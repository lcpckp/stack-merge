<!DOCTYPE html>
<!-- saved from url=(0022)http://localhost:8000/ -->
<html lang="en" style="--animation-speed: 1; --stack-height: 542px;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="theme-color" content="#0f172a">
<meta name="msapplication-navbutton-color" content="#0f172a">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Stack Merge</title>
<link rel="icon" type="image/png" href="favicon.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Quantico:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
  /* Prevent white background flashing on mobile */
  html {
    background: #0f172a;
    height: 100%;
    overflow-x: hidden; /* Prevent horizontal scrolling */
    overflow-y: auto; /* Allow vertical scrolling */
    max-width: 100vw; /* Prevent page from exceeding viewport width */
    margin: 0;
    padding: 0;
  }
  
  :root{ 
    --bg:#0f172a; 
    --panel:#1e293b; 
    --text:#f8fafc; 
    --font-family: 'Quantico', monospace;
    
    /* Theme colors are now handled dynamically via JavaScript */
  }
  
  /* Prevent double-tap zoom on all elements */
  * {
    touch-action: manipulation;
  }
  
  /* Disable text selection and dragging */
  * {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-user-drag: none;
    -khtml-user-drag: none;
    -moz-user-drag: none;
    -o-user-drag: none;
  }
  
  /* Allow text selection for input fields and textareas */
  input, textarea {
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
  }
  
  /* Prevent mobile long-press highlight on pole elements */
  .pole {
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-user-drag: none;
    -khtml-user-drag: none;
    -moz-user-drag: none;
    -o-user-drag: none;
  }
  
  /* Prevent focus outline on pole elements */
  .pole:focus {
    outline: none !important;
    -webkit-tap-highlight-color: transparent !important;
  }
  
  /* Prevent mobile long-press highlight on powerup buttons */
  .powerup-btn {
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-user-drag: none;
    -khtml-user-drag: none;
    -moz-user-drag: none;
    -o-user-drag: none;
  }
  
  /* Prevent focus outline on powerup buttons */
  .powerup-btn:focus {
    outline: none !important;
    -webkit-tap-highlight-color: transparent !important;
  }
  
  /* Prevent focus outline on modal close buttons */
  .help-modal-close-btn:focus,
  .shop-modal-close-btn:focus {
    outline: none !important;
    -webkit-tap-highlight-color: transparent !important;
  }
  
  /* Prevent focus outline on new game modal buttons */
  .new-game-btn:focus,
  .confirm-new-game-btn:focus,
  .cancel-new-game-btn:focus {
    outline: none !important;
    -webkit-tap-highlight-color: transparent !important;
  }
  
  /* Prevent focus outline on modal containers */
  .modal:focus,
  .new-game-modal:focus,
  .help-modal:focus,
  .shop-modal:focus,
  .sound-control-modal:focus,
  .settings-modal:focus {
    outline: none !important;
    -webkit-tap-highlight-color: transparent !important;
  }
  
  /* More specific powerup button focus prevention */
  .powerup-btn:focus,
  .powerup-btn:focus-visible,
  .powerup-btn:focus-within {
    outline: none !important;
    -webkit-tap-highlight-color: transparent !important;
    box-shadow: none !important;
  }
  
  /* Nuclear option: Remove focusability entirely from powerup buttons */
  .powerup-btn {
    -webkit-tap-highlight-color: transparent !important;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0) !important;
    outline: none !important;
    box-shadow: none !important;
  }
  
  /* Force remove all focus styles globally for buttons */
  button:focus,
  button:focus-visible,
  button:focus-within,
  [role="button"]:focus,
  [role="button"]:focus-visible,
  [role="button"]:focus-within {
    outline: none !important;
    -webkit-tap-highlight-color: transparent !important;
    box-shadow: none !important;
  }
  

  
  /* Mobile hover disable rules */
  @media (hover: none) and (pointer: coarse) {
    /* Disable help modal hover effects */
    .help-modal-close-btn:hover,
    .help-modal .stats-btn:hover,
    .help-modal button.stats-btn:hover,
    .help-modal #showStatsBtn:hover {
      background: inherit !important;
      transform: none !important;
    }
    
    /* Disable reset data button hover effects */
    #resetDataBtn:hover {
      background-color: inherit !important;
      transform: none !important;
    }
    
    /* Disable block item hover effects */
    .block-item:hover,
    .debug-pane .block-item:hover,
    .block-item.no-block:hover {
      transform: none !important;
      box-shadow: inherit !important;
      border-color: inherit !important;
      background: inherit !important;
    }
    
    /* Disable debug pane button hover effects */
    .debug-pane .button:hover,
    .debug-pane .button.primary:hover,
    .debug-pane .close-btn:hover {
      background: inherit !important;
    }
    
    /* Disable modal hover effects */
    .new-game-modal:hover {
      border-color: inherit !important;
      box-shadow: inherit !important;
    }
    
    /* Disable button hover effects */
    .new-game-btn:hover,
    .confirm-new-game-btn:hover,
    .cancel-new-game-btn:hover {
      background: inherit !important;
      transform: none !important;
    }
    
    /* Disable sound control hover effects */
    .sound-control-mute:hover,
    .sound-control-mute.muted:hover {
      background: inherit !important;
      border-color: inherit !important;
    }
    
    /* Disable theme selector hover effects */
    .theme-selector:hover {
      border-color: inherit !important;
    }
    

    
    /* Disable focus outlines and blue borders on mobile */
    *:focus {
      outline: none !important;
      border-color: inherit !important;
      box-shadow: none !important;
    }
    
    .theme-selector:focus {
      outline: none !important;
      border-color: inherit !important;
      box-shadow: none !important;
    }
    
    /* Disable prob test close hover */
    .prob-test-close:hover {
      background: inherit !important;
    }
  }
  
  body { 
    margin:0; 
    font-family: var(--font-family); 
    background:var(--bg); 
    color:var(--text); 
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    min-height: 100vh; /* Allow content to expand beyond viewport height */
    overflow-x: hidden; /* Prevent horizontal scrolling */
    overflow-y: auto; /* Allow vertical scrolling */
    max-width: 100vw; /* Prevent page from exceeding viewport width */
    /* Prevent background flashing on mobile */
    background-color: var(--bg);
    background-image: none;
  }
  
  /* Development mode - enable scrolling for debug access */
  body.development-mode {
    overflow: auto; /* Allow scrolling in development */
    min-height: 100vh; /* Ensure minimum height while allowing content to expand */
  }
  
  /* Mobile viewport constraints */
  @media (max-width: 768px) {
    body {
      max-width: 100vw;
      overflow-x: hidden;
      margin: 0;
      padding: 0;
    }
    
    .topbar {
      max-width: 100%;
      padding: 4px 12px 8px;
      margin: 0;
    }
    
    h1 {
      font-size: 28px;
      margin: 0;
    }
  }
  
  /* Global horizontal scroll prevention */
  * {
    max-width: 100%;
    box-sizing: border-box;
  }
  
  /* Prevent horizontal scrolling at document level */
  html, body {
    overflow-x: hidden !important;
    max-width: 100vw !important;
    width: 100% !important;
  }
  
  /* Ensure no element can cause horizontal overflow */
  .topbar,
  .title-section,
  .game-container,
  .powerup-shop {
    max-width: 100%;
    overflow-x: hidden;
    overflow-y: visible; /* Allow badges to extend vertically */
  }
  
  /* Ensure debug button is accessible on mobile in development */
  body.development-mode #debugBtn {
    position: relative;
    z-index: 1000;
    margin-bottom: 20px; /* Add some bottom margin for mobile scrolling */
  }
  .topbar { width:100%; max-width:1200px; display:flex; flex-direction:column; align-items:center; gap:16px; padding:12px 16px 8px; box-sizing:border-box; }
  h1 { 
    margin:0; 
    font-size:40px; 
    font-weight:700; 
    text-align:center; 
    font-family: var(--font-family); 
    line-height: 1.0;
    white-space: normal;
    overflow: hidden;
    max-height: none;
  }
  
  /* Title section styling - 3-column layout */
  .title-section { 
    display: grid;
    grid-template-columns: auto 1fr auto;
    align-items: center;
    width: 100%;
    max-width: 800px;
    margin: 12px auto 12px;
    gap: 16px;
    /* Prevent viewport shifting on mobile */
    transform: translateZ(0);
    will-change: auto;
    /* Force stable positioning */
    backface-visibility: hidden;
    perspective: 100px;
    padding: 0 24px;
    /* Prevent any scrolling */
    overflow: hidden;
    max-height: none;
  }
  
  /* Left section - centered in left grid area */
  .title-section .left-section {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    /* Force stable positioning */
    transform: translateZ(0);
    will-change: auto;
    backface-visibility: hidden;
    /* Ensure buttons scale to accommodate title */
    grid-column: 1;
    justify-self: end;
    min-width: fit-content;
  }
  
  /* Center section - centered title */
  .title-section .center-section {
    display: flex;
    align-items: center;
    justify-content: center;
    /* Force stable positioning */
    will-change: auto;
    backface-visibility: hidden;
    /* Prevent mobile viewport interference */
    touch-action: manipulation;
    /* Allow title text wrapping */
    white-space: normal;
    overflow: hidden;
    text-overflow: clip;
    min-width: 0;
    flex: 1;
    /* Ensure title is always centered on screen */
    grid-column: 2;
    justify-self: center;
    /* Prevent any scrolling */
    max-height: none;
  }
  
  /* Right section - centered in right grid area */
  .title-section .right-section {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    /* Force stable positioning */
    transform: translateZ(0);
    will-change: auto;
    backface-visibility: hidden;
    /* Ensure buttons scale to accommodate title */
    grid-column: 3;
    justify-self: start;
    min-width: fit-content;
  }
  
  /* Title button styling */
  .title-btn {
    background: var(--panel);
    color: var(--text);
    border: 1px solid #475569;
    width: 48px;
    height: 48px;
    border-radius: 10px;
    font-weight: 700;
    font-size: 24px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    font-family: var(--font-family);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  
  .title-btn:hover {
    background: #334155;
    border-color: #64748b;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(0,0,0,0.25);
  }
  
  .title-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
  }
  
  /* Glowing ➕ button after game over */
  .title-btn.game-over-glow {
    box-shadow: 0 0 8px rgba(14, 165, 233, 0.6), 0 0 16px rgba(14, 165, 233, 0.4), 0 0 24px rgba(14, 165, 233, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    animation: breatheGlow 1.5s ease-in-out infinite;
    border-color: #3b82f6;
  }
  
  /* Glowing ❔ button for new players */
  .title-btn.help-glow {
    box-shadow: 0 0 8px rgba(239, 68, 68, 0.6), 0 0 16px rgba(239, 68, 68, 0.4), 0 0 24px rgba(239, 68, 68, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    animation: breatheGlowRed 1.5s ease-in-out infinite;
    border-color: #ef4444;
  }
  
  /* Glowing 🎨 button when new theme is unlocked */
  .title-btn.settings-glow {
    box-shadow: 0 0 8px rgba(34, 197, 94, 0.6), 0 0 16px rgba(34, 197, 94, 0.4), 0 0 24px rgba(34, 197, 94, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    animation: breatheGlowGreen 1.5s ease-in-out infinite;
    border-color: #22c55e;
  }
  
  /* Sound button states */
  .title-btn#soundBtn {
    transition: all 0.2s ease;
  }
  
  .title-btn#soundBtn:hover {
    transform: scale(1.05);
  }
  

  
  @keyframes breatheGlow {
    0%, 100% { 
      box-shadow: 0 0 8px rgba(14, 165, 233, 0.6), 0 0 16px rgba(14, 165, 233, 0.4), 0 0 24px rgba(14, 165, 233, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    }
    50% { 
      box-shadow: 0 0 12px rgba(14, 165, 233, 0.8), 0 0 20px rgba(14, 165, 233, 0.6), 0 0 28px rgba(14, 165, 233, 0.4), 0 3px 0 rgba(0,0,0,0.25);
    }
  }
  
  @keyframes breatheGlowRed {
    0%, 100% { 
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.6), 0 0 16px rgba(239, 68, 68, 0.4), 0 0 24px rgba(239, 68, 68, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    }
    50% { 
      box-shadow: 0 0 12px rgba(239, 68, 68, 0.8), 0 0 20px rgba(239, 68, 68, 0.6), 0 0 28px rgba(239, 68, 68, 0.4), 0 3px 0 rgba(0,0,0,0.25);
    }
  }
  
  @keyframes breatheGlowGreen {
    0%, 100% { 
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.6), 0 0 16px rgba(34, 197, 94, 0.4), 0 0 24px rgba(34, 197, 94, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    }
    50% { 
      box-shadow: 0 0 12px rgba(34, 197, 94, 0.8), 0 0 20px rgba(34, 197, 94, 0.6), 0 0 28px rgba(34, 197, 94, 0.4), 0 3px 0 rgba(0,0,0,0.25);
    }
  }
  
  /* Mobile responsive sizing for title buttons */
  @media (max-width: 768px) {
    .title-btn {
      width: 44px !important;
      height: 44px !important;
      border-radius: 10px !important;
      font-size: 22px !important;
    }
    
    .title-section {
      gap: 8px;
      padding: 0 16px;
      grid-template-columns: minmax(80px, auto) minmax(160px, 1fr) minmax(80px, auto);
      max-width: 100%;
      margin: 16px 16px 8px;
    }
    
    /* Prevent viewport shifting on mobile */
    .title-section {
      transform: translateZ(0);
      will-change: auto;
      position: relative;
      /* Force stable positioning */
      backface-visibility: hidden;
      perspective: 1000px;
    }
    
    .title-section .left-section,
    .title-section .right-section {
      transform: translateZ(0);
      will-change: auto;
      backface-visibility: hidden;
    }
  }
  
  /* Mobile responsive spacing for title sections */
  @media (max-width: 768px) {
    .title-section .left-section {
      gap: 12px; /* Increased gap for much bigger buttons */
    }
    
    .title-section .right-section {
      gap: 12px; /* Increased gap for much bigger buttons */
    }
    
    /* Force button sizing with high specificity */
    .title-section .title-btn {
      width: 44px !important;
      height: 44px !important;
      border-radius: 10px !important;
      font-size: 22px !important;
      min-width: 44px !important;
      min-height: 44px !important;
    }
    
    /* Ensure title text has enough space on mobile */
    .title-section .center-section {
      min-width: 160px;
      padding: 0 2px;
    }
    
    .title-section .center-section h1 {
      white-space: normal;
      overflow: hidden;
      text-overflow: clip;
      max-width: 100%;
      font-size: 24px !important;
      line-height: 1.0;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    
    /* Make button sections more compact on mobile */
    .title-section .left-section,
    .title-section .right-section {
      min-width: 80px;
      max-width: 100px;
      justify-self: center;
    }
  }
  
      /* Mobile responsive game area and powerup shop */
  @media (max-width: 768px) {
    .game-container {
      margin-top: 24px;
      padding: 0 16px 8px;
      overflow-x: hidden;
    }
    
    .game {
      gap: 16px;
      justify-content: center;
    }
    
    .pole {
      width: 120px;
      height: clamp(400px, 60vh, 500px);
    }
    
    .disc {
      width: 90px;
      height: 36px;
      font-size: 20px;
    }
    
    .powerup-shop {
      margin-top: 0px !important;
      margin-bottom: 8px !important;
      padding: 0 16px !important;
      /* Ensure powerup shop is always visible on mobile */
      position: relative;
      z-index: 10;
      background: var(--bg);
      /* Force display and ensure proper positioning */
      display: flex !important;
      visibility: visible !important;
      overflow: visible;
      opacity: 1 !important;
    }
    
    .shop-grid {
      gap: 12px;
      flex-wrap: nowrap;
    }
    
    .powerup-btn {
      flex: 0 0 calc(25% - 9px); /* 25% minus 1/4 of the total gap space (36px / 4 = 9px) */
      min-width: 0;
      min-height: clamp(60px, 15vw, 80px);
      max-height: clamp(60px, 15vw, 80px);
      padding: 0 12px;
      max-width: none;
    }
    

    
    /* Ensure game container doesn't take up too much space */
    .game-container {
      margin-bottom: 0 !important;
      padding-bottom: 16px !important;
    }
  }
  
  /* Medium desktop - slightly more compact */
  @media (min-width: 769px) and (max-width: 1200px) {
    .title-section {
      max-width: 700px;
    }
  }
  
  /* Large desktop - more compact */
  @media (min-width: 1201px) {
    .title-section {
      max-width: 600px;
    }
  }
  
  /* Extra small mobile devices - adjust title section spacing */
  @media (max-width: 480px) {
    .title-section {
      gap: 8px;
      padding: 0 16px;
      grid-template-columns: 1fr auto 1fr;
      max-width: 100%;
      margin: 24px 12px 16px;
    }
    
    .title-btn {
      width: 36px;
      height: 36px;
      border-radius: 7px;
      font-size: 18px;
    }
    
    .title-section .left-section {
      gap: 6px; /* Smaller gap for very small screens */
    }
    
    .title-section .right-section {
      gap: 6px; /* Smaller gap for very small screens */
    }
  }
  
  /* Fallback for very small screens where grid might not work well */
  @media (max-width: 360px) {
    .title-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }
    
    .title-section .left-section,
    .title-section .center-section,
    .title-section .right-section {
      justify-content: center;
    }
  }
    
      /* Extra small mobile adjustments */
  .game-container {
    margin-top: 16px;
    padding: 0 12px 6px;
  }
  
  .game {
    gap: 12px;
  }
  
  .pole {
    width: 100px;
    height: clamp(350px, 55vh, 450px);
  }
  
  .disc {
    width: 80px;
    height: 32px;
    font-size: 18px;
  }
  
  .powerup-shop {
    margin-top: 0px !important;
    margin-bottom: 8px !important;
    padding: 0 12px !important;
    /* Ensure visibility on extra small screens */
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    z-index: 10;
    width: 100%;
    max-width: 100%;
    overflow: visible;
  }
  
  .shop-grid {
    gap: 8px;
    flex-wrap: wrap;
  }
  
  .powerup-btn {
    min-width: 0;
    min-height: clamp(50px, 12vw, 70px);
    max-height: clamp(50px, 12vw, 70px);
    padding: 0 clamp(6px, 1.5vw, 12px);
    width: 100%;
  }
  
  /* Disable hover effects on mobile/touch devices */
  @media (hover: none) and (pointer: coarse) {
    .title-btn:hover {
      transform: none;
      box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    }
    
    .title-btn#soundBtn:hover {
      transform: none;
    }
  }
  

  
  /* Controls section styling */
  .controls { display:flex; align-items:center; gap:18px; }

  .game-info { 
    display: grid; 
    grid-template-columns: 1fr auto 1fr; 
    grid-template-areas: "score next gold";
    align-items: center; 
    gap: 48px; 
    margin-top: 32px; /* Reduced spacing between title and game info */
    width: auto; /* Allow natural expansion */
    max-width: none; /* Remove max-width constraint */
    margin-left: auto;
    margin-right: auto;
    position: relative;
    padding: 0 24px;
    overflow: visible;

  }
  .score-display { 
    display: flex; 
    justify-content: flex-end; 
    justify-self: end;
    grid-area: score;
    width: auto; /* Allow natural expansion */
  }
  .score-label { 
    font-size: 16px; 
    opacity: 0.9; 
    font-family: var(--font-family);
    text-align: center;
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    white-space: nowrap;
    z-index: 1000;
    pointer-events: none;
    margin-bottom: 8px;
  }
  .next { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 12px; 
    justify-self: center;
    grid-area: next;
    position: relative;
    /* Ensure next queue is always centered regardless of score/gold sizes */
    z-index: 10;
  }
  .next .label { 
    font-size: 16px; 
    font-weight: 600;
    opacity: 0.9; 
    font-family: var(--font-family);
    text-align: center;
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    white-space: nowrap;
    z-index: 1000;
    pointer-events: none;
    margin-bottom: 8px;
  }
  .next-row { display:flex; align-items:center; gap:12px; }
  .next-disc { width:108px; height:45px; border-radius:9px; display:flex; align-items:center; justify-content:center; font-weight:600; font-size:24px; box-shadow:0 3px 0 rgba(0,0,0,0.25); transition: transform calc(0.18s * var(--animation-speed, 1)) ease; font-family: var(--font-family); transform-origin: center center; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
  .next-disc.current { outline:3px solid #fff; outline-offset:3px; }
  .next-disc.consume-out { 
    animation: nextConsume calc(0.18s * var(--animation-speed, 1)) ease forwards; 
    transition: none; /* Disable transition during animation to prevent conflicts */
  }
  @keyframes nextConsume {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0.85); opacity: 0; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .next-disc.consume-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.85); opacity: 0; }
  .next-disc.shift-left { transform: translateX(-120px); }
  
  /* Instant animations when speed is 0 (Blazing) */
  .next-disc.shift-left[style*="--animation-speed: 0"] { transform: translateX(-120px); }

  /* Swap animation classes */
  .next-disc.swap-animation-1 { 
    animation: swapBlock1 calc(0.3s * var(--animation-speed, 1)) ease-in-out forwards; 
    transition: none; /* Disable transition during animation to prevent conflicts */
    z-index: 10;
  }
  .next-disc.swap-animation-2 { 
    animation: swapBlock2 calc(0.3s * var(--animation-speed, 1)) ease-in-out forwards; 
    transition: none; /* Disable transition during animation to prevent conflicts */
    z-index: 10;
  }
  
  @keyframes swapBlock1 {
    0% { transform: translateX(0) scale(1); }
    50% { transform: translateX(60px) scale(1.1); }
    100% { transform: translateX(120px) scale(1); }
  }
  
  @keyframes swapBlock2 {
    0% { transform: translateX(0) scale(1); }
    50% { transform: translateX(-60px) scale(1.1); }
    100% { transform: translateX(-120px) scale(1); }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .next-disc.swap-animation-1[style*="--animation-speed: 0"] { animation: none; transform: translateX(120px) scale(1); }
  .next-disc.swap-animation-2[style*="--animation-speed: 0"] { animation: none; transform: translateX(-120px) scale(1); }

  
  /* Score value styling to match other modules */
      .score-value { 
    background: var(--panel); 
    color: var(--text); 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 24px; 
    min-width: 120px; 
    width: auto; /* Allow natural expansion */
    max-width: none; /* Remove any max-width constraints */
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    white-space: nowrap;
    overflow: visible; /* Ensure content doesn't get clipped */

  }
  
  /* Score star emoji styling as a badge in top left corner */
  .score-star {
    position: absolute;
    top: -12px;
    left: -12px;
    font-size: 28px;
    opacity: 1;
    z-index: 10;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    pointer-events: none;
  }
  
  .score-text {
    position: relative;
    z-index: 2;
    font-size: 28px;
    font-weight: 600;
    line-height: 1;
    font-family: var(--font-family);
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  /* Score comma styling - smaller than digits but same color */
  .score-comma {
    font-size: 22px;
    opacity: 1;
    font-weight: 400;
    color: inherit;
  }

  /* Gold display styling to match score display */
  .gold-display { 
    display: flex; 
    justify-content: flex-start; 
    justify-self: start;
    grid-area: gold;
    width: auto; /* Allow natural expansion */
  }
  
  /* Score-gold container for desktop layout */
  .score-gold-container {
    display: contents; /* On desktop, this doesn't affect the grid layout */
  }
  
  /* Ensure score and gold displays maintain their grid positioning on desktop */
  .score-display {
    grid-area: score;
  }
  
  .gold-display {
    grid-area: gold;
  }
  
  /* Ensure the next section stays in the middle column on desktop */
  .next {
    grid-area: next;
  }
  .gold-label { 
    font-size: 16px; 
    opacity: 0.9; 
    font-family: var(--font-family);
    text-align: center;
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    white-space: nowrap;
    z-index: 1000;
    pointer-events: none;
    margin-bottom: 8px;
    color: white;
  }
        .gold-value { 
    background: #FCD34D; 
    color: #000; 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 24px; 
    min-width: 120px; 
    width: auto; /* Allow natural expansion */
    max-width: none; /* Remove any max-width constraints */
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    white-space: nowrap;
    overflow: visible; /* Ensure content doesn't get clipped */
  }
  
  /* Gold emoji styling as a badge in top left corner */
  .gold-emoji {
    position: absolute;
    top: -12px;
    left: -12px;
    font-size: 28px;
    opacity: 1;
    z-index: 10;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    pointer-events: none;
  }
  
  .gold-text {
    position: relative;
    z-index: 2;
    font-size: 28px !important;
    font-weight: 600;
    line-height: 1;
    font-family: var(--font-family);
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  /* Stage multiplier badge styling centered on lower edge of gold counter */
  .stage-multiplier-badge {
    position: absolute;
    bottom: -16px;
    left: 50%;
    transform: translateX(-50%);
    background: #dc2626;
    color: white;
    font-size: 12px;
    font-weight: 700;
    padding: 4px 6px;
    border-radius: 8px;
    border: 2px solid var(--bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 10;
    font-family: var(--font-family);
    min-width: 20px;
    text-align: center;
    line-height: 1;
    box-sizing: border-box;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  /* Disabled gold cost badge styling */
  .powerup-cost-badge.disabled {
    background: #fbbf24; /* Keep same gold color */
    color: black; /* Keep black text for readability */
    opacity: 0.7; /* Reduced opacity for disabled appearance */
  }

  /* Powerup ownership badge styling centered on lower edge of powerup buttons */
  .powerup-ownership-badge {
    position: absolute;
    bottom: -14px;
    left: 50%;
    transform: translateX(-50%);
    background: #dc2626; /* Default red for 0 owned */
    color: white;
    font-size: 11px;
    font-weight: 700;
    padding: 3px 5px;
    border-radius: 8px;
    border: 2px solid var(--bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 10;
    font-family: var(--font-family);
    min-width: 18px;
    text-align: center;
    line-height: 1;
    box-sizing: border-box;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    transition: background-color 0.3s ease;
  }
  
  /* Badge color classes based on ownership count */
  .powerup-ownership-badge.count-0 {
    background: #dc2626; /* Red for 0 owned */
  }
  
  .powerup-ownership-badge.count-1-plus {
    background: #16a34a; /* Green for 1+ owned */
  }
  

  
  /* Bottom gold cost badge styling */
  .powerup-cost-badge {
    position: absolute;
    bottom: -14px;
    left: 50%;
    transform: translateX(-50%);
    background: #fbbf24; /* Gold color matching main display */
    color: black;
    font-size: 11px;
    font-weight: 700;
    padding: 3px 5px;
    border-radius: 8px;
    border: 2px solid var(--bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 10;
    font-family: var(--font-family);
    min-width: 18px;
    text-align: center;
    line-height: 1;
    box-sizing: border-box;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    transition: background-color 0.3s ease;
    /* Allow badge to expand beyond button boundaries */
    overflow: visible;
    max-width: none;
    width: auto;
  }
  
  /* Stage multiplier badge pulse animation */
  .stage-multiplier-badge.pulse {
    animation: stageBadgePulse 0.6s ease-out;
  }
  
  @keyframes stageBadgePulse {
    0% { transform: translateX(-50%) scale(1); }
    50% { transform: translateX(-50%) scale(1.2); }
    100% { transform: translateX(-50%) scale(1); }
  }
  
  /* Score count pulse animation */
  .score-value.pulse {
    animation: scorePulse 0.3s ease-out;
  }
  
  @keyframes scorePulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  
  /* Gold earned animation */
  .gold-earned {
    position: fixed;
    color: #FCD34D;
    font-weight: 700;
    font-size: 20px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
    z-index: 1000;
    pointer-events: none;
    animation: goldEarned 1.2s ease-out forwards;
  }
  
  @keyframes goldEarned {
    0% {
      opacity: 0;
      transform: translateY(0) scale(0.8);
    }
    15% {
      opacity: 1;
      transform: translateY(-15px) scale(1.2);
    }
    70% {
      opacity: 1;
      transform: translateY(-45px) scale(1.1);
    }
    100% {
      opacity: 0;
      transform: translateY(-65px) scale(1);
    }
  }

  /* Personal best animation */
  .personal-best {
    position: fixed;
    color: #fbbf24;
    font-weight: 700;
    font-size: 18px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
    z-index: 1000;
    pointer-events: none;
    animation: personalBest 3s ease-out forwards;
  }
  
  @keyframes personalBest {
    0% {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.7);
    }
    20% {
      opacity: 1;
      transform: translate(-50%, calc(-50% - 8px)) scale(1.1);
    }
    40% {
      opacity: 1;
      transform: translate(-50%, calc(-50% - 12px)) scale(1);
    }
    100% {
      opacity: 0;
      transform: translate(-50%, calc(-50% - 30px)) scale(1);
    }
  }
  
  /* Gold count pulse animation */
  .gold-value.pulse {
    animation: goldPulse 0.3s ease-out;
  }
  
  @keyframes goldPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }



  /* AI button styling to match score-value and interface */
  .ai-btn {
    background: var(--panel);
    color: var(--text);
    border: 1px solid #475569;
    padding: 12px 24px;
    border-radius: 9px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    font-family: var(--font-family);
  }
  .ai-btn:hover {
    background: #334155;
    border-color: #64748b;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(0,0,0,0.25);
  }
  .ai-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
  }
  


  .hidden { display:none !important; }

  /* Help modal */
  .modal-backdrop { 
    position:fixed; 
    inset:0; 
    background:rgba(0,0,0,0.6); 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    z-index:1000; 
    /* Ensure backdrop respects safe areas with extra buffer for mobile UI controls */
    padding: calc(env(safe-area-inset-top, 0px) + 20px) calc(env(safe-area-inset-left, 0px) + 16px) calc(env(safe-area-inset-bottom, 0px) + 20px) calc(env(safe-area-inset-right, 0px) + 16px);
    box-sizing: border-box;
  }
  .modal { 
    background:var(--panel); 
    color:var(--text); 
    width:min(720px, 92vw); 
    border-radius:16px; 
    padding:24px 28px; 
    box-shadow:0 15px 45px rgba(0,0,0,0.4); 
    font-family: var(--font-family); 
    /* Ensure modal respects safe areas with extra buffer for mobile UI controls */
    max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 120px);
  }
  .modal h2 { margin:0 0 12px; font-size:24px; font-family: var(--font-family); }
  .modal p, .modal li { font-size:16px; line-height:1.5; font-family: var(--font-family); }
  .modal ul { margin:12px 0 0 24px; padding:0; }
  .modal .actions { display:flex; justify-content:flex-end; margin-top:18px; }
  
  /* Mobile responsive sizing for help modal stage progression elements */
  @media (max-width: 768px) {
    /* Ensure modal is properly positioned on mobile with safe areas */
    .help-modal {
      max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 120px);
      margin: 0;
      padding: 20px;
      /* Ensure content is properly spaced from edges */
      box-sizing: border-box;
    }
    
    /* Ensure modal title has proper spacing and layout */
    .help-modal h2 {
      margin-top: 0 !important;
      padding-top: 0 !important;
      display: flex !important;
      justify-content: space-between !important;
      align-items: center !important;
      width: 100% !important;
    }

      /* High score display in help modal title */
  
  .help-modal .title-text {
    font-size: 1em !important;
    color: var(--text) !important;
    font-weight: 700 !important;
  }
  
  /* Stats button styling - Manual reset approach */
  .help-modal .stats-btn,
  .help-modal button.stats-btn,
  .help-modal #showStatsBtn {
    /* Manual reset of button defaults instead of all: unset */
    font-size: 0.8em !important;
    color: var(--text) !important;
    font-weight: 500 !important;
    margin: 0 !important;
    margin-left: auto !important;
    padding: 6px 12px !important;
    
    /* Background and border */
    background: #334155 !important;
    background-color: #334155 !important;
    background-image: none !important;
    border: 1px solid #475569 !important;
    border-radius: 8px !important;
    
    /* Layout and display */
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-sizing: border-box !important;
    vertical-align: middle !important;
    white-space: nowrap !important;
    text-align: center !important;
    line-height: 1 !important;
    
    /* Interaction */
    cursor: pointer !important;
    user-select: none !important;
    outline: none !important;
    text-decoration: none !important;
    
    /* Remove browser button styling */
    appearance: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    
    /* Effects */
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2) !important;
    transition: all 0.2s ease !important;
    font-family: var(--font-family) !important;
    
    /* Force dimensions */
    min-height: auto !important;
    min-width: auto !important;
    height: auto !important;
    width: auto !important;
  }

  /* Desktop-specific styling to override mobile styles */
  @media (min-width: 769px) {
    .help-modal .stats-btn,
    .help-modal button.stats-btn,
    .help-modal #showStatsBtn {
      font-size: 0.8em !important;
      padding: 6px 12px !important;
      background: #334155 !important;
      background-color: #334155 !important;
      border: 1px solid #475569 !important;
      border-color: #475569 !important;
      color: var(--text) !important;
      font-weight: 500 !important;
      font-family: var(--font-family) !important;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2) !important;
      border-radius: 8px !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      margin-left: auto !important;
      cursor: pointer !important;
      transition: all 0.2s ease !important;
      appearance: none !important;
      -webkit-appearance: none !important;
    }
  }
  
  .help-modal .stats-btn:hover,
  .help-modal button.stats-btn:hover,
  .help-modal #showStatsBtn:hover {
    background: #475569 !important;
    background-color: #475569 !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3) !important;
  }
  
  .help-modal .stats-btn:active,
  .help-modal button.stats-btn:active,
  .help-modal #showStatsBtn:active {
    transform: translateY(0) !important;
    background: #334155 !important;
    background-color: #334155 !important;
  }

  /* Desktop-specific hover and active states */
  @media (min-width: 769px) {
    .help-modal .stats-btn:hover,
    .help-modal button.stats-btn:hover,
    .help-modal #showStatsBtn:hover {
      background: #475569 !important;
      background-color: #475569 !important;
      transform: translateY(-1px) !important;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3) !important;
    }
    
    .help-modal .stats-btn:active,
    .help-modal button.stats-btn:active,
    .help-modal #showStatsBtn:active {
      transform: translateY(0) !important;
      background: #334155 !important;
      background-color: #334155 !important;
    }
  }
    
    /* Ensure close button has proper spacing */
    .help-modal .actions {
      margin-bottom: 0;
      padding-bottom: 0;
    }
    
    /* Make target blocks smaller in help modal */
    .help-modal .next-stage-block {
      width: 70px !important;
      height: 32px !important;
      font-size: 16px !important;
    }
    
    /* Make gold displays smaller in help modal */
    .help-modal .gold-value {
      padding: 6px 12px !important;
      font-size: 16px !important;
      min-width: 60px !important;
    }
    
    /* Make gold emojis smaller in help modal */
    .help-modal .gold-emoji {
      font-size: 18px !important;
      top: -6px !important;
      left: -6px !important;
    }
    
    /* Make gold text smaller in help modal */
    .help-modal .gold-text {
      font-size: 16px !important;
    }
    
    /* Make stage multiplier badges smaller in help modal */
    .help-modal .stage-multiplier-badge {
      font-size: 10px !important;
      padding: 2px 4px !important;
      bottom: -10px !important;
      min-width: 16px !important;
    }
    
    /* Reduce gaps in help modal stage progression */
    .help-modal .merge-example[style*="gap: 40px"] {
      gap: 16px !important;
    }
    
    .help-modal [style*="gap: 40px"] {
      gap: 16px !important;
    }
    
    /* Make the stage progression examples more compact on mobile */
    .help-modal [style*="max-width: 600px"] {
      max-width: 90vw !important;
    }
  }

  /* Enhanced Help Modal Styles */
  .help-modal { 
    width: min(900px, 95vw); 
    max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 120px); 
    overflow-y: auto; 
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    /* Ensure modal fits within safe area */
    margin: 0;
    position: absolute;
    top: 20px; /* Default top position for desktop */
  }

  /* Override modal backdrop padding for help modal to allow proper positioning */
  .help-modal-backdrop {
    padding: 0;
    align-items: flex-start;
    justify-content: center;
  }

  /* Shop modal styling */
  .shop-modal-backdrop {
    padding: 0;
    align-items: flex-start;
    justify-content: center;
  }

  .shop-modal {
    background: var(--panel);
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 24px;
    max-width: 400px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    margin-top: 80px; /* Start below the close button with proper spacing */
  }
  
  /* Desktop positioning for shop modal - start below close button */
  @media (min-width: 769px) {
    .shop-modal {
      margin-top: 80px; /* Start below the close button with proper spacing */
    }
  }

  .shop-modal-close-btn {
    position: fixed;
    top: 20px;
    right: calc(50vw - min(200px, 20vw) + 20px); /* Position relative to 400px modal width (200px is half) */
    background: var(--bg);
    color: var(--text);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    font-family: var(--font-family);
    font-weight: 500;
    transition: all 0.2s ease;
  }

  /* Shop modal header layout */
  .shop-modal-header {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    margin-bottom: 20px;
    position: relative;
    height: 60px; /* Give the header a fixed height to align properly */
  }

  .shop-modal-header h2 {
    margin: 0;
    text-align: left;
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%); /* Center vertically based on center line, same as gold display */
  }

  .shop-modal-header .title-text {
    font-size: 28px;
    font-weight: 700;
    color: var(--text);
    font-family: var(--font-family);
  }

  /* Shop gold display styling - replicate main gold display */
  .shop-gold-display {
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%); /* Center vertically to align with title */
  }

  .shop-gold-value {
    background: #FCD34D;
    color: #000;
    padding: 10px 20px;
    border-radius: 9px;
    font-weight: 600;
    font-size: 16px;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    min-width: 100px;
    text-align: center;
  }

  .shop-gold-emoji {
    position: absolute;
    top: -12px;
    left: -12px;
    font-size: 28px;
    opacity: 1;
    z-index: 1;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    pointer-events: none;
  }

  .shop-gold-text {
    position: relative;
    z-index: 2;
    font-size: 28px;
    font-weight: 600;
    line-height: 1;
    color: #000;
    font-family: var(--font-family);
  }

  /* Shop gold display shrinking animation for purchases */
  .shop-gold-value.shrink {
    animation: shopGoldShrink 0.3s ease-out;
  }

  @keyframes shopGoldShrink {
    0% { transform: scale(1); }
    50% { transform: scale(0.9); }
    100% { transform: scale(1); }
  }

  /* Badge scale animation for item shop purchases */
  @keyframes badgeScale {
    0% { transform: translateX(-50%) scale(1); }
    50% { transform: translateX(-50%) scale(1.2); }
    100% { transform: translateX(-50%) scale(1); }
  }
  
  .powerup-ownership-badge.scale-animation {
    animation: badgeScale 0.4s ease-out;
  }

  /* Gold lost animation for item shop */
  .gold-lost {
    position: fixed;
    color: #ef4444;
    font-weight: 700;
    font-size: 20px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
    z-index: 1000;
    pointer-events: none;
    animation: goldLost 1.2s ease-out forwards;
  }

  @keyframes goldLost {
    0% {
      opacity: 0;
      transform: translateY(0) scale(0.8);
    }
    15% {
      opacity: 1;
      transform: translateY(15px) scale(1.2);
    }
    70% {
      opacity: 1;
      transform: translateY(45px) scale(1.1);
    }
    100% {
      opacity: 0;
      transform: translateY(65px) scale(1);
    }
  }

  /* Shop separator styling */
  .shop-separator {
    height: 1px;
    background: rgba(255, 255, 255, 0.2);
    margin: 20px 0;
    border: none;
  }

  /* Shop footer styling */
  .shop-footer {
    margin-top: 20px;
    padding-top: 16px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
  }

  .shop-tooltip {
    text-align: center;
    font-size: 14px;
    color: rgba(255, 255, 255, 0.7);
    font-family: var(--font-family);
    font-style: italic;
  }
  
  /* Desktop-only hover effects for shop modal */
  @media (hover: hover) and (pointer: fine) {
    .shop-modal-close-btn:hover {
      background: #334155;
      border-color: #0ea5e9;
    }
    
    .shop-item-btn:hover {
      border: 2px solid #0ea5e9;
      background: #334155;
      transform: translateY(-1px);
      box-shadow: 0 4px 0 rgba(14, 165, 233, 0.2);
    }
  }



  .shop-modal h2 {
    margin: 0 0 24px 0;
    color: var(--text);
    font-size: 24px;
    font-weight: 700;
    text-align: center;
  }

  .shop-items-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-top: 16px;
  }

  .shop-item-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    text-align: center;
  }
  

  


  .shop-item-btn {
    background: var(--panel);
    color: var(--text);
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
    font-family: var(--font-family);
    font-weight: 500;
    transition: all 0.2s ease;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 4px;
    min-height: 32px;
    min-width: 80px;
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    position: relative;
    box-sizing: border-box;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .shop-item-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

  .shop-item-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.1);
    background: #374151;
    color: #9ca3af;
  }





  .shop-item-emoji {
    font-size: 32px;
    line-height: 1;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  


  .shop-item-cost {
    display: flex;
    align-items: center;
    gap: 2px;
    font-size: 12px;
    color: #fbbf24;
    font-weight: 600;
  }

  .shop-item-cost .cost-emoji {
    font-size: 14px;
  }

  .shop-item-description {
    font-size: 14px;
    color: #94a3b8;
    margin-bottom: 8px;
    text-align: left;
    font-weight: 400;
    line-height: 1.4;
  }

  .shop-item-group {
    margin-bottom: 16px;
  }
  
  /* Powerup tooltip modal */
  .powerup-tooltip-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1001;
    padding: 20px;
    box-sizing: border-box;
  }
  
  .powerup-tooltip {
    background: var(--panel);
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 20px;
    max-width: 320px;
    width: 90vw;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    position: relative;
  }
  
  .powerup-tooltip-close {
    position: absolute;
    top: 8px;
    right: 8px;
    background: var(--bg);
    color: #ef4444;
    border: 1px solid #475569;
    border-radius: 4px;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    transition: all 0.2s ease;
  }
  
  .powerup-tooltip-close:hover {
    background: #334155;
    border-color: #0ea5e9;
  }
  
  .powerup-tooltip-emoji {
    font-size: 48px;
    margin-bottom: 12px;
    display: block;
  }
  
  .powerup-tooltip-title {
    font-size: 20px;
    font-weight: 700;
    color: var(--text);
    margin-bottom: 8px;
  }
  
  .powerup-tooltip-description {
    font-size: 14px;
    color: #94a3b8;
    line-height: 1.5;
    margin-bottom: 16px;
  }
  
  .powerup-tooltip-usage {
    font-size: 12px;
    color: #64748b;
    font-style: italic;
    background: rgba(255, 255, 255, 0.05);
    padding: 8px;
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }
  


  /* Desktop help modal backdrop should allow content positioning below close button */
  @media (min-width: 769px) {
    .help-modal-backdrop {
      align-items: flex-start;
    }
    

  }

  /* High score display in help modal title - Desktop */
  .help-modal h2 {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    width: 100% !important;
  }
  
  .help-modal .title-text {
    font-size: 1em !important;
    color: var(--text) !important;
    font-weight: 700 !important;
  }
  

  
  /* Modal Close Button - Desktop: floating in top-right of modal bounds */
  .help-modal-close-btn {
    position: fixed;
    top: 20px;
    right: calc(50vw - min(450px, 47.5vw) + 20px);
    padding: 10px 20px;
    min-width: auto;
    height: auto;
    border-radius: 8px;
    background: #334155;
    color: var(--text);
    border: 1px solid #475569;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    z-index: 1001;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.2s ease;
    font-family: var(--font-family);
  }
  
  /* Sound Control and Settings Modal Close Button - positioned for narrower modals */
  .sound-control-modal .help-modal-close-btn,
  .settings-modal .help-modal-close-btn {
    right: calc(50vw - 250px + 20px); /* Position relative to 500px modal width (250px is half) */
  }
  
  .help-modal-close-btn:hover {
    background: #475569;
    transform: translateY(-1px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
  }
  
  .help-modal-close-btn:active {
    transform: translateY(0);
    background: #334155;
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) */
  .help-modal::-webkit-scrollbar {
    display: none;
  }
  
  /* Reset Data Button Styling */
  #resetDataBtn {
    background-color: #dc2626 !important;
    color: white !important;
    border: none;
    transition: all 0.2s ease;
  }
  
  #resetDataBtn:hover {
    background-color: #b91c1c !important;
    transform: translateY(-1px);
  }
  
  #resetDataBtn:active {
    transform: translateY(0);
  }
  
  .help-grid { 
    display: flex; 
    flex-direction: column; 
    gap: 24px; 
    margin: 24px 0; 
  }
  
  .help-section { 
    background: #334155; 
    border-radius: 12px; 
    padding: 20px; 
    border: 1px solid #475569; 
  }
  
  .help-section-header { 
    display: flex; 
    align-items: center; 
    gap: 12px; 
    margin-bottom: 16px; 
  }
  
  .help-icon { 
    font-size: 24px; 
    opacity: 0.9; 
  }
  
  .help-section h3 { 
    margin: 0; 
    font-size: 18px; 
    font-weight: 600; 
    color: #f8fafc; 
  }
  
  .help-content p { 
    margin: 8px 0; 
    font-size: 14px; 
    line-height: 1.4; 
  }
  
  .help-content p:first-child { 
    margin-top: 0; 
  }
  
  .merge-example { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    gap: 20px; 
    margin: 16px 0; 
    padding: 20px; 
    background: #1e293b; 
    border-radius: 8px; 
    flex-wrap: wrap; 
  }
  
  .merge-before, .merge-after { 
    text-align: center; 
  }
  
  .merge-label { 
    display: block; 
    font-size: 12px; 
    color: #94a3b8; 
    margin-bottom: 8px; 
    font-weight: 500; 
  }
  
  .merge-blocks { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 8px; 
  }
  
  .merge-block { 
    width: 108px; 
    height: 42px; 
    border-radius: 9px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    font-weight: 700; 
    font-size: 24px; 
    box-shadow: 0 3px 0 rgba(0,0,0,0.25); 
    font-family: var(--font-family);
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  /* Block colors are now handled dynamically via JavaScript */
  
  .merge-block.bomb-block {
    width: 108px;
    height: 42px;
    border-radius: 9px;
    background: #000;
    color: white;
    position: relative;
    overflow: hidden;
  }
  
  .merge-block.bomb-block .bomb-content {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  .merge-block.bomb-block .bomb-emoji {
    position: absolute;
    top: -3px;
    left: -21px;
    font-size: 42px;
    opacity: 1;
    z-index: 1;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .merge-block.bomb-block .bomb-text {
    position: relative;
    z-index: 2;
    font-size: 24px;
    font-weight: 700;
    font-family: var(--font-family);
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .merge-block.explosion {
    background: #F59E0B;
    color: white;
    font-size: 32px;
    width: 108px;
    height: 42px;
    border-radius: 9px;
  }
  
  /* Next stage block styling */
  .next-stage-block {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .merge-arrow { 
    font-size: 20px; 
    color: #94a3b8; 
    font-weight: 600; 
  }
  
  .help-footer { 
    text-align: center; 
    margin: 24px 0 16px; 
    padding: 16px; 
    background: #334155; 
    border-radius: 8px; 
    border: 1px solid #475569; 
  }
  
  .help-footer p { 
    margin: 0; 
    font-size: 16px; 
    color: #f8fafc; 
  }

  /* Statistics Modal Styles */
  .stats-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(30, 41, 59, 0.95);
    backdrop-filter: blur(8px);
    border: 2px solid rgba(255, 255, 255, 0.8);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    width: auto;
    max-width: 90vw;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    /* Prevent viewport shifting on mobile */
    transform-origin: center center;
    touch-action: manipulation;
  }

  .stats-modal-backdrop {
    padding: 0;
    align-items: center;
    justify-content: center;
  }

  .stats-modal h2 {
    text-align: center;
    margin: 0 0 16px 0;
    color: var(--text);
    font-size: 20px;
    font-weight: 700;
    font-family: var(--font-family);
  }

  .stats-content {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin: 16px 0;
  }

  .stat-line {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 24px;
    padding: 6px 0;
  }

  .stat-icon {
    font-size: 24px;
    opacity: 0.9;
    flex-shrink: 0;
  }

  .stat-label {
    font-size: 16px;
    color: #94a3b8;
    font-weight: 500;
    flex-shrink: 0;
  }

  .stat-value {
    font-size: 18px;
    font-weight: 700;
    color: #f8fafc;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }



  /* Mobile responsive for stats modal */
  @media (max-width: 768px) {
    .stats-modal {
      width: auto;
      max-width: calc(100vw - 40px);
      padding: 16px;
      /* Force the centering transform to stay put on mobile */
      transform: translate(-50%, -50%) !important;
      transform-origin: center center !important;
    }

    .stats-content {
      gap: 4px;
      margin: 12px 0;
    }

    .stat-line {
      padding: 4px 0;
      flex-wrap: nowrap;
      min-width: 0;
      gap: 16px;
    }

    .stat-icon {
      font-size: 20px;
      flex-shrink: 0;
    }

    .stat-label {
      font-size: 14px;
      flex-shrink: 0;
      white-space: nowrap;
    }

    .stat-value {
      font-size: 16px;
      flex-shrink: 0;
    }
  }

  .game-container {
    display: flex;
    align-items: flex-start;
    margin-top: 24px;
    padding-bottom: 24px;
    justify-content: center;
    position: relative;
    /* Ensure game container doesn't take up full height on mobile */
    min-height: auto;
    /* Prevent horizontal scrolling on mobile */
    overflow-x: hidden;
    overflow-y: visible;
    /* Responsive width that adapts to screen size */
    width: 100%;
    max-width: 632px;
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    /* Force overflow visibility to prevent any clipping */
    clip-path: none;
    mask: none;
    -webkit-mask: none;
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) */
  .game-container::-webkit-scrollbar {
    display: none;
  }
  
  /* Force game container to break out of any clipping contexts */
  .game-container,
  .game-container * {
    overflow: visible !important;
    clip-path: none !important;
    mask: none !important;
    -webkit-mask: none !important;
  }
  
  /* Ensure game container can overflow beyond any parent boundaries */
  .game-container {
    position: relative;
    z-index: 100;
    isolation: isolate;
  }
  
  /* Ensure game area can overflow */
  .game {
    position: relative;
    z-index: 101;
    isolation: isolate;
  }
  
  /* Ensure poles can overflow */
  .pole {
    position: relative;
    z-index: 102;
    isolation: isolate;
  }
  
  /* Ensure discs can overflow */
  .disc {
    position: relative;
    z-index: 103;
    isolation: isolate;
  }
  
  /* Ensure game container is responsive */
  .game-container {
    max-width: 100% !important;
    width: 100% !important;
    min-width: auto;
  }
  
  /* Ensure game area is responsive */
  .game {
    max-width: 100% !important;
    width: 100% !important;
  }
  
  
  
  .game { 
    display: flex; 
    gap: 24px; 
    justify-content: center; 
    flex-wrap: wrap;
    position: relative;
    /* Ensure blocks can overflow and show their full shape */
    overflow: visible;
    /* Force overflow visibility to prevent any clipping */
    clip-path: none;
    mask: none;
    -webkit-mask: none;
    max-width: 100%;
    overflow-x: hidden;
  }
  

  
  .bottom-actions { 
    display: flex; 
    justify-content: center; 
    align-items: center;
    gap: 18px; 
    margin-top: 18px; 
  }
  
  /* Unified Powerup Shop - Below Game Area */
  .powerup-shop {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    margin-top: 4px;
    margin-bottom: 16px;
    width: 100%;
    max-width: 632px;
    margin-left: auto;
    margin-right: auto;
    padding: 0;
    overflow: visible;
    box-sizing: border-box;
    /* Ensure powerup shop is always visible */
    position: relative;
    z-index: 5;
    background: var(--bg);
  }
  
  /* Desktop-specific spacing adjustment */
  @media (min-width: 769px) {
    .powerup-shop {
      margin-top: 16px;
    }
  }
  
  
  

  

  
  .shop-grid {
    display: flex;
    gap: 16px;
    justify-content: space-between;
    align-items: center;
    flex-wrap: nowrap;
    width: 95%;
    margin: 0 auto;
    max-width: 1200px;
    overflow: visible;
  }
  
  /* Ensure buttons stay on one line on desktop */
  @media (min-width: 768px) {
    .shop-grid {
      flex-wrap: nowrap;
      max-width: none;
    }
  }
  
  /* Ensure buttons don't become too wide on very large screens */
  @media (min-width: 1200px) {
    .shop-grid {
      max-width: 1400px;
    }
  }
  
  /* Universal powerup button sizing - buttons sized as if all 4 are visible */
  .powerup-btn {
    flex: 0 0 calc(25% - 12px); /* 25% minus 1/4 of the total gap space (48px / 4 = 12px) */
    min-width: 0;
    min-height: 80px;
    max-width: none;
    padding: 0;
  }
  

  

  
  /* Ensure buttons don't become too narrow on very small screens */
  @media (max-width: 480px) {
    .powerup-btn {
      flex: 0 0 calc(25% - 6px); /* 25% minus 1/4 of the total gap space (24px / 4 = 6px) */
      min-width: 0;
      min-height: 50px;
      max-width: none;
    }
  }
  

  
  /* Handle very narrow containers with responsive flexbox */
  @media (max-width: 600px) {
    .shop-grid {
      gap: 12px;
      flex-wrap: nowrap;
    }
    
    .powerup-btn {
      flex: 0 0 calc(25% - 9px); /* 25% minus 1/4 of the total gap space (36px / 4 = 9px) */
      min-width: 0;
      min-height: 70px;
      max-width: none;
    }
    

  }
  

  

  
  .powerup-btn {
    background: var(--panel);
    color: var(--text);
    border: 2px solid rgba(255, 255, 255, 0.1);
    min-width: 0;
    min-height: 80px;
    /* Ensure buttons start hidden by default */
    visibility: hidden;
    opacity: 0;
    pointer-events: none;
    /* Ensure badges can extend beyond button boundaries */
    overflow: visible;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--font-family);
    pointer-events: auto;
    position: relative;
    padding: 0;
    box-sizing: border-box;
    overflow: visible;
    text-overflow: ellipsis;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;

  }
  

  
  .powerup-btn:active {
    transform: translateY(0) !important;
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2) !important;
  }
  
  /* Ensure active state works on mobile devices */
  @media (hover: none) and (pointer: coarse) {
    .powerup-btn:active,
    .powerup-btn.mobile-active {
      transform: translateY(2px) !important;
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2) !important;
      -webkit-tap-highlight-color: transparent;
    }
  }
  
  .powerup-btn:disabled {
    opacity: 0.6 !important;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.1);
    background: #374151;
    color: #9ca3af;
    /* Disabled buttons should not be clickable */
    pointer-events: none !important;
  }
  

  
  /* Default powerup button styling - enabled when owned */
  .powerup-btn:not(:disabled):not(.undo-mode) {
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1);
  }
  

  
  /* Undo mode styling - when a bomb is selected and can be undone */
  .powerup-btn.undo-mode {
    border: 2px solid #10B981;
    background: #065F46;
    box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25);
    animation: undoModePulse 2s ease-in-out infinite;
  }
  

  
  .powerup-btn.undo-mode .powerup-emoji {
    content: "↩️";
  }
  
  /* Trash X overlay styling */
  .next-disc {
    position: relative; /* Ensure the block is a positioned ancestor for the overlay */
  }
  
  .trash-x-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgb(0, 0, 0);
    color: white;
    font-size: 24px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 9px;
    cursor: pointer;
    z-index: 10;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    animation: trashXOverlayPulse 1.5s ease-in-out infinite;
    box-shadow: 0 0 20px rgba(185, 28, 28, 0.6);
  }
  
  /* Mobile responsive sizing for trash emoji */
  @media (max-width: 768px) {
    .trash-x-overlay {
      font-size: 18px;
    }
  }
  
  @media (max-width: 480px) {
    .trash-x-overlay {
      font-size: 16px;
    }
  }
  
  .trash-x-overlay:hover {
    background: rgba(153, 23, 23, 1.0);
    box-shadow: 0 0 25px rgba(185, 28, 28, 0.8);
  }
  
  .trash-x-overlay:active {
    background: rgba(120, 15, 15, 1.0);
  }
  
  @keyframes trashXOverlayPulse {
    0%, 100% { 
      box-shadow: 0 0 20px rgba(185, 28, 28, 0.6);
    }
    50% { 
      box-shadow: 0 0 30px rgba(185, 28, 28, 0.8);
    }
  }
  
  /* Desktop-only hover effects for powerup buttons */
  @media (hover: hover) and (pointer: fine) {
    .powerup-btn:not(:disabled):not(.undo-mode):hover {
      border: 2px solid #0ea5e9;
      background: #334155;
      transform: translateY(-1px);
      box-shadow: 0 4px 0 rgba(14, 165, 233, 0.2);
    }
    
    .powerup-btn.undo-mode:hover {
      border: 2px solid #34D399;
      background: #047857;
      transform: translateY(-1px);
      box-shadow: 0 4px 0 rgba(16, 185, 129, 0.3);
    }
    
    /* Disable hover effects for powerup buttons inside the shop modal */
    .shop-modal .powerup-btn:not(:disabled):not(.undo-mode):hover {
      border: 2px solid #475569;
      background: #1e293b;
      transform: none;
      box-shadow: none;
    }
  }
  
  @keyframes undoModePulse {
    0%, 100% { 
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25);
    }
    50% { 
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.4);
    }
  }
  

  
  .powerup-emoji {
    font-size: 32px;
    line-height: 1;
    flex-shrink: 0;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .powerup-cost {
    display: flex;
    align-items: center;
    gap: 2px;
    font-family: var(--font-family);
    font-size: 16px;
    white-space: nowrap;
    padding-right: 8px;
    flex-shrink: 0;
    min-width: 0;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .cost-emoji {
    font-size: 18px;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .cost-amount {
    color: #FCD34D;
    font-weight: 700;
    font-size: 18px;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  /* Responsive sizing that automatically adapts to button count */
  .powerup-emoji {
    font-size: clamp(20px, 4vw, 32px);
  }
  
  .powerup-cost {
    font-size: clamp(10px, 2vw, 16px);
    padding-right: clamp(2px, 0.5vw, 8px);
  }
  
  .cost-emoji {
    font-size: clamp(11px, 2.2vw, 18px);
  }
  
  .cost-amount {
    font-size: clamp(11px, 2.2vw, 18px);
  }
  
  /* Better mobile typography scaling */
  @media (max-width: 768px) {
    .powerup-emoji {
      font-size: clamp(24px, 6vw, 32px);
    }
    
    .powerup-cost {
      font-size: clamp(14px, 3.5vw, 18px);
      padding-right: clamp(4px, 1vw, 8px);
    }
    
    .cost-emoji {
      font-size: clamp(16px, 4vw, 20px);
    }
    
    .cost-amount {
      font-size: clamp(16px, 4vw, 20px);
    }
    
    
    

  }
  
  @media (max-width: 480px) {
    .powerup-emoji {
      font-size: clamp(20px, 5vw, 28px);
    }
    
    .powerup-cost {
      font-size: clamp(12px, 3vw, 16px);
      padding-right: clamp(3px, 0.8vw, 6px);
    }
    
    .cost-emoji {
      font-size: clamp(14px, 3.5vw, 18px);
    }
    
    .cost-amount {
      font-size: clamp(14px, 3.5vw, 18px);
    }
    
    /* Disable blue borders on mobile for powerup buttons */
    

    

  }
  


  
  /* Responsive button sizing that maintains proper edge padding */
  @media (min-width: 1200px) {
    .powerup-btn {
      padding: 0 12px;
    }
    
    .powerup-btn .powerup-emoji {
      font-size: clamp(28px, 3vw, 36px);
    }
    
    .powerup-btn .powerup-cost {
      font-size: clamp(16px, 1.5vw, 20px);
    }
  }
  
  @media (min-width: 768px) and (max-width: 1199px) {
    .powerup-btn {
      padding: 0 10px;
    }
    
    .powerup-btn .powerup-emoji {
      font-size: clamp(24px, 3vw, 32px);
    }
    
    .powerup-btn .powerup-cost {
      font-size: clamp(14px, 2vw, 18px);
    }
  }
  
  @media (max-width: 767px) {
    .powerup-btn {
      padding: 0 8px;
    }
    
    .powerup-btn .powerup-emoji {
      font-size: clamp(20px, 5vw, 28px);
    }
    
    .powerup-btn .powerup-cost {
      font-size: clamp(12px, 3vw, 16px);
    }
  }
  

  

  

  

  

  
  /* Mobile responsive powerup shop */
  @media (max-width: 768px) {
    .powerup-shop {
      margin-top: 8px;
      margin-bottom: 20px;
      padding: 0 16px;
      position: relative;
      z-index: 10;
      background: var(--bg);
      display: flex !important;
      visibility: visible !important;
      opacity: 1 !important;
      width: 100%;
      overflow: visible;
      max-width: 100%;
    }
    
    .shop-grid {
      gap: 12px;
      flex-wrap: nowrap;
    }
    
    .powerup-btn {
      flex: 0 0 calc(25% - 9px); /* 25% minus 1/4 of the total gap space (36px / 4 = 9px) */
      min-width: 0;
      min-height: clamp(60px, 15vw, 80px);
      max-height: clamp(60px, 15vw, 80px);
      padding: 0 12px;
      max-width: none;
    }
    

    
    .game-container {
      margin-bottom: 0;
      padding-bottom: 0;
    }
  }
  
  /* Extra small mobile powerup shop */
  @media (max-width: 480px) {
    .powerup-shop {
      margin-top: 8px;
      margin-bottom: 16px;
      padding: 0 12px;
      display: flex !important;
      visibility: visible !important;
      opacity: 1 !important;
      z-index: 10;
      width: 100%;
      max-width: 100%;
      overflow: visible;
    }
    
    .shop-grid {
      gap: 8px;
      flex-wrap: nowrap;
    }
    
    .powerup-btn {
      flex: 0 0 calc(25% - 6px); /* 25% minus 1/4 of the total gap space (24px / 4 = 6px) */
      min-width: 0;
      min-height: clamp(50px, 12vw, 70px);
      max-height: clamp(50px, 12vw, 70px);
      padding: 0;
      max-width: none;
    }
    

  }
  
  /* Next block display styling in debug panel */

  .pole { position:relative; width:140px; height:var(--stack-height, 525px); background:var(--panel); border-radius:15px; display:flex; flex-direction:column-reverse; align-items:center; padding:16px; box-sizing:border-box; cursor:pointer; transition: all 0.2s ease; z-index: 0; overflow: visible; clip-path: none; mask: none; -webkit-mask: none; }
  .pole:hover { outline: 3px solid #0ea5e9; outline-offset: -3px; }
  .pole:hover .disc { transform: translateY(-2px); }
  .pole.full { opacity:0.6; cursor: not-allowed; }
  .pole.full:hover { opacity: 0.6; border: none; }
  .pole.no-hover:hover { border: none !important; opacity: 1 !important; }
  .pole.no-hover { pointer-events: none; }
  /* Touch device optimizations */
  @media (hover: none) and (pointer: coarse) {
    /* On touch devices, completely disable hover effects since they're not useful */
    .pole:hover {
      outline: none !important;
    }
    
    .pole:hover .disc {
      transform: none !important;
    }
    
    /* Reduce transition duration on touch devices for snappier feedback */
    .pole {
      transition: all 0.1s ease;
    }
  }
  .disc { width:108px; height:42px; border-radius:9px; display:flex; align-items:center; justify-content:center; color:white; font-weight:700; font-size:24px; margin-top:9px; box-shadow:0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family); transform-origin: center center; position: relative; z-index: 1; overflow: hidden !important; clip-path: none; mask: none; -webkit-mask: none; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
  
  /* Bomb block styling */
  .bomb-content {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  .bomb-emoji {
    position: absolute;
    top: -3px;
    left: -21px;
    font-size: 42px;
    opacity: 1;
    z-index: 1;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .bomb-text {
    position: relative;
    z-index: 2;
    font-size: 24px;
    font-weight: 700;
    font-family: var(--font-family);
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  /* remove extra gap at the very top of a full pole (topmost disc has no margin) */
  .pole .disc:last-child { margin-top: 0; }

  .disc.animate { 
    animation: drop calc(0.15s * var(--animation-speed, 1)) ease-out;
  }
  @keyframes drop {
    from { transform: translateY(-60px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.animate[style*="--animation-speed: 0"] { animation: none; transform: translateY(0); opacity: 1; }

  /* Enhanced merge animations */
  .disc.merge-out { 
    animation: mergeOut calc(0.15s * var(--animation-speed, 1)) cubic-bezier(0.4, 0, 0.2, 1) forwards;
    filter: brightness(1.1) saturate(1.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.merge-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.7); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes mergeOut {
    0% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
    }
    25% { 
      transform: scale(1.1); 
      opacity: 1; 
      filter: brightness(1.2) saturate(1.3);
    }
    50% { 
      transform: scale(1.15); 
      opacity: 0.9; 
      filter: brightness(1.3) saturate(1.4);
    }
    75% { 
      transform: scale(1.05); 
      opacity: 0.6; 
      filter: brightness(1.1) saturate(1.2);
    }
    100% { 
      transform: scale(0.7); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
    }
  }

  /* Bomb explosion effect - for the bomb block itself */
  .disc.bomb-explosion {
    animation: bombExplosion calc(0.5s * var(--animation-speed, 1)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    filter: brightness(1.5) saturate(1.8);
    box-shadow: 0 0 20px rgba(220, 38, 38, 0.6), 0 0 40px rgba(220, 38, 38, 0.4);
    z-index: 15;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.bomb-explosion[style*="--animation-speed: 0"] { animation: none; transform: scale(0.8); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes bombExplosion {
    0% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
    15% { 
      transform: scale(1.6); 
      opacity: 1; 
      filter: brightness(2.0) saturate(2.2);
      box-shadow: 0 0 30px rgba(220, 38, 38, 0.8), 0 0 60px rgba(220, 38, 38, 0.5);
    }
    35% { 
      transform: scale(1.3); 
      opacity: 0.7; 
      filter: brightness(1.6) saturate(1.8);
      box-shadow: 0 0 25px rgba(220, 38, 38, 0.6), 0 0 50px rgba(220, 38, 38, 0.4);
    }
    70% { 
      transform: scale(0.9); 
      opacity: 0.3; 
      filter: brightness(1.2) saturate(1.3);
      box-shadow: 0 0 15px rgba(220, 38, 38, 0.3), 0 0 30px rgba(220, 38, 38, 0.2);
    }
    100% { 
      transform: scale(0.8); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
      box-shadow: 0 0 60px rgba(220, 38, 38, 0);
    }
  }

  /* Stage progression explosion effect - for blocks being cleared during stage advancement */
  .disc.stage-explosion {
    animation: bombRipple calc(0.5s * var(--animation-speed, 1)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    filter: brightness(1.3) saturate(1.4);
    box-shadow: 0 0 15px rgba(220, 38, 38, 0.4), 0 0 30px rgba(220, 38, 38, 0.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.stage-explosion[style*="--animation-speed: 0"] { animation: none; transform: scale(0.8); opacity: 0; filter: brightness(0.8) saturate(0.9); }

  /* Bomb shockwave ripple effect - for blocks affected by the explosion */
  .disc.bomb-ripple {
    animation: bombRipple calc(0.5s * var(--animation-speed, 1)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    filter: brightness(1.3) saturate(1.4);
    box-shadow: 0 0 15px rgba(220, 38, 38, 0.4), 0 0 30px rgba(220, 38, 38, 0.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.bomb-ripple[style*="--animation-speed: 0"] { animation: none; transform: scale(0.8); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes bombRipple {
    0% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
    20% { 
      transform: scale(1.2); 
      opacity: 1; 
      filter: brightness(1.4) saturate(1.6);
      box-shadow: 0 0 20px rgba(220, 38, 38, 0.5), 0 0 40px rgba(220, 38, 38, 0.3);
    }
    40% { 
      transform: scale(1.1); 
      opacity: 0.8; 
      filter: brightness(1.3) saturate(1.4);
      box-shadow: 0 0 15px rgba(220, 38, 38, 0.4), 0 0 30px rgba(220, 38, 38, 0.25);
    }
    70% { 
      transform: scale(0.9); 
      opacity: 0.4; 
      filter: brightness(1.1) saturate(1.2);
      box-shadow: 0 0 10px rgba(220, 38, 38, 0.2), 0 0 20px rgba(220, 38, 38, 0.15);
    }
    100% { 
      transform: scale(0.8); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
  }

  .disc.merge-in { 
    animation: mergeIn calc(0.2s * var(--animation-speed, 1)) cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    filter: brightness(1.05) saturate(1.1);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.merge-in[style*="--animation-speed: 0"] { animation: none; transform: scale(1); opacity: 1; filter: brightness(1) saturate(1); }
  @keyframes mergeIn {
    0% { 
      transform: scale(0.6); 
      opacity: 0; 
      filter: brightness(0.7) saturate(0.8);
    }
    30% { 
      transform: scale(0.85); 
      opacity: 0.7; 
      filter: brightness(0.9) saturate(1);
    }
    60% { 
      transform: scale(1.05); 
      opacity: 0.9; 
      filter: brightness(1.05) saturate(1.1);
    }
    80% { 
      transform: scale(0.98); 
      opacity: 1; 
      filter: brightness(1.02) saturate(1.05);
    }
    100% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
    }
  }

  /* Merge glow effect for visual appeal */
  .disc.merging {
    box-shadow: 0 0 15px rgba(14, 165, 233, 0.4), 0 0 25px rgba(14, 165, 233, 0.2);
    transition: box-shadow 0.1s ease;
    z-index: 5;
  }
  
  /* Enhanced disc transitions for smoother animations */
  .disc {
    transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform, opacity, filter;
  }
  
  /* Disable transitions during animations to prevent conflicts */
  .disc.merge-out,
  .disc.merge-in,
  .disc.bomb-explosion,
  .disc.bomb-ripple,
  .disc.stage-explosion,
  .disc.clear-out {
    transition: none;
  }
  


  /* special clear animation for high-value blocks */
  .disc.clear-out { animation: clearOut calc(0.26s * var(--animation-speed, 1)) ease forwards; }
  @keyframes clearOut {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0.85); opacity: 0; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.clear-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.85); opacity: 0; }

  /* removed falling/fade styles for simplified clear */



  .controls { margin-top:8px; font-size:13px; color:#ccc; }

  /* Debug pane styling */
  .debug-pane { 
    position: fixed; 
    top: 0; 
    right: 0; 
    height: 100vh; 
    background: var(--panel); 
    color: var(--text); 
    border-left: 3px solid #475569; 
    padding: 20px; 
    z-index: 1002; 
    width: 320px;
    box-shadow: -5px 0 25px rgba(0,0,0,0.4);
    font-family: var(--font-family);
    overflow-y: auto;
    overflow-x: hidden;
    box-sizing: border-box;
    transform: translateX(100%);
    transition: transform 0.3s ease-out;
    display: flex;
    flex-direction: column;
  }
  
  .debug-pane.show {
    transform: translateX(0);
  }
  
  /* Debug pane backdrop overlay */
  .debug-pane::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.3);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease-out;
    z-index: -1;
  }
  
  .debug-pane.show::before {
    opacity: 1;
  }
  

  .debug-pane h3 { margin: 0 0 16px; font-size: 20px; text-align: center; font-family: var(--font-family); }
  .debug-pane .section { margin-bottom: 18px; }
  
  .debug-pane .section:not(.bottom-buttons) {
    flex: 1;
  }
  .debug-pane .section-title { font-weight: 600; margin-bottom: 8px; font-size: 15px; font-family: var(--font-family); }
  .debug-pane .controls { display: flex; flex-direction: column; gap: 12px; }
  .debug-pane .control-row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
  .debug-pane .control-row label { font-size: 14px; min-width: 70px; font-family: var(--font-family); flex-shrink: 0; }
  .debug-pane .control-row input[type="range"] { flex: 1; min-width: 0; accent-color: #0ea5e9; }
  .debug-pane .control-row .value-display { 
    background: var(--bg); 
    padding: 6px 12px; 
    border-radius: 6px; 
    font-size: 13px; 
    min-width: 45px; 
    text-align: center; 
    font-family: var(--font-family);
    flex-shrink: 0;
  }
  .debug-pane .button { 
    background: #334155; 
    color: var(--text); 
    border: 1px solid #475569; 
    padding: 10px 16px; 
    border-radius: 6px; 
    cursor: pointer; 
    font-weight: 600; 
    font-size: 14px;
    transition: background 0.2s;
    font-family: var(--font-family);
    box-sizing: border-box;
  }
  
  .debug-pane .button-row {
    display: flex;
    gap: 8px;
  }
  
  .debug-pane .button-row .button {
    flex: 1;
    min-width: 0;
  }
  
  .debug-pane .bottom-buttons {
    margin-top: auto;
    padding-top: 16px;
    padding-bottom: 16px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
    /* Ensure this section stays at the bottom */
    position: relative;
  }
  
  /* Block grid styling */
  .block-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
    margin: 12px 0;
  }
  
  .block-item {
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .block-item:hover {
    transform: scale(1.05);
    box-shadow: 0 3px 0 rgba(0,0,0,0.3);
  }
  
  .block-item.selected {
    outline: 3px solid #fff;
    outline-offset: 2px;
    transform: scale(1.1);
    box-shadow: 0 4px 0 rgba(0,0,0,0.4);
  }
  
  /* Debug block colors are now handled dynamically via JavaScript */
  
  /* Basic styling for debug blocks (colors applied via JavaScript) */
  .debug-pane .block-item {
    width: 40px;
    height: 40px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 2px solid transparent;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .debug-pane .block-item:hover {
    border-color: #64748b;
    transform: scale(1.05);
  }
  
  .debug-pane .block-item.selected {
    border-color: #0ea5e9;
    transform: scale(1.1);
  }
  
  /* General rule for any higher tier blocks (262144+) to use white styling */
  .block-item[data-value]:not([data-value="1"]):not([data-value="2"]):not([data-value="4"]):not([data-value="8"]):not([data-value="16"]):not([data-value="32"]):not([data-value="64"]):not([data-value="128"]):not([data-value="256"]):not([data-value="512"]):not([data-value="1024"]):not([data-value="2048"]):not([data-value="4096"]):not([data-value="8192"]):not([data-value="16384"]):not([data-value="32768"]):not([data-value="65536"]):not([data-value="131072"]):not([data-value="262144"]) {
    background: #fff !important;
    color: #000 !important;
  }
  
  /* Largest merge block styling - now handled dynamically via JavaScript */
  
  /* Largest merge block styling - now handled dynamically via JavaScript with proper theming */

  /* Theme switching classes - now handled dynamically via JavaScript */
  
  /* Dynamic gold glow effect for white blocks (16384+) in the game */
  .disc.white-block-glow {
    --glow-intensity: 1;
    --glow-spread: 8px;
    --glow-opacity: 0.6;
    --border-width: 2px;
    --border-opacity: 0.8;
    --inset-opacity: 0.1;
    
    box-shadow: 
      0 0 calc(var(--glow-spread) * 1) rgba(245, 215, 110, var(--glow-opacity)),
      0 0 calc(var(--glow-spread) * 2) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.67)),
      0 0 calc(var(--glow-spread) * 3) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.33)),
      0 0 calc(var(--glow-spread) * 4) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.17)),
      inset 0 0 calc(var(--glow-spread) * 1) rgba(245, 215, 110, var(--inset-opacity));
    border: var(--border-width) solid rgba(245, 215, 110, var(--border-opacity));
  }
  
  .block-item.no-block {
    background: #64748b;
    color: #fff;
    border: 2px solid #94a3b8;
    font-weight: 600;
  }
  
  .block-item.no-block:hover {
    background: #475569;
    border-color: #cbd5e1;
  }
  
  .block-item.no-block.selected {
    background: #475569;
    border-color: #e2e8f0;
    outline: 3px solid #e2e8f0;
  }
  
  .selected-block-info {
    text-align: center;
    font-size: 13px;
    color: rgba(255, 255, 255, 0.9);
    margin-top: 8px;
    padding: 8px;
    background: var(--bg);
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }
  .debug-pane .button:hover { background: #475569; }
  .debug-pane .button:active { background: #334155; }
  .debug-pane .button.primary { background: #0ea5e9; border-color: #0284c7; }
  .debug-pane .button.primary:hover { background: #0284c7; }
  .debug-pane .button.active { background: #0ea5e9; border-color: #0284c7; }
  .debug-pane .close-btn { 
    position: absolute; 
    top: 8px; 
    right: 12px; 
    background: rgba(30, 41, 59, 0.8); 
    border: 1px solid #64748b; 
    color: #94a3b8; 
    font-size: 20px; 
    cursor: pointer; 
    padding: 6px; 
    border-radius: 6px;
    font-family: var(--font-family);
    transition: all 0.2s ease;
    /* Ensure it's always touchable */
    pointer-events: auto;
    touch-action: manipulation;
  }
  .debug-pane .close-btn:hover { background: #475569; color: var(--text); }
  .debug-pane .status { 
    background: var(--bg); 
    padding: 8px; 
    border-radius: 6px; 
    font-size: 13px; 
    text-align: center;
    border: 1px solid #475569;
    font-family: var(--font-family);
  }
  .debug-pane .status.active { border-color: #10B981; background: rgba(16, 185, 129, 0.1); }
  .debug-pane .status.inactive { border-color: #6B7280; background: rgba(107, 114, 128, 0.1); }
  
  /* Hide debug button by default - will be shown only in development mode */
  #debugBtn {
    display: none;
  }

  /* Game Over Button Overlay */
  .game-over-button-overlay {
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) scale(0.8) !important;
    background: #0f172a; /* Page background color */
    border: 2px solid rgba(255, 255, 255, 0.8); /* Semi-transparent white border */
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    opacity: 0;
    pointer-events: none; /* Disable interactions when hidden */
    transition: opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1), transform 1.2s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.3s ease; /* Animate opacity and transform with same timing */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    min-width: 200px;
    /* Debug: add border to see positioning */
    border: 3px solid red;
  }

  .game-over-button-overlay.hiding {
    transition: opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1), transform 1.2s cubic-bezier(0.4, 0, 0.2, 1); /* Exact inverse of fade-in animation */
  }

  .game-over-button-overlay.show {
    opacity: 1;
    pointer-events: auto; /* Re-enable interactions when shown */
    transform: translate(-50%, -50%) scale(1) !important;
  }

  .game-over-text {
    font-size: 24px;
    font-weight: 700;
    color: #ef4444;
    font-family: var(--font-family);
    text-align: center;
    margin: 0;
  }

  .new-high-score-message {
    font-size: 20px;
    font-weight: 700;
    color: #fbbf24;
    font-family: var(--font-family);
    text-align: center;
    margin: 8px 0;
    animation: celebrateHighScore 1s ease-in-out;
  }

  @keyframes celebrateHighScore {
    0% { 
      opacity: 0;
      transform: scale(0.8);
    }
    50% {
      opacity: 1;
      transform: scale(1.1);
    }
    100% {
      opacity: 1;
      transform: scale(1);
    }
  }

  @keyframes breathingEffect {
    0%, 100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.05);
    }
  }

  .largest-merge-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    margin-top: 8px;
  }

  .largest-merge-label {
    font-size: 16px;
    font-weight: 600;
    color: var(--text);
    font-family: var(--font-family);
    text-align: center;
    margin: 0;
  }

  .largest-merge-block {
    width: 108px;
    height: 42px;
    border-radius: 9px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 24px;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    font-family: var(--font-family);
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  .gold-earned-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    margin-top: 16px;
  }

  .gold-earned-label {
    font-size: 16px;
    font-weight: 600;
    color: var(--text);
    font-family: var(--font-family);
    text-align: center;
    margin: 0;
  }

  .gold-earned-amount {
    background: #FCD34D; 
    color: #000; 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 20px; 
    min-width: 70px; 
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  .final-score-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    margin-top: 16px;
  }

  .final-score-label {
    font-size: 16px;
    font-weight: 600;
    color: var(--text);
    font-family: var(--font-family);
    text-align: center;
    margin: 0;
  }

  .final-score-amount {
    background: #1e293b; 
    color: white; 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 20px; 
    min-width: 70px; 
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  .new-high-score-badge {
    position: absolute;
    bottom: -8px;
    right: 0;
    left: 0;
    text-align: center;
    font-size: 10px;
    font-weight: 600;
    background: transparent;
    color: #fbbf24;
    white-space: nowrap;
    animation: celebrateHighScore 1s ease-in-out, breathingEffect 2s ease-in-out infinite;
    font-family: var(--font-family);
    /* Ensure stable positioning during modal animation */
    transform-origin: center;
    will-change: transform;
    /* Force hardware acceleration and stable positioning */
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    perspective: 1000px;
    -webkit-perspective: 1000px;
  }

  .new-game-btn {
    background: #10B981;
    color: white;
    border: none;
    padding: 16px 32px;
    border-radius: 12px;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .new-game-btn:hover {
    background: #059669;
    transform: translateY(-2px);
    box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
  }

  .new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }



  /* New Game Modal Styling */
  .new-game-modal {
    max-width: 300px;
    text-align: center;
    /* Add similar outline to Game Over window but with green/blue theme */
    border: 2px solid rgba(16, 185, 129, 0.8); /* Semi-transparent green border */
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3); /* Green-tinted shadow */
    background: rgba(30, 41, 59, 0.95); /* Semi-transparent panel background like Game Over */
    backdrop-filter: blur(8px); /* Add subtle blur effect like Game Over */
    /* Add smooth transition for hover effects */
    transition: all 0.3s ease;
  }

  /* Add hover effect to make the outline more prominent */
  .new-game-modal:hover {
    border-color: rgba(16, 185, 129, 1); /* Solid green on hover */
    box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4); /* Enhanced shadow on hover */
  }

  .new-game-modal h2 {
    margin-bottom: 24px;
    color: var(--text);
  }



  /* Welcome Modal Styling */
  .welcome-modal {
    max-width: 500px;
    text-align: center;
    padding: 30px;
  }

  .welcome-content {
    margin-bottom: 30px;
  }

  .welcome-content p {
    margin: 0 0 16px 0;
    font-size: 16px;
    line-height: 1.5;
    color: var(--text);
  }

  .welcome-actions {
    display: flex;
    gap: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .welcome-btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    min-width: 140px;
  }

  .welcome-yes-btn {
    background: #10B981;
    color: white;
    box-shadow: 0 3px 0 rgba(16, 185, 129, 0.3);
  }

  .welcome-yes-btn:hover {
    background: #059669;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(16, 185, 129, 0.4);
  }

  .welcome-yes-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(16, 185, 129, 0.3);
  }

  .welcome-skip-btn {
    background: var(--panel);
    color: var(--text);
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
  }

  .welcome-skip-btn:hover {
    background: #475569;
    border-color: #64748b;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(0, 0, 0, 0.3);
  }

  .welcome-skip-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

  /* Mobile responsive for welcome modal */
  @media (max-width: 768px) {
    .welcome-modal {
      max-width: 95vw;
      margin: 20px;
      padding: 24px;
    }
    
    .welcome-content p {
      font-size: 15px;
    }
    
    .welcome-actions {
      flex-direction: column;
      gap: 12px;
    }
    
    .welcome-btn {
      width: 100%;
      padding: 14px 20px;
      font-size: 15px;
    }
  }

  .new-game-buttons {
    display: flex;
    gap: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .confirm-new-game-btn {
    background: #10B981;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .confirm-new-game-btn:hover {
    background: #059669;
    transform: translateY(-2px);
    box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
  }

  .confirm-new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

  .cancel-new-game-btn {
    background: #DC2626;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .cancel-new-game-btn:hover {
    background: #b91c1c;
    transform: translateY(-2px);
    box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
  }

  .cancel-new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

/* Debug stats table styling */
.debug-stats-table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 8px;
  font-size: 12px;
  table-layout: fixed;
}

.debug-stats-table td {
  padding: 2px 4px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.debug-stats-table td:first-child {
  font-weight: 500;
  color: rgba(255, 255, 255, 0.7);
  width: 45%;
}

.debug-stats-table td:last-child {
  text-align: right;
  font-weight: 600;
  color: var(--text);
  width: 55%;
}

/* Mobile Responsive Design */
@media (max-width: 768px) {
  /* Adjust topbar for mobile */
  .topbar {
    padding: 8px 12px 8px;
    gap: 16px;
  }
  
  h1 {
    font-size: 24px !important;
  }
  
  /* Adjust game info layout for mobile */
  .game-info {
    display: grid;
    grid-template-columns: 1fr;
    grid-template-areas: 
      "score-gold"
      "next";
    align-items: center;
    gap: 32px;
    margin-top: 24px; /* Minimal spacing below title on mobile */
    max-width: 100%;
    padding: 0 16px;
  }
  
  /* Ensure the score-gold unit is centered as one block */
  .score-display, .gold-display {
    flex-shrink: 0; /* Prevent shrinking */
  }
  
  /* Style the score-gold container on mobile */
  .score-gold-container {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center; /* Center the displays within the container */
    gap: 16px; /* Consistent spacing between score and gold */
    grid-area: score-gold;
    width: auto;
    /* Center the entire unit on screen by centering the container */
    margin: 0 auto;
  }
  
  /* Reset individual display positioning on mobile */
  .score-display, .gold-display {
    margin: 0; /* Remove individual margins */
    /* Let each display size naturally based on content */
    width: auto;
    min-width: fit-content;
    /* Ensure displays don't interfere with centering */
    flex-shrink: 0;
  }
  
  /* The key: center the container itself, not the content within it */
  .score-gold-container {
    justify-content: flex-start; /* Don't center content within container */
    /* Container gets centered by margin: 0 auto, content flows naturally */
  }
  

  
  /* Ensure the game-info container properly centers its children */
  .game-info {
    /* Force the flexbox to center children properly */
    align-items: center;
    justify-content: flex-start;
  }
  
  /* Adjust stage multiplier badge for mobile */
  .stage-multiplier-badge {
    font-size: 10px;
    padding: 3px 5px;
    min-width: 18px;
    bottom: -14px;
    left: 50%;
    transform: translateX(-50%);
  }
  
  .next {
    order: 2;
    width: 100%;
    justify-self: center;
    margin-top: 32px; /* Space for the label above the queue */
  }
  
  .score-label, .next .label, .gold-label {
    font-size: 16px;
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    white-space: nowrap;
    z-index: 1000;
    pointer-events: none;
    margin-bottom: 8px;
  }
  
  .gold-label {
    color: white;
  }
  
  .score-value, .gold-value {
    font-size: 20px;
    padding: 8px 16px;
    min-width: 100px;
  }
  
  .next-disc {
    width: 80px;
    height: 35px;
    font-size: 18px;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  /* Adjust bomb blocks in next queue for mobile */
  .next-disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .next-disc .bomb-text {
    font-size: 18px;
  }
  
  /* Fix next blocks animation for mobile */
  .next-disc.shift-left {
    transform: translateX(-96px); /* Adjusted for mobile next-disc width + gap */
  }
  
  .next-disc.consume-out {
    animation-duration: calc(0.15s * var(--animation-speed, 1)); /* Slightly faster on mobile */
    transition: none; /* Disable transition during animation to prevent conflicts */
  }
  
  /* Mobile swap animations */
  .next-disc.swap-animation-1 {
    animation-duration: calc(0.25s * var(--animation-speed, 1)); /* Slightly faster on mobile */
  }
  .next-disc.swap-animation-2 {
    animation-duration: calc(0.25s * var(--animation-speed, 1)); /* Slightly faster on mobile */
  }
  
  @keyframes swapBlock1 {
    0% { transform: translateX(0) scale(1); }
    50% { transform: translateX(48px) scale(1.1); }
    100% { transform: translateX(96px) scale(1); }
  }
  
  @keyframes swapBlock2 {
    0% { transform: translateX(0) scale(1); }
    50% { transform: translateX(-48px) scale(1.1); }
    100% { transform: translateX(-96px) scale(1); }
  }
  
  /* Fix drop animation for mobile - override default with higher specificity */
  .game .pole .disc.animate {
    animation: dropMobile calc(0.15s * var(--animation-speed, 1)) ease-out !important;
  }
  
  @keyframes dropMobile {
    from { transform: translateY(-50px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  /* Adjust game container for mobile */
  .game-container {
    margin-top: 20px;
    padding-bottom: 8px;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    display: flex;
    /* Ensure horizontal scrolling if needed to keep all 4 stacks visible */
    overflow-x: auto;
    overflow-y: visible;
    width: 100%;
    max-width: 100%;
  }
  
  .game {
    order: 1;
  }
  

  

  
  /* Adjust game grid for mobile */
  .game {
    gap: 16px;
    justify-content: center;
    flex-wrap: nowrap;
  }
  
  /* Make poles smaller for mobile */
  .pole {
    width: 100px;
    /* Height will be set by JavaScript via --stack-height variable */
    padding: 12px;
  }
  
  /* Adjust discs for smaller poles */
  .disc {
    width: 76px;
    height: 30px;
    font-size: 18px;
    margin-top: 6px;
  }
  
  /* Adjust bomb blocks for mobile to match disc sizing */
  .disc .bomb-emoji {
    font-size: 30px;
    top: -2px;
    left: -15px;
  }
  
  .disc .bomb-text {
    font-size: 18px;
  }
}

/* Mobile responsive help modal and other mobile adjustments */
@media (max-width: 768px) {
  /* Adjust bottom actions for mobile */
  .bottom-actions {
    margin-top: 16px;
    gap: 12px;
    order: 5;
  }
  
  .ai-btn {
    padding: 10px 20px;
    font-size: 14px;
  }
  
  /* Adjust help modal for mobile */
  .help-modal {
    width: 95vw;
    padding: 20px;
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    /* Position will be set dynamically via JavaScript */
    position: absolute;
  }

  /* Mobile help modal backdrop positioning */
  .help-modal-backdrop {
    padding: 0;
    align-items: flex-start;
    justify-content: center;
  }
  


  /* Mobile responsive for help modal high score display */
  .help-modal .title-text {
    font-size: 1em !important;
    color: var(--text) !important;
    font-weight: 700 !important;
  }
  
  .help-modal .stats-btn {
    font-size: 16px !important;
    margin-left: auto !important;
    padding: 10px 16px !important;
    background: #334155 !important;
    border: 1px solid #475569 !important;
    color: var(--text) !important;
    font-weight: 500 !important;
    font-family: var(--font-family) !important;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2) !important;
  }




  
  /* Mobile responsive for help modal actions */
  .help-modal .actions {
    flex-direction: column;
    gap: 12px;
    align-items: stretch;
  }
  
  .help-modal .actions button {
    width: 100%;
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) on mobile */
  .help-modal::-webkit-scrollbar {
    display: none;
  }
  
  /* Mobile responsive for floating close button - screen corner with safe area */
  .help-modal-close-btn,
  .shop-modal-close-btn {
    position: fixed;
    top: calc(env(safe-area-inset-top, 0px) + 24px);
    right: calc(env(safe-area-inset-right, 0px) + 20px);
    padding: 10px 16px;
    font-size: 16px;
  }
  
  /* Mobile responsive for sound control and settings modal close buttons */
  .sound-control-modal .help-modal-close-btn,
  .settings-modal .help-modal-close-btn {
    position: fixed;
    top: calc(env(safe-area-inset-top, 0px) + 24px);
    right: calc(env(safe-area-inset-right, 0px) + 20px);
    padding: 10px 16px;
    font-size: 16px;
  }
  
  .help-grid {
    gap: 16px;
  }
  
  /* Adjust powerup buttons section for mobile */
  .help-modal .help-content [style*="gap: 80px"] {
    gap: 40px !important;
  }
  
  /* Make powerup buttons more compact on mobile */
  .help-modal .powerup-btn {
    min-width: 50px !important;
    min-height: 50px !important;
    max-width: 90px !important;
    padding: 0 !important;
  }
  
  .help-modal .powerup-emoji {
    font-size: 20px !important;
  }
  
  /* Adjust help section padding for mobile */
  .help-modal .help-section {
    padding: 16px !important;
  }
  
  /* Adjust help section header spacing for mobile */
  .help-modal .help-section-header {
    margin-bottom: 12px !important;
  }
  
  .help-modal .help-section-header h3 {
    font-size: 18px !important;
  }
  
  /* Make merge examples more compact on mobile */
  .help-modal .merge-example {
    gap: 30px !important;
  }
  
  .help-modal .merge-example[style*="gap: 80px"] {
    gap: 30px !important;
  }
  
  .help-modal .merge-block {
    width: 70px !important;
    height: 28px !important;
    font-size: 18px !important;
  }
  
  .help-modal .merge-block.bomb-block {
    width: 76px !important;
    height: 30px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-emoji {
    font-size: 30px !important;
    top: -2px !important;
    left: -15px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-text {
    font-size: 18px !important;
  }
  
  .help-modal .merge-arrow {
    font-size: 18px !important;
  }
  
  .help-modal .merge-example [style*="gap: 12px"] {
    gap: 10px !important;
  }
  
  .help-modal .merge-example [style*="margin-left: 20px"] {
    margin-left: 16px !important;
  }
  
  /* Adjust debug pane for mobile */
  .debug-pane {
    width: 95vw;
    right: 0;
  }
}

  /* Extra small mobile devices */
  @media (max-width: 480px) {
    .topbar {
      padding: 2px 8px 6px;
      margin: 0;
    }
    
    /* Extra small mobile debug pane adjustments */
    .debug-pane {
      padding-bottom: calc(140px + env(safe-area-inset-bottom, 0px)); /* Even more bottom padding for very small screens */
    }
    
    .debug-pane .bottom-buttons {
      padding-bottom: 24px; /* Extra padding for very small screens */
    }
    
    /* Extra small mobile button sizing */
    .title-btn {
      width: 44px !important;
      height: 44px !important;
      border-radius: 10px !important;
      font-size: 22px !important;
      min-width: 44px !important;
      min-height: 44px !important;
    }
  
  h1 {
    font-size: 22px;
  }
  
  /* Extra help modal adjustments for very small screens */
  .help-modal {
    width: 98vw;
    padding: 16px;
    position: absolute;
  }

  /* Extra small mobile help modal backdrop positioning */
  .help-modal-backdrop {
    padding: 0;
    align-items: flex-start;
    justify-content: center;
  }
  

  
  /* Extra small mobile floating close button - screen corner with safe area */
  .help-modal-close-btn,
  .shop-modal-close-btn {
    position: fixed;
    top: calc(env(safe-area-inset-top, 0px) + 16px);
    right: calc(env(safe-area-inset-right, 0px) + 16px);
    padding: 8px 12px;
    font-size: 14px;
  }
  
  /* Extra small mobile sound control and settings modal close buttons */
  .sound-control-modal .help-modal-close-btn,
  .settings-modal .help-modal-close-btn {
    position: fixed;
    top: calc(env(safe-area-inset-top, 0px) + 16px);
    right: calc(env(safe-area-inset-right, 0px) + 16px);
    padding: 8px 12px;
    font-size: 14px;
  }
  
  .help-modal .help-content [style*="gap: 80px"] {
    gap: 24px !important;
  }
  
  .help-modal .powerup-btn {
    min-width: 45px !important;
    min-height: 45px !important;
    max-width: 80px !important;
    padding: 0 !important;
  }
  
  .help-modal .powerup-emoji {
    font-size: 18px !important;
  }
  
  .help-modal .help-section {
    padding: 12px !important;
  }
  
  .help-modal .help-section-header h3 {
    font-size: 16px !important;
  }
  
  /* Make merge examples more compact on mobile */
  .help-modal .merge-example {
    gap: 20px !important;
  }
  
  .help-modal .merge-example[style*="gap: 80px"] {
    gap: 20px !important;
  }
  
  .help-modal .merge-block {
    width: 60px !important;
    height: 24px !important;
    font-size: 16px !important;
  }
  
  .help-modal .merge-block.bomb-block {
    width: 60px !important;
    height: 24px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-emoji {
    font-size: 24px !important;
    top: -2px !important;
    left: -12px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-text {
    font-size: 16px !important;
  }
  
  .help-modal .merge-arrow {
    font-size: 16px !important;
  }
  
  .help-modal .merge-example [style*="gap: 12px"] {
    gap: 8px !important;
  }
  
  .help-modal .merge-example [style*="margin-left: 20px"] {
    margin-left: 12px !important;
  }
  
  .game-info {
    display: grid;
    grid-template-columns: 1fr;
    grid-template-areas: 
      "score-gold"
      "next";
    gap: 16px;
    margin-top: 24px; /* Minimal spacing below title on extra small mobile */
    max-width: 100%;
    padding: 0 12px;
  }
  
  .next {
    grid-area: next;
    width: 100%;
    justify-self: center;
    margin-top: 32px; /* Space for the label above the queue */
  }
  
  .score-display {
    justify-self: start;
    justify-content: flex-end;
  }
  
  .gold-display {
    justify-self: end;
    justify-content: flex-start;
  }
  
  /* Style the score-gold container for extra small mobile */
  .score-gold-container {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 12px; /* Slightly smaller gap for extra small mobile */
    grid-area: score-gold;
    width: auto;
    margin: 0 auto;
  }
  
  /* Reset individual display positioning for extra small mobile */
  .score-display, .gold-display {
    margin: 0;
    width: auto;
    min-width: fit-content;
    flex-shrink: 0;
  }
  
  .score-label, .next .label, .gold-label {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    white-space: nowrap;
    z-index: 1000;
    pointer-events: none;
    margin-bottom: 8px;
  }
  
  .gold-label {
    color: white;
  }
  
  .pole {
    width: 80px;
    /* Height will be set by JavaScript via --stack-height variable */
    padding: 8px;
  }
  
  .disc {
    width: 64px;
    height: 26px;
    font-size: 16px;
    margin-top: 4px;
  }
  
  /* Adjust bomb blocks for extra small mobile */
  .disc .bomb-emoji {
    font-size: 22px;
    top: -1px;
    left: -11px;
  }
  
  .disc .bomb-text {
    font-size: 16px;
  }
  
  .next-disc {
    width: 70px;
    height: 30px;
    font-size: 16px;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  .score-value, .gold-value {
    min-width: 80px;
  }
  
  /* Adjust bomb blocks in next queue for extra small mobile */
  .next-disc .bomb-emoji {
    font-size: 26px;
    top: -1px;
    left: -13px;
  }
  
  .next-disc .bomb-text {
    font-size: 16px;
  }
  
  /* Fix next blocks animation for extra small mobile */
  .next-disc.shift-left {
    transform: translateX(-84px); /* Adjusted for extra small mobile next-disc width + gap */
  }
  
  .next-disc.consume-out {
    animation-duration: calc(0.15s * var(--animation-speed, 1)); /* Slightly faster on mobile */
    transition: none; /* Disable transition during animation to prevent conflicts */
  }
  
  /* Extra small mobile swap animations */
  .next-disc.swap-animation-1 {
    animation-duration: calc(0.25s * var(--animation-speed, 1)); /* Slightly faster on mobile */
  }
  .next-disc.swap-animation-2 {
    animation-duration: calc(0.25s * var(--animation-speed, 1)); /* Slightly faster on mobile */
  }
  
  @keyframes swapBlock1 {
    0% { transform: translateX(0) scale(1); }
    50% { transform: translateX(42px) scale(1.1); }
    100% { transform: translateX(84px) scale(1); }
  }
  
  @keyframes swapBlock2 {
    0% { transform: translateX(0) scale(1); }
    50% { transform: translateX(-42px) scale(1.1); }
    100% { transform: translateX(-84px) scale(1); }
  }
  
  /* Extra small mobile uses same drop animation approach */
  
  /* Fix drop animation for extra small mobile - override default with higher specificity */
  .game .pole .disc.animate {
    animation: dropMobileSmall calc(0.15s * var(--animation-speed, 1)) ease-out !important;
  }
  
  @keyframes dropMobileSmall {
    from { transform: translateY(-40px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  .game {
    gap: 12px;
    flex-wrap: nowrap;
  }
  
  .bomb-conversion-btn {
    width: 45px;
    height: 45px;
  }
  
  .bomb-conversion-btn .emoji {
    font-size: 20px;
  }
  
  /* Adjust stage multiplier badge for extra small mobile */
  .stage-multiplier-badge {
    font-size: 9px;
    padding: 2px 4px;
    min-width: 16px;
    bottom: -12px;
    left: 50%;
    transform: translateX(-50%);
  }
}

/* Landscape mobile orientation */
@media (max-width: 768px) and (orientation: landscape) {
  .game-container {
    flex-direction: row;
    align-items: flex-start;
    gap: 12px;
    width: 100%;
    max-width: 100%;
  }
  
  .game {
    flex-wrap: nowrap;
  }
  
  .pole {
    height: 250px;
  }
  
  /* Adjust bomb blocks for landscape mobile */
  .disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .disc .bomb-text {
    font-size: 20px;
  }
  
  /* Adjust bomb blocks in next queue for landscape mobile */
  .next-disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .next-disc .bomb-text {
    font-size: 20px;
  }
}



/* Probability test results modal */
.prob-test-modal { 
  position: fixed; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%); 
  background: var(--panel); 
  color: var(--text); 
  width: min(600px, 90vw); 
  border-radius: 16px; 
  padding: 24px; 
  box-shadow: 0 15px 45px rgba(0,0,0,0.4); 
  font-family: var(--font-family);
  z-index: 1001;
  max-height: 80vh;
  overflow-y: auto;
}

.prob-test-modal h3 { 
  margin: 0 0 20px; 
  font-size: 20px; 
  text-align: center; 
  color: #0ea5e9;
  font-family: var(--font-family);
}

.prob-test-results {
  background: var(--bg);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
  border: 1px solid #475569;
}

.prob-test-table {
  width: 100%;
  border-collapse: collapse;
  margin: 12px 0;
  font-size: 14px;
}

.prob-test-table th,
.prob-test-table td {
  padding: 8px 12px;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.prob-test-table th {
  background: #334155;
  font-weight: 600;
  color: #f8fafc;
}

.prob-test-table td {
  font-family: 'Courier New', monospace;
  font-size: 13px;
}

.prob-test-table .block-value {
  font-weight: 600;
  color: #0ea5e9;
}

.prob-test-table .expected {
  color: #10B981;
}

.prob-test-table .actual {
  color: #F59E0B;
}

.prob-test-table .difference {
  color: #EF4444;
}

.prob-test-summary {
  text-align: center;
  margin-top: 16px;
  padding: 12px;
  background: #334155;
  border-radius: 6px;
  border: 1px solid #475569;
}

.prob-test-summary .total {
  font-size: 16px;
  font-weight: 600;
  color: #10B981;
}

.prob-test-close {
  background: #334155;
  color: var(--text);
  border: 1px solid #475569;
  padding: 10px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: background 0.2s;
  font-family: var(--font-family);
  width: 100%;
  margin-top: 16px;
}

.prob-test-close:hover {
  background: #475569;
}

.prob-test-close:active {
  background: #334155;
}



/* Hide next blocks section when game is over */
.next.game-over-hidden {
  opacity: 0.3;
  pointer-events: none;
}

/* Show new game button in place of next blocks */
.new-game-container {
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  margin-top: 16px;
}

.new-game-container.show {
  display: flex;
}

.new-game-container .label {
  font-size: 18px;
  opacity: 0.9;
  font-family: var(--font-family);
}

.new-game-container .new-game-btn {
  padding: 12px 24px;
  font-size: 16px;
}

  /* Sound Control Modal Styles */
  .sound-control-modal { 
    background: var(--panel); 
    color: var(--text); 
    width: min(500px, 85vw); /* Narrower width to create margins like help guide */
    border-radius: 16px; 
    padding: 28px; 
    box-shadow: 0 15px 45px rgba(0,0,0,0.4); 
    font-family: var(--font-family);
    z-index: 1001;
    max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 120px);
    overflow-y: auto;
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    /* Ensure modal fits within safe area and starts below close button */
    margin: 0;
    position: absolute;
    top: 80px; /* Start below the close button with proper spacing - accounts for button height + border + text */
  }

  .sound-control-modal h2 { 
    margin: 0 0 24px; 
    font-size: 24px; 
    text-align: center; 
    color: #0ea5e9;
    font-family: var(--font-family);
  }
  
  /* Settings Modal Styles - same positioning as sound control modal */
  .settings-modal { 
    background: var(--panel); 
    color: var(--text); 
    width: min(500px, 85vw); /* Narrower width to create margins like help guide */
    border-radius: 16px; 
    padding: 28px; 
    box-shadow: 0 15px 45px rgba(0,0,0,0.4); 
    font-family: var(--font-family);
    z-index: 1001;
    max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 120px);
    overflow-y: auto;
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    /* Ensure modal fits within safe area and starts below close button */
    margin: 0;
    position: absolute;
    top: 80px; /* Start below the close button with proper spacing - accounts for button height + border + text */
  }

.sound-control-container {
  background: var(--bg);
  border-radius: 8px;
  border: 1px solid #475569;
  padding: 20px;
  margin-bottom: 20px;
}

.sound-control-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
  gap: 16px;
}

.sound-control-row:last-child {
  margin-bottom: 0;
}

.sound-control-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 16px;
  min-width: 120px;
}

.sound-control-emoji {
  font-size: 20px;
}

.sound-control-slider {
  flex: 1;
  min-width: 0;
  accent-color: #0ea5e9;
}

.sound-control-controls {
  display: flex;
  align-items: center;
  gap: 16px;
  flex: 1;
}

.sound-control-controls .volume-value {
  min-width: 30px;
  text-align: center;
  font-weight: 600;
  color: var(--text);
  flex-shrink: 0;
}



.sound-control-mute {
  background: #334155;
  color: var(--text);
  border: 1px solid #475569;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.2s ease;
  font-family: var(--font-family);
  min-width: 80px;
}

.sound-control-mute:hover {
  background: #475569;
  border-color: #64748b;
}

.sound-control-mute:active {
  background: #334155;
}

.sound-control-mute.muted {
  background: #dc2626;
  border-color: #ef4444;
}

.sound-control-mute.muted:hover {
  background: #b91c1c;
  border-color: #dc2626;
}

.theme-selector {
  background: var(--panel);
  color: var(--text);
  border: 1px solid #475569;
  padding: 8px 12px;
  border-radius: 6px;
  font-family: var(--font-family);
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 120px;
}

.theme-selector:hover {
  border-color: #64748b;
}

  .theme-selector:focus {
    outline: none;
    border-color: #0ea5e9;
    box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.2);
  }
  
  /* Mobile responsive theme selector */
  @media (max-width: 768px) {
    .theme-selector {
      min-width: 100px;
      font-size: 16px; /* Prevent zoom on iOS */
      padding: 10px 14px;
    }
  }
  
  /* Debug pane theme selector styling */
  .debug-pane .theme-selector {
    min-width: 120px;
    background: var(--bg);
    border-color: #64748b;
  }


  
  /* Mobile responsive debug panel */
  @media (max-width: 768px) {
    .debug-pane {
      width: 100vw; /* Full width on mobile */
      right: 0;
      z-index: 9999; /* Ensure it's above everything on mobile */
      touch-action: manipulation; /* Improve touch handling */
      /* Ensure bottom buttons are always accessible */
      padding-bottom: calc(120px + env(safe-area-inset-bottom, 0px)); /* Add bottom padding to account for browser controls and safe areas */
      /* Improve scrolling behavior on mobile */
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
    }
    
    .debug-pane .close-btn {
      position: fixed; /* Fixed positioning for better mobile touch */
      top: 20px;
      right: 20px;
      z-index: 10000; /* Above the debug panel */
      background: rgba(30, 41, 59, 0.9); /* More visible background */
      border: 1px solid #64748b;
      padding: 12px; /* Larger touch target */
      min-width: 44px; /* iOS minimum touch target size */
      min-height: 44px;
      /* Ensure touch events work properly */
      pointer-events: auto !important;
      touch-action: manipulation;
      -webkit-tap-highlight-color: rgba(14, 165, 233, 0.3); /* Visual feedback on touch */
      user-select: none; /* Prevent text selection */
    }
    
    /* Ensure the close button is always on top and touchable */
    .debug-pane .close-btn:hover,
    .debug-pane .close-btn:active,
    .debug-pane .close-btn:focus {
      background: rgba(51, 65, 85, 0.95);
      border-color: #0ea5e9;
      outline: none;
    }
    
    /* Ensure bottom buttons section is always accessible */
    .debug-pane .bottom-buttons {
      margin-top: auto;
      padding-top: 16px;
      padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px)); /* Extra bottom padding for mobile with safe area support */
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }
  }







  /* Mobile responsive design for sound control and settings modals */
@media (max-width: 768px) {
  .sound-control-modal,
  .settings-modal,
  .shop-modal {
    width: 90vw; /* Narrower width to create margins like help guide */
    padding: 24px;
    margin: 20px;
    /* Mobile positioning - start below close button */
    position: absolute;
    top: calc(env(safe-area-inset-top, 0px) + 70px); /* Account for close button height + small padding */
  }
  
  .sound-control-modal h2,
  .settings-modal h2 {
    font-size: 22px;
    margin-bottom: 20px;
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) on mobile */
  .sound-control-modal::-webkit-scrollbar,
  .settings-modal::-webkit-scrollbar {
    display: none;
  }
  
  .sound-control-container {
    padding: 16px;
    margin-bottom: 16px;
  }
  
  /* Settings modal container styling */
  .settings-modal .sound-control-container {
    padding: 16px;
    margin-bottom: 16px;
  }
  
  .sound-control-row {
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    margin-bottom: 20px;
  }
  
  /* Settings modal row styling */
  .settings-modal .sound-control-row {
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    margin-bottom: 20px;
  }
  
  .sound-control-label {
    min-width: auto;
    justify-content: flex-start;
    flex-shrink: 0;
  }
  
  /* Settings modal label styling */
  .settings-modal .sound-control-label {
    min-width: auto;
    justify-content: flex-start;
    flex-shrink: 0;
  }
  
  .sound-control-slider {
    width: 200px !important;
    flex: none !important;
    flex-shrink: 0;
  }
  
  /* Create a horizontal container for slider + value on mobile */
  .sound-control-controls {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 12px;
    flex-shrink: 0;
  }
  
  .sound-control-controls .sound-control-slider {
    width: 200px !important;
    flex: none !important;
    flex-shrink: 0;
  }
  
  .sound-control-controls .volume-value {
    min-width: 30px;
    text-align: center;
    font-weight: 600;
    color: var(--text);
    flex-shrink: 0;
  }
  
  /* Settings modal slider and controls styling */
  .settings-modal .sound-control-slider {
    width: 200px !important;
    flex: none !important;
    flex-shrink: 0;
  }
  
  .settings-modal .sound-control-controls {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 12px;
    flex-shrink: 0;
  }
  
  .settings-modal .sound-control-controls .sound-control-slider {
    width: 200px !important;
    flex: none !important;
    flex-shrink: 0;
  }
  
  .settings-modal .sound-control-controls .volume-value {
    min-width: 30px;
    text-align: center;
    font-weight: 600;
    color: var(--text);
    flex-shrink: 0;
  }
  
  /* For rows with just a button (like master mute), center the button */
  .sound-control-row:has(.sound-control-mute) {
    align-items: center;
  }
  
  .sound-control-mute {
    align-self: center;
    min-width: 100px;
  }
  
  /* Settings modal mute button styling */
  .settings-modal .sound-control-row:has(.sound-control-mute) {
    align-items: center;
  }
  
  .settings-modal .sound-control-mute {
    align-self: center;
    min-width: 100px;
  }
  
  /* Theme selector styling for mobile */
  .theme-selector {
    width: 200px !important;
    min-width: 200px !important;
    flex-shrink: 0;
  }
  
  /* Settings modal theme selector controls - right justify the dropdown */
  .settings-modal .sound-control-controls:has(.theme-selector) {
    justify-content: flex-end;
  }
}

/* Medium-small mobile devices */
@media (max-width: 600px) and (min-width: 481px) {
  /* Adjust slider width for medium-small screens */
  .sound-control-slider,
  .sound-control-controls .sound-control-slider,
  .settings-modal .sound-control-slider,
  .settings-modal .sound-control-controls .sound-control-slider {
    width: 180px !important;
    flex: none !important;
  }
  
  /* Theme selector width for medium-small screens */
  .theme-selector {
    width: 180px !important;
    min-width: 180px !important;
  }
}

/* Extra small mobile devices */
@media (max-width: 480px) {
  .sound-control-modal,
  .settings-modal,
  .shop-modal {
    width: 92vw; /* Narrower width to create margins like help guide */
    padding: 20px;
    margin: 16px;
    /* Extra small mobile positioning - start below close button */
    position: absolute;
    top: calc(env(safe-area-inset-top, 0px) + 65px); /* Account for close button height + small padding */
  }
  
  .sound-control-modal h2,
  .settings-modal h2 {
    font-size: 20px;
    margin-bottom: 18px;
  }
  
  .sound-control-container {
    padding: 14px;
    margin-bottom: 14px;
  }
  
  /* Settings modal container styling for extra small mobile */
  .settings-modal .sound-control-container {
    padding: 14px;
    margin-bottom: 14px;
  }
  
  .sound-control-row {
    gap: 10px;
    margin-bottom: 18px;
  }
  
  /* Settings modal row styling for extra small mobile */
  .settings-modal .sound-control-row {
    gap: 10px;
    margin-bottom: 18px;
  }
  
  .sound-control-label {
    font-size: 15px;
  }
  
  /* Settings modal label styling for extra small mobile */
  .settings-modal .sound-control-label {
    font-size: 15px;
  }
  
  .sound-control-emoji {
    font-size: 18px;
  }
  
  /* Settings modal emoji styling for extra small mobile */
  .settings-modal .sound-control-emoji {
    font-size: 18px;
  }
  
  /* Adjust slider width for very small screens */
  .sound-control-slider,
  .sound-control-controls .sound-control-slider,
  .settings-modal .sound-control-slider,
  .settings-modal .sound-control-controls .sound-control-slider {
    width: 150px !important;
    flex: none !important;
  }
  
  /* Theme selector width for very small screens */
  .theme-selector {
    width: 150px !important;
    min-width: 150px !important;
  }
}
</style>
</head>
<body class="development-mode">
  <!-- Probability test results modal (hidden by default) -->
  <div id="probTestModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="probTestTitle">
    <div class="modal prob-test-modal">
      <h3 id="probTestTitle">Probability Distribution Test Results</h3>
      
      <div class="prob-test-results">
        <div id="probTestContent">
          <!-- Test results will be populated here -->
        </div>
      </div>
      
      <button id="probTestClose" class="prob-test-close">Close</button>
    </div>
  </div>

  <div class="topbar">
    <div class="title-section">
      <div class="left-section">
        <button id="addBtn" class="title-btn" title="New Game">➕</button>
        <button id="helpBtn" class="title-btn" title="How to play">❔</button>
      </div>
      <div class="center-section">
        <h1>Stack<br>Merge</h1>
      </div>
      <div class="right-section">
        <button id="soundBtn" class="title-btn" title="Sound Controls">🔊</button>
        <button id="settingsBtn" class="title-btn" title="Customization">🎨</button>
      </div>
    </div>
  </div>

  <div class="game-info">
    <div class="score-gold-container">
      <div class="score-display">
        <div class="score-value" id="scoreDisplay">
          <div class="score-label">Score</div>
          <div class="score-star">⭐</div>
          <div class="score-text">2</div>
        </div>
      </div>
      
      <div class="gold-display">
        <div class="gold-value" id="goldDisplay">
          <div class="gold-label">Gold</div>
          <div class="gold-emoji">💰</div>
          <div class="gold-text">0</div>
        </div>
      </div>
    </div>
    
    <div class="next">
      <div class="label">Next Blocks</div>
      <div class="next-row" id="nextContainer" aria-live="polite"><div class="next-disc current" style="background: rgb(207, 239, 8); color: rgb(0, 0, 0); --animation-speed: 1;">1</div><div class="next-disc" style="background: rgb(16, 185, 129); color: rgb(255, 255, 255); --animation-speed: 1;">2</div><div class="next-disc" style="background: rgb(16, 185, 129); color: rgb(255, 255, 255); --animation-speed: 1;">2</div></div>
    </div>
  </div>
  


  <!-- Game Over Button Overlay -->
  <div id="gameOverButton" class="game-over-button-overlay">
    <div class="game-over-text">Game Over</div>
    <div class="largest-merge-info">
              <div class="largest-merge-label">Largest Block:</div>
      <div id="largestMergeBlock" class="largest-merge-block"></div>
    </div>
    <div class="gold-earned-info">
      <div class="gold-earned-label">Total Gold Earned:</div>
      <div id="goldEarnedDisplay" class="gold-earned-amount">
        <div class="gold-emoji">💰</div>
        <div class="gold-text">0</div>
      </div>
    </div>
    <div class="final-score-info">
      <div class="final-score-label">Final Score:</div>
      <div id="finalScoreDisplay" class="final-score-amount">
        <div class="score-star">⭐</div>
        <div class="score-text">0</div>
        <div id="newHighScoreMessage" class="new-high-score-badge hidden">NEW RECORD</div>
      </div>
    </div>
  </div>

  <!-- New Game Confirmation Modal -->
  <div id="newGameModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="newGameTitle">
    <div class="modal new-game-modal">
      <h2 id="newGameTitle">New Game?</h2>
      <div class="new-game-buttons">
        <button id="confirmNewGameBtn" class="confirm-new-game-btn">Yes</button>
        <button id="cancelNewGameBtn" class="cancel-new-game-btn">No</button>
      </div>
    </div>
  </div>

  <!-- Sound Control Modal -->
  <div id="soundControlModal" class="modal-backdrop help-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="soundControlTitle">
    <div class="modal sound-control-modal">
      <h2 id="soundControlTitle">Sound Controls</h2>
      
      <div class="sound-control-container">
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🔊</span>
            <span>Master Mute</span>
          </div>
          <button id="masterMuteBtn" class="sound-control-mute">Mute</button>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">📦</span>
            <span>Drops</span>
          </div>
          <div class="sound-control-controls">
            <input type="range" id="dropVolumeSlider" class="sound-control-slider" min="0" max="5" step="1">
            <span id="dropVolumeValue" class="volume-value">3</span>
          </div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🔗</span>
            <span>Merges</span>
          </div>
          <div class="sound-control-controls">
            <input type="range" id="mergeVolumeSlider" class="sound-control-slider" min="0" max="5" step="1">
            <span id="mergeVolumeValue" class="volume-value">3</span>
          </div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">💰</span>
            <span>Gold</span>
          </div>
          <div class="sound-control-controls">
            <input type="range" id="coinVolumeSlider" class="sound-control-slider" min="0" max="5" step="1">
            <span id="coinVolumeValue" class="volume-value">3</span>
          </div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">💥</span>
            <span>Bombs</span>
          </div>
          <div class="sound-control-controls">
            <input type="range" id="bombVolumeSlider" class="sound-control-slider" min="0" max="5" step="1">
            <span id="bombVolumeValue" class="volume-value">3</span>
          </div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🚀</span>
            <span>Other</span>
          </div>
          <div class="sound-control-controls">
            <input type="range" id="otherVolumeSlider" class="sound-control-slider" min="0" max="5" step="1">
            <span id="otherVolumeValue" class="volume-value">3</span>
          </div>
        </div>
      </div>
      
      <button id="soundControlClose" class="help-modal-close-btn" title="Close sound controls">❌ Close</button>
    </div>
  </div>

  <!-- Customization Modal -->
  <div id="settingsModal" class="modal-backdrop help-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
    <div class="modal sound-control-modal settings-modal">
      <h2 id="settingsTitle">Customization</h2>
      
      <div class="sound-control-container">
        <!-- Theme Settings -->
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🎨</span>
            <span>Theme</span>
          </div>
          <div class="sound-control-controls">
                    <select id="themeSelector" class="theme-selector"><option value="jellyfish">Jellyfish</option><option value="alternate">Earth</option></select>
          </div>
        </div>
        

        

      </div>
      
      <button id="settingsClose" class="help-modal-close-btn" title="Close customization">❌ Close</button>
    </div>
  </div>

  <div class="game-container">
    <div class="game" id="game" role="application" aria-label="Stacks"><div class="pole" role="button" tabindex="0" aria-label="Stack 1, contains 1 blocks" style="--animation-speed: 1;"><div class="disc" style="background: rgb(207, 239, 8); color: rgb(0, 0, 0);">1</div></div><div class="pole" role="button" tabindex="0" aria-label="Stack 2, contains 1 blocks" style="--animation-speed: 1;"><div class="disc" style="background: rgb(207, 239, 8); color: rgb(0, 0, 0);">1</div></div><div class="pole" role="button" tabindex="0" aria-label="Stack 3, contains 0 blocks" style="--animation-speed: 1;"></div><div class="pole" role="button" tabindex="0" aria-label="Stack 4, contains 0 blocks" style="--animation-speed: 1;"></div></div>
  </div>
  

  <!-- Unified Powerup Shop - Below Game Area -->
  <div class="powerup-shop">
    <div class="shop-grid">
      <button id="trashButton" class="powerup-btn" title="Remove next block from queue" disabled="">
        <span class="powerup-emoji">🗑️</span>
        <div class="powerup-cost-badge" id="trashCostBadge" style="display: none;"></div>
        <div class="powerup-ownership-badge" id="trashOwnershipBadge">0</div>
      </button>
      
      <button id="swapButton" class="powerup-btn" title="Select block to drop from queue" disabled="">
        <span class="powerup-emoji">🔄</span>
        <div class="powerup-cost-badge" id="swapCostBadge" style="display: none;"></div>
        <div class="powerup-ownership-badge" id="swapOwnershipBadge">0</div>
      </button>
      
      <button id="bombConversionBtn" class="powerup-btn bomb-btn" title="Convert next block to bomb (press again to undo)" disabled="">
        <span class="powerup-emoji">💣</span>
        <div class="powerup-cost-badge" id="bombCostBadge" style="display: none;"></div>
        <div class="powerup-ownership-badge" id="bombOwnershipBadge">0</div>
      </button>
      
      <button id="pickaxeButton" class="powerup-btn" title="Remove any block from stacks (press again to deactivate)" disabled="">
        <span class="powerup-emoji">⛏️</span>
        <div class="powerup-cost-badge" id="pickaxeCostBadge" style="display: none;"></div>
        <div class="powerup-ownership-badge" id="pickaxeOwnershipBadge">0</div>
      </button>
      

    </div>
  </div>
  
  <div class="bottom-actions">
    <button id="debugBtn" class="ai-btn" title="Debug controls" style="display: block;">⚙️</button>
  </div>


  <!-- Help modal (hidden by default) -->
  <div id="helpModal" class="modal-backdrop help-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modal help-modal" style="top: 20px; max-height: 819px; padding-top: 20px;">
      <button id="helpClose" class="help-modal-close-btn" title="Close help guide">❌ Close</button>
      <h2 id="helpTitle">
        <span class="title-text">How to Play</span>
        <button id="showStatsBtn" class="stats-btn" title="Show Player Statistics" style="background: #334155 !important; border: 1px solid #475569 !important; color: var(--text) !important; padding: 10px 20px !important; border-radius: 8px !important; font-family: var(--font-family) !important; font-weight: 500 !important; cursor: pointer !important; margin-left: auto !important; appearance: none !important; -webkit-appearance: none !important; font-size: 16px !important;">📊 My Stats</button>
      </h2>
      
      <div class="help-grid">
        <!-- Basic Controls Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🎮</span>
            <h3>Basic Gameplay</h3>
          </div>
          <div class="help-content">
                        <div style="background: var(--panel); border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid #475569;">
              <h4 style="margin: 0 0 16px 0; color: #fbbf24; font-size: 18px; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 20px;">⭐</span>
                Main Objectives
              </h4>
              <ul style="margin: 0; padding-left: 20px; list-style: none;">
                <li style="margin: 0 0 8px 0; font-size: 16px; line-height: 1.5; display: flex; align-items: baseline; gap: 8px;">
                  <span style="color: #fbbf24; font-size: 18px;">•</span>
                  <span>Get a high score by surviving as long as possible. Dropping blocks increases your score.</span>
                </li>
                <li style="margin: 0 0 8px 0; font-size: 16px; line-height: 1.5; display: flex; align-items: baseline; gap: 8px;">
                  <span style="color: #fbbf24; font-size: 18px;">•</span>
                  <span>Merging blocks creates more space and gains gold.</span>
                </li>
                <li style="margin: 0 0 8px 0; font-size: 16px; line-height: 1.5; display: flex; align-items: baseline; gap: 8px;">
                  <span style="color: #fbbf24; font-size: 18px;">•</span>
                  <span>Gold can be used to buy items which will help you survive!</span>
                </li>
              </ul>
            </div>
            
            <div style="background: var(--panel); border-radius: 12px; padding: 20px; border: 1px solid #475569;">
              <h4 style="margin: 0 0 16px 0; color: var(--text); font-size: 18px; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 20px;">🎮</span>
                Controls
              </h4>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: 8px; border: 1px solid #475569;">
                  <span style="font-size: 24px;">⬇️</span>
                  <span style="font-size: 14px; font-weight: 500;">Tap on a column to drop the next block</span>
                </div>
                <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: 8px; border: 1px solid #475569;">
                  <span style="font-size: 24px;">💰</span>
                  <span style="font-size: 14px; font-weight: 500;">Buy items with gold</span>
                </div>
                <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: 8px; border: 1px solid #475569;">
                  <span style="font-size: 24px;">🗑️</span>
                  <span style="font-size: 14px; font-weight: 500;">Remove the next block from the queue</span>
                </div>
                <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: 8px; border: 1px solid #475569;">
                  <span style="font-size: 24px;">🔄</span>
                  <span style="font-size: 14px; font-weight: 500;">Select which block to drop from the queue</span>
                </div>
                <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: 8px; border: 1px solid #475569;">
                  <span style="font-size: 24px;">💣</span>
                  <span style="font-size: 14px; font-weight: 500;">Convert the next block to a bomb</span>
                </div>
                <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: 8px; border: 1px solid #475569;">
                  <span style="font-size: 24px;">⛏️</span>
                  <span style="font-size: 14px; font-weight: 500;">Destroy any block in the game</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Merging Section -->
        <!-- Basic Merging Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🔗</span>
            <h3>Merging Blocks</h3>
          </div>
          <div class="help-content">
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• When two blocks with the same value are stacked, they merge into one bigger block.</p>
            <div class="merge-example" style="display: flex; gap: 80px; justify-content: center;">
              <div style="display: flex; align-items: center; gap: 12px;">
                <div class="merge-before">
                  <div class="merge-blocks">
                    <div class="merge-block" data-value="1">1</div>
                    <div class="merge-block" data-value="1">1</div>
                  </div>
                </div>
                <div class="merge-arrow">→</div>
                <div class="merge-after">
                  <div class="merge-blocks">
                    <div class="merge-block" data-value="2">2</div>
                  </div>
                </div>
              </div>
              
              <div style="display: flex; align-items: center; gap: 12px;">
                <div class="merge-before">
                  <div class="merge-blocks">
                    <div class="merge-block" data-value="2">2</div>
                    <div class="merge-block" data-value="2">2</div>
                  </div>
                </div>
                <div class="merge-arrow">→</div>
                <div class="merge-after">
                  <div class="merge-blocks">
                    <div class="merge-block" data-value="4">4</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Gold Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">💰</span>
            <h3>Gold</h3>
          </div>
          <div class="help-content">
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Merging blocks earns gold. Merge multiple blocks in a row to earn bonus gold.</p>
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Gold is used to purchase items, which are valuable tools for survival.</p>
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• You can earn 10x, 100x, or 1000x+ the normal amount of gold! Read the <strong>Stage Progression</strong> section of this guide.</p>
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;"></p>
          </div>
        </div>

        <!-- Bomb Blocks Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">💣</span>
            <h3>Bomb Blocks</h3>
          </div>
          <div class="help-content">
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• When a bomb block merges with a block of the same value, it explodes and destroys the entire stack!</p>
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Bomb blocks will occasionally appear in the queue.</p>
            <div class="merge-example">
              <div class="merge-before">
                <div class="merge-blocks">
                  <div class="merge-block" data-value="2">2</div>
                  <div class="merge-block bomb-block">
                    <div class="bomb-content">
                      <div class="bomb-emoji">💣</div>
                      <div class="bomb-text">2</div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="merge-arrow">→</div>
              <div class="merge-after">
                <div class="merge-blocks">
                  <div class="merge-block bomb-block">
                    <div class="bomb-content">
                      <div class="bomb-emoji">💣</div>
                      <div class="bomb-text">4</div>
                    </div>
                  </div>
                </div>
              </div>
              <div style="display: flex; align-items: center; margin-left: 20px;">
                <span style="font-size: 24px; font-weight: bold; color: #f8fafc;">=</span>
                <span style="font-size: 18px; font-weight: bold; color: #ef4444; margin-left: 24px;">Stack Destroyed</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Powerups Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">⚡</span>
            <h3>Items</h3>
          </div>
          <div class="help-content">
            <div style="background: var(--panel); border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid #475569;">
              <h4 style="margin: 0 0 16px 0; color: var(--text); font-size: 18px; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 20px;">🗑️</span>
                Trash Can
              </h4>
              <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Trash Can removes the next block from the queue.</p>
              <div style="display: flex; justify-content: center; margin: 16px 0 24px 0;">
                <div style="display: flex; flex-direction: column; align-items: center; gap: 16px;">
                  <button class="powerup-btn" style="pointer-events: none; width: 120px; height: 80px; padding: 0; display: flex; align-items: center; justify-content: center; position: relative; visibility: visible !important; opacity: 1 !important;">
                    <span class="powerup-emoji" style="font-size: 28px;">🗑️</span>
                    <div class="powerup-ownership-badge" style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #16a34a; color: white; font-size: 11px; font-weight: 700; padding: 3px 5px; border-radius: 8px; border: 2px solid var(--bg); box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 10; font-family: var(--font-family); min-width: 18px; text-align: center; line-height: 1; box-sizing: border-box; white-space: nowrap;">1</div>
                  </button>
                  <span style="color: #f8fafc; font-size: 14px; text-align: center;">Removes the next block</span>
                </div>
              </div>
            </div>
            
            <div style="background: var(--panel); border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid #475569;">
              <h4 style="margin: 0 0 16px 0; color: var(--text); font-size: 18px; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 20px;">🔄</span>
                Swap
              </h4>
              <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Swap lets you select which block to drop from the queue. Press once to select the second block, twice for the third block, or three times to return to normal mode.</p>
              <div style="display: flex; justify-content: center; margin: 16px 0 24px 0;">
                <div style="display: flex; flex-direction: column; align-items: center; gap: 16px;">
                  <button class="powerup-btn" style="pointer-events: none; width: 120px; height: 80px; padding: 0; display: flex; align-items: center; justify-content: center; position: relative; visibility: visible !important; opacity: 1 !important;">
                    <span class="powerup-emoji" style="font-size: 28px;">🔄</span>
                    <div class="powerup-ownership-badge" style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #16a34a; color: white; font-size: 11px; font-weight: 700; padding: 3px 5px; border-radius: 8px; border: 2px solid var(--bg); box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 10; font-family: var(--font-family); min-width: 18px; text-align: center; line-height: 1; box-sizing: border-box; white-space: nowrap;">1</div>
                  </button>
                  <span style="color: #f8fafc; font-size: 14px; text-align: center;">Selects block to drop</span>
                </div>
              </div>
            </div>
            
            <div style="background: var(--panel); border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid #475569;">
              <h4 style="margin: 0 0 16px 0; color: var(--text); font-size: 18px; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 20px;">💣</span>
                Bomb
              </h4>
              <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Bomb turns the next block in queue into a bomb block.</p>
              <div style="display: flex; justify-content: center; margin: 16px 0 24px 0;">
                <div style="display: flex; flex-direction: column; align-items: center; gap: 16px;">
                  <button class="powerup-btn bomb-btn" style="pointer-events: none; width: 120px; height: 80px; padding: 0; display: flex; align-items: center; justify-content: center; position: relative; visibility: visible !important; opacity: 1 !important;">
                    <span class="powerup-emoji" style="font-size: 28px;">💣</span>
                    <div class="powerup-ownership-badge" style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #16a34a; color: white; font-size: 11px; font-weight: 700; padding: 3px 5px; border-radius: 8px; border: 2px solid var(--bg); box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 10; font-family: var(--font-family); min-width: 18px; text-align: center; line-height: 1; box-sizing: border-box; white-space: nowrap;">1</div>
                  </button>
                  <span style="color: #f8fafc; font-size: 14px; text-align: center;">Converts the next block to a bomb</span>
                </div>
              </div>
            </div>
            
            <div style="background: var(--panel); border-radius: 12px; padding: 20px; border: 1px solid #475569;">
              <h4 style="margin: 0 0 16px 0; color: var(--text); font-size: 18px; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 20px;">⛏️</span>
                Pickaxe
              </h4>
              <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Pickaxe will remove any single block from anywhere in the game.</p>
              <div style="display: flex; justify-content: center; margin: 16px 0 24px 0;">
                <div style="display: flex; flex-direction: column; align-items: center; gap: 16px;">
                  <button class="powerup-btn" style="pointer-events: none; width: 120px; height: 80px; padding: 0; display: flex; align-items: center; justify-content: center; position: relative; visibility: visible !important; opacity: 1 !important;">
                    <span class="powerup-emoji" style="font-size: 28px;">⛏️</span>
                    <div class="powerup-ownership-badge" style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #16a34a; color: white; font-size: 11px; font-weight: 700; padding: 3px 5px; border-radius: 8px; border: 2px solid var(--bg); box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 10; font-family: var(--font-family); min-width: 18px; text-align: center; line-height: 1; box-sizing: border-box; white-space: nowrap;">1</div>
                  </button>
                  <span style="color: #f8fafc; font-size: 14px; text-align: center;">Removes any block</span>
                </div>
              </div>
            </div>
          </div>
        </div>



        <!-- Stage System Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🚀</span>
            <h3>Stage Progression</h3>
          </div>
          <div class="help-content">
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Creating a block with value 1024 will give you a permanent 10x gold multiplier.</p>
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Each additional block value above this will once again 10x the multiplier: 100x, 1,000x, 10,000x ...</p>
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Power-ups increase in cost exponentially, so stage progression is crucial to survival in extended runs.</p>

            <div class="merge-example" style="justify-content: center; gap: 40px; padding: 20px;">
              <div style="display: flex; flex-direction: column; gap: 20px; align-items: center; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div style="margin: 0; justify-self: end;">
                    <div style="display: flex; align-items: center; justify-content: center;">
                      <div class="next-stage-block" data-value="1024" style="width: 100px; height: 42px; font-size: 22px; border-radius: 9px; display: flex; align-items: center; justify-content: center; font-weight: 600; box-shadow: 0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family);">1024</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div style="margin: 0; justify-self: start;">
                    <div style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 8px 16px; border-radius: 9px; font-weight: 600; font-size: 18px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div style="position: absolute; top: -10px; left: -10px; font-size: 24px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div style="position: relative; z-index: 2; font-size: 18px; font-weight: 600; line-height: 1; color: #000;">1.5k</div>
                      <div style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 9px; font-weight: 700; padding: 2px 4px; border-radius: 6px; border: 1px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 16px; text-align: center;">10x</div>
                    </div>
                  </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div style="margin: 0; justify-self: end;">
                    <div style="display: flex; align-items: center; justify-content: center;">
                      <div class="next-stage-block" data-value="2048" style="width: 100px; height: 42px; font-size: 22px; border-radius: 9px; display: flex; align-items: center; justify-content: center; font-weight: 600; box-shadow: 0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family);">2048</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div style="margin: 0; justify-self: start;">
                    <div style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 8px 16px; border-radius: 9px; font-weight: 600; font-size: 18px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div style="position: absolute; top: -10px; left: -10px; font-size: 24px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div style="position: relative; z-index: 2; font-size: 18px; font-weight: 600; line-height: 1; color: #000;">15.5k</div>
                      <div style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 9px; font-weight: 700; padding: 2px 4px; border-radius: 6px; border: 1px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 24px; text-align: center;">100x</div>
                    </div>
                  </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div style="margin: 0; justify-self: end;">
                    <div style="display: flex; align-items: center; justify-content: center;">
                      <div class="next-stage-block" data-value="4096" style="width: 100px; height: 42px; font-size: 22px; border-radius: 9px; display: flex; align-items: center; justify-content: center; font-weight: 600; box-shadow: 0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family);">4096</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div style="margin: 0; justify-self: start;">
                    <div style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 8px 16px; border-radius: 9px; font-weight: 600; font-size: 18px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div style="position: absolute; top: -10px; left: -10px; font-size: 24px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div style="position: relative; z-index: 2; font-size: 18px; font-weight: 600; line-height: 1; color: #000;">555.5k</div>
                      <div style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 9px; font-weight: 700; padding: 2px 4px; border-radius: 6px; border: 1px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 28px; text-align: center;">1000x</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Sound Controls Section -->
        <div class="help-section hidden">
          <div class="help-section-header">
            <span class="help-icon">🔊</span>
            <h3>Sound Controls</h3>
          </div>
          <div class="help-content">
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Customize your audio experience with the sound control menu.</p>
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• <strong>Volume Slider:</strong> Adjust the overall volume from 0% (muted) to 100% (full volume).</p>
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• <strong>Mute Toggle:</strong> Quickly mute or unmute all game sounds with a single click.</p>
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• <strong>Sound Effects:</strong> The game includes various sound effects for merging blocks, collecting gold, using power-ups, and more.</p>
            <p style="margin: 0 0 12px 0; font-size: 16px; line-height: 1.5;">• Access the sound controls by clicking the speaker icon in the top bar.</p>
          </div>
        </div>


      </div>



      <div class="actions" style="justify-content: flex-start;">
        <button id="resetDataBtn" class="ai-btn" style="background-color: #dc2626; color: white;" title="Clear all game data and cookies">Clear All Data</button>
      </div>
    </div>
  </div>

  <!-- Player Statistics Modal (hidden by default) -->
  <div id="statsModal" class="modal-backdrop stats-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="statsTitle">
    <div class="modal stats-modal">
      <h2 id="statsTitle">Player Statistics</h2>
      
      <div class="stats-content">
        <div class="stat-line">
          <span class="stat-label">🏆 All Time High Score:</span>
          <span class="stat-value" id="statsHighScore">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">💰 Lifetime Gold Earned:</span>
          <span class="stat-value" id="statsLifetimeGold">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">📦 Total Blocks Dropped:</span>
          <span class="stat-value" id="statsTotalBlocksDropped">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">💣 Total Bombs Exploded:</span>
          <span class="stat-value" id="statsTotalBombsExploded">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">🗑️ Total Blocks Trashed:</span>
          <span class="stat-value" id="statsTotalBlocksTrashed">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">⛏️ Total Blocks Mined:</span>
          <span class="stat-value" id="statsTotalBlocksMined">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">🔄 Total Swaps Used:</span>
          <span class="stat-value" id="statsTotalSwapsUsed">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">🛒 Lifetime Items Purchased:</span>
          <span class="stat-value" id="statsLifetimeItemsPurchased">0</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Welcome modal for first-time users (hidden by default) -->
  <div id="welcomeModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="welcomeTitle">
    <div class="modal welcome-modal">
      <h2 id="welcomeTitle">Stack Merge</h2>
      <div class="welcome-content">
        <h3>Would you like to read the How to Play guide?</h3>
      </div>
      <div class="welcome-actions">
        <button id="welcomeYesBtn" class="welcome-btn welcome-yes-btn">Yes</button>
        <button id="welcomeSkipBtn" class="welcome-btn welcome-skip-btn">Skip</button>
      </div>
    </div>
  </div>

  <!-- Shop modal (hidden by default) -->
  <div id="shopModal" class="modal-backdrop shop-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="shopTitle">
    <div class="modal shop-modal">
      <button id="shopClose" class="shop-modal-close-btn" title="Close shop">❌ Close</button>
      <div class="shop-modal-header">
        <h2 id="shopTitle">
          <span class="title-text">🛒 Shop</span>
        </h2>
        <div class="shop-gold-display">
          <div class="shop-gold-value" id="shopGoldDisplay">
            <div class="shop-gold-emoji">💰</div>
            <div class="shop-gold-text">0</div>
          </div>
        </div>
      </div>
      
      <div class="shop-separator"></div>
      
      <div class="shop-items-grid">
        <div class="shop-item-group">
          <div class="shop-item-container">
            <button class="powerup-btn" id="shopTrashPowerupBtn" title="Trash Can Powerup">
              <span class="powerup-emoji">🗑️</span>
              <span class="powerup-ownership-badge" id="shopTrashOwnershipBadge">0</span>
            </button>
            <button class="shop-item-btn" id="shopTrashBtn" title="Purchase Trash Can">
              <div class="shop-item-cost">
                <span class="cost-emoji">💰</span>
                <span class="cost-amount" id="shopTrashCost">25</span>
              </div>
            </button>
          </div>
        </div>
        
        <div class="shop-item-group">
          <div class="shop-item-container">
            <button class="powerup-btn" id="shopSwapPowerupBtn" title="Swap Powerup">
              <span class="powerup-emoji">🔄</span>
              <span class="powerup-ownership-badge" id="shopSwapOwnershipBadge">0</span>
            </button>
            <button class="shop-item-btn" id="shopSwapBtn" title="Purchase Swap">
              <div class="shop-item-cost">
                <span class="cost-emoji">💰</span>
                <span class="cost-amount" id="shopSwapCost">50</span>
                </div>
            </button>
          </div>
        </div>
        
        <div class="shop-item-group">
          <div class="shop-item-container">
            <button class="powerup-btn" id="shopBombPowerupBtn" title="Bomb Powerup">
              <span class="powerup-emoji">💣</span>
              <span class="powerup-ownership-badge" id="shopBombOwnershipBadge">0</span>
            </button>
            <button class="shop-item-btn" id="shopBombBtn" title="Purchase Bomb">
              <div class="shop-item-cost">
                <span class="cost-emoji">💰</span>
                <span class="cost-amount" id="shopBombCost">100</span>
              </div>
            </button>
          </div>
        </div>
        
        <div class="shop-item-group">
          <div class="shop-item-container">
            <button class="powerup-btn" id="shopPickaxePowerupBtn" title="Pickaxe Powerup">
              <span class="powerup-emoji">⛏️</span>
              <span class="powerup-ownership-badge" id="shopPickaxeOwnershipBadge">0</span>
            </button>
            <button class="shop-item-btn" id="shopPickaxeBtn" title="Purchase Pickaxe">
              <div class="shop-item-cost">
                <span class="cost-emoji">💰</span>
                <span class="cost-amount" id="shopPickaxeCost">1000</span>
              </div>
            </button>
          </div>
        </div>
      </div>
      
      <div class="shop-footer">
        <div class="shop-tooltip">
          Tap on each item for a description.
        </div>
        <div class="shop-tooltip">
          Press the button below the item to purchase.
        </div>
      </div>
    </div>
  </div>

  <!-- Powerup tooltip modal (hidden by default) -->
  <div id="powerupTooltipModal" class="powerup-tooltip-backdrop hidden" role="dialog" aria-modal="true">
    <div class="powerup-tooltip">
      <button id="powerupTooltipClose" class="powerup-tooltip-close" title="Close tooltip">×</button>
      <span id="powerupTooltipEmoji" class="powerup-tooltip-emoji">💣</span>
      <div id="powerupTooltipTitle" class="powerup-tooltip-title">Bomb</div>
      <div id="powerupTooltipDescription" class="powerup-tooltip-description">
        Explodes and removes all blocks in the selected stack.
      </div>
      <div id="powerupTooltipUsage" class="powerup-tooltip-usage">
        Click on a stack to detonate the bomb and clear all blocks.
      </div>
    </div>
  </div>

  <!-- Debug pane (hidden by default) -->
  <div id="debugPane" class="debug-pane">
    <button class="close-btn" id="debugClose" title="Close debug pane">×</button>
    <h3>Debug Controls</h3>
    

    
    <div class="section">
      <div class="section-title">Probability Curve</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugDecaySlider">Decay Factor:</label>
          <input type="range" id="debugDecaySlider" min="0.1" max="0.9" value="0.7" step="0.05">
          <div class="value-display" id="debugDecayLabel">0.70</div>
        </div>
        <div class="control-row">
          <button id="debugUpdateProbBtn" class="button">Update Probabilities</button>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Theme Settings</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugThemeSelector">Theme:</label>
                      <select id="debugThemeSelector" class="theme-selector"><option value="jellyfish">Jellyfish</option><option value="alternate">Earth</option></select>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Sound Settings</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugVolumeSlider">Volume:</label>
          <input type="range" id="debugVolumeSlider" min="0" max="100" value="30" step="5">
          <div class="value-display" id="debugVolumeLabel">30%</div>
        </div>
        <div class="control-row">
          <label for="debugMuteToggle">Mute:</label>
          <input type="checkbox" id="debugMuteToggle">
          <div class="value-display" id="debugMuteStatus">No</div>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Custom Block Dropper</div>
      <div class="controls">
        <div class="control-row">
          <label for="bombToggle">Bomb:</label>
          <input type="checkbox" id="bombToggle">
          <div class="value-display" id="bombStatus">No</div>
        </div>
        <div class="block-grid">
          <div class="block-item no-block selected" data-value="none">No Block</div>
          <div class="block-item" data-value="1" style="background: rgb(207, 239, 8); color: rgb(0, 0, 0);">1</div>
          <div class="block-item" data-value="2" style="background: rgb(16, 185, 129); color: rgb(255, 255, 255);">2</div>
          <div class="block-item" data-value="4" style="background: rgb(37, 99, 235); color: rgb(255, 255, 255);">4</div>
          <div class="block-item" data-value="8" style="background: rgb(124, 58, 237); color: rgb(255, 255, 255);">8</div>
          <div class="block-item" data-value="16" style="background: rgb(88, 28, 135); color: rgb(255, 255, 255);">16</div>
          <div class="block-item" data-value="32" style="background: rgb(217, 70, 239); color: rgb(255, 255, 255);">32</div>
          <div class="block-item" data-value="64" style="background: rgb(236, 72, 153); color: rgb(255, 255, 255);">64</div>
          <div class="block-item" data-value="128" style="background: rgb(232, 103, 88); color: rgb(255, 255, 255);">128</div>
          <div class="block-item" data-value="256" style="background: rgb(245, 158, 11); color: rgb(255, 255, 255);">256</div>
          <div class="block-item" data-value="512" style="background: rgb(234, 88, 12); color: rgb(255, 255, 255);">512</div>
          <div class="block-item" data-value="1024" style="background: rgb(220, 38, 38); color: rgb(255, 255, 255);">1024</div>
          <div class="block-item" data-value="2048" style="background: rgb(157, 23, 77); color: rgb(255, 255, 255);">2048</div>
          <div class="block-item" data-value="4096" style="background: rgb(124, 45, 109); color: rgb(255, 255, 255);">4096</div>
          <div class="block-item" data-value="8192" style="background: rgb(100, 116, 139); color: rgb(255, 255, 255);">8192</div>
          <div class="block-item" data-value="16384" style="background: rgb(255, 255, 255); color: rgb(0, 0, 0);">16.4k</div>
        </div>
        <div class="selected-block-info">
          <button id="cascadeTestBtn" class="button primary">Cascade Test</button>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Powerup Pricing</div>
      <div class="controls">
        <div class="control-row">
          <button id="debugPowerupPricingBtn" class="button">Set Powerup Costs to 999k</button>
        </div>
        <div class="control-row">
          <button id="debugResetPowerupPricingBtn" class="button">Reset Powerup Costs</button>
        </div>

      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Game State</div>
      <div class="controls">
        <table class="debug-stats-table">
          <tbody><tr><td>Score:</td><td id="debugScore">2</td></tr>
          <tr><td>Gold:</td><td id="debugGold">0</td></tr>
          <tr><td>Stacks:</td><td id="debugStacks">4</td></tr>
          <tr><td>Capacity:</td><td id="debugCapacity">10</td></tr>
          <tr><td>Target:</td><td id="debugTarget">1024</td></tr>
          <tr><td>Max Block:</td><td id="debugMaxBlock">2</td></tr>
          <tr><td>Blocks Dropped:</td><td id="debugBlocksDropped">2</td></tr>
                      <tr><td>Total Blocks Dropped:</td><td id="debugTotalBlocksDropped">817</td></tr>
            <tr><td>Total Bombs Exploded:</td><td id="debugTotalBombsExploded">40</td></tr>
            <tr><td>Total Blocks Trashed:</td><td id="debugTotalBlocksTrashed">14</td></tr>
            <tr><td>Total Blocks Mined:</td><td id="debugTotalBlocksMined">0</td></tr>
            <tr><td>Total Swaps Used:</td><td id="debugTotalSwapsUsed">0</td></tr>
            <tr><td>Lifetime Items Purchased:</td><td id="debugLifetimeItemsPurchased">0</td></tr>
            <tr><td>Bomb Status:</td><td id="debugBombStatus">Disabled</td></tr>
          <tr><td>Stage:</td><td id="debugStage">1</td></tr>
        </tbody></table>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Current Probabilities</div>
      <div class="controls">
        <div id="debugProbabilities" style="font-size: 12px; font-family: monospace; max-height: 200px; overflow-y: auto; background: var(--bg); padding: 8px; border-radius: 4px; border: 1px solid #475569;"><div style="margin-bottom: 8px;"><strong>Block | Probability | Cumulative</strong></div><div style="margin: 2px 0; padding: 2px 4px; background: rgba(255,255,255,0.05); border-radius: 2px; border: 2px solid #10B981;">
      <span style="color: #10B981; font-weight: 600;">1</span> | 
      <span style="color: #10B981;">50.00%</span> | 
      <span style="color: #F59E0B;">50.00%</span>
       <span style="color: #10B981; font-size: 10px;">(Foundation)</span>
    </div><div style="margin: 2px 0; padding: 2px 4px; background: transparent; border-radius: 2px; border: 2px solid #10B981;">
      <span style="color: #10B981; font-weight: 600;">2</span> | 
      <span style="color: #10B981;">50.00%</span> | 
      <span style="color: #F59E0B;">100.00%</span>
       <span style="color: #10B981; font-size: 10px;">(Foundation)</span>
    </div></div>
        <div class="control-row" style="margin-top: 12px;">
          <button id="testProbBtn" class="button">Test Probabilities</button>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Test Features</div>
      <div class="controls">
        <div class="control-row">
          <button id="testPersonalBestBtn" class="button primary">Test Personal Best Message</button>
        </div>
        <div class="control-row">
          <button id="testGameOverBtn" class="button primary">Test Game Over Screen (with Personal Best)</button>
        <button id="testUnlockThemeBtn" class="button primary">Test Theme Unlock</button>
        <button id="testLockThemeBtn" class="button primary">Test Theme Lock</button>
        </div>
      </div>
    </div>
    
    <div class="section bottom-buttons">
      <div class="controls">
        <div class="button-row">
          <button id="grantScoreBtn" class="button primary">Grant 1 Score</button>
          <button id="grantGoldBtn" class="button primary">Grant 1 Gold</button>
        </div>
      </div>
    </div>
  </div>

<script>
// Focus Prevention - Remove focus from buttons immediately when they get focused
document.addEventListener('DOMContentLoaded', function() {
  // Remove focus from powerup buttons immediately when they get focused
  const powerupButtons = document.querySelectorAll('.powerup-btn');
  powerupButtons.forEach(button => {
    button.addEventListener('focus', function() {
      this.blur();
    });
    button.addEventListener('focusin', function() {
      this.blur();
    });
  });
  
  // Remove focus from modal close buttons
  const modalCloseButtons = document.querySelectorAll('.help-modal-close-btn, .shop-modal-close-btn');
  modalCloseButtons.forEach(button => {
    button.addEventListener('focus', function() {
      this.blur();
    });
    button.addEventListener('focusin', function() {
      this.blur();
    });
  });
  
  // Remove focus from new game modal buttons
  const newGameButtons = document.querySelectorAll('.new-game-btn, .confirm-new-game-btn, .cancel-new-game-btn');
  newGameButtons.forEach(button => {
    button.addEventListener('focus', function() {
      this.blur();
    });
    button.addEventListener('focusin', function() {
      this.blur();
    });
  });
});

// Environment Detection
const isLocalhost = (() => {
  const hostname = window.location.hostname;
  const protocol = window.location.protocol;
  const port = window.location.port;
  
  // Check for localhost variations
  const localhostPatterns = [
    'localhost',
    '127.0.0.1',
    '::1',
    '0.0.0.0'
  ];
  
  // Check for common development ports
  const devPorts = ['3000', '8000', '8080', '5000', '5173', '4173', '3001'];
  
  // Check for file protocol (local file)
  const isFileProtocol = protocol === 'file:';
  
  // Check if it's localhost or development environment
  const isLocal = localhostPatterns.includes(hostname) || 
                  devPorts.includes(port) || 
                  isFileProtocol ||
                  hostname.includes('.local') ||
                  hostname.includes('.test');
  
  // Environment detection complete
  
  // Add environment indicator to page title in development
  if (isLocal) {
    document.title = `[DEV] ${document.title}`;
    
    // Enable scrolling in development mode for debug access
    document.body.classList.add('development-mode');
  }
  
  return isLocal;
})();

// Utility functions for environment detection
const isDevelopment = () => isLocalhost;
const isProduction = () => !isLocalhost;
const getEnvironment = () => isLocalhost ? 'development' : 'production';

// Sound Manager for Stack Merge Game - Web Audio API Implementation
class SoundManager {
  constructor() {
    this.isMuted = false;
    // Always use cork sounds for merges
    this.volume = 0.3; // Default volume (30%)
    this.initialized = false; // Will be set to true after Web Audio API initialization
    
    // Individual sound type volumes (0-5 scale, converted to 0.0-1.0 internally)
    this.soundVolumes = {
      drop: 3,      // Drop sounds
      merge: 3,     // Merge sounds
      coin: 3,      // Gold coin sounds
      bomb: 3,      // Bomb explosion sounds
      other: 2      // Other sounds (stage progression, etc.)
    };
    
    // Web Audio API components
    this.audioContext = null;
    this.audioBuffers = {};
    this.audioUnlocked = false;
    
    // Track initialization state and queue first sound
    this.initializationPromise = null;
    this.pendingFirstSound = null;
    
    // Debug localStorage to check for corrupted settings
    this.debugLocalStorage();
    
    // Initialize Web Audio API system
    this.initializeWebAudioSystem();
    
    // Pre-initialize audio system to be ready for first interaction
    this.preInitializeAudio();
  }
  

  

  
  // Initialize Web Audio API system
  async initializeWebAudioSystem() {
    try {
      
      // Create audio context
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Define all sound files that need to be loaded
      this.audioFiles = {
        drop: 'sounds/click2.wav',
        bomb: 'sounds/bomb.mp3',
        stageProgression: 'sounds/stageprogression.mp3',
        newGame: 'sounds/newgame.mp3',
        gameOver: 'sounds/gameover.mp3',
        purchase: 'sounds/purchase2.mp3',
        personalBest: 'sounds/newrecord.mp3',
        themeUnlock: 'sounds/themeunlock.mp3',
        itemUnlock: 'sounds/itemunlock.mp3',
        trash: 'sounds/trash.mp3',
        bombStart: 'sounds/bombstart.mp3',
        bombClose: 'sounds/bombclose.mp3',
        bombLight: 'sounds/bomblight.mp3',
        break: 'sounds/break.mp3',
        switch: 'sounds/switch.mp3'
      };
      
      // Cork sounds for merges
      for (let i = 0; i <= 9; i++) {
        this.audioFiles[`cork${i}`] = `sounds/cork${i}.wav`;
      }
      
      // Coin sounds
      for (let i = 1; i <= 7; i++) {
        this.audioFiles[`coin${i}`] = `sounds/coin${i}.wav`;
      }
      

      
      // Start loading audio buffers in background
      this.preloadAudioBuffers();
      
    } catch (error) {
      this.audioFiles = {};
    }
  }

  // Preload all audio files as buffers
  async preloadAudioBuffers() {
    const loadPromises = [];
    
    for (const [soundKey, filePath] of Object.entries(this.audioFiles)) {
      loadPromises.push(this.loadAudioBuffer(soundKey, filePath));
    }
    
    try {
      await Promise.all(loadPromises);
      this.initialized = true;
      
      // If there's a pending first sound, play it now
      if (this.pendingFirstSound) {
        const { method, args } = this.pendingFirstSound;
        this.pendingFirstSound = null;
        // Small delay to ensure everything is ready
        setTimeout(() => {
          this[method](...args);
        }, 50);
      }
    } catch (error) {
      this.initialized = true; // Still mark as initialized to allow the game to continue
    }
  }

  // Load individual audio buffer
  async loadAudioBuffer(soundKey, filePath) {
    try {
      const response = await fetch(filePath);
      if (!response.ok) throw new Error(`Failed to fetch ${filePath}`);
      
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
      
      this.audioBuffers[soundKey] = audioBuffer;
      
    } catch (error) {
      // Silent error handling
    }
  }

  // Universal audio unlock method using Web Audio API (works on all devices including iOS)
  async unlockAudio() {
    if (this.audioUnlocked) {
      return Promise.resolve();
    }

    try {
      // Initialize Web Audio if not already done
      if (!this.audioContext) {
        await this.initializeWebAudioSystem();
      }
      
      // Wait for audio buffers to be loaded if not already done
      if (!this.initialized) {
        // Wait for initialization to complete
        while (!this.initialized) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      
      // Resume audio context if suspended
      if (this.audioContext && this.audioContext.state === 'suspended') {
        let attempt = 1;
        
        while (this.audioContext.state === 'suspended' && attempt <= 1000) {
          try {
            const resumePromise = this.audioContext.resume();
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Timeout')), 1);
            });
            
            await Promise.race([resumePromise, timeoutPromise]);
            
            if (this.audioContext.state === 'running') break;
          } catch (error) {
            // Silent continue
          }
          
          attempt++;
        }
      }
      
      this.audioUnlocked = true;
      return Promise.resolve();
      
    } catch (error) {
      this.audioUnlocked = true; // Mark as unlocked anyway to prevent infinite retry
      return Promise.resolve();
    }
  }

  // Debug popup helper for iOS testing (disabled for normal gameplay)
  showDebugPopup(message) {
    // Silent debug helper
  }

  // Helper method to safely play audio with proper promise handling
  safePlayAudio(audio) {
    const playPromise = audio.play();
    if (playPromise) {
      return playPromise.then(() => {
        // Audio played successfully
      }).catch((error) => {
        throw error;
      });
    }
    // Return resolved promise for older browsers
    return Promise.resolve();
  }
  
  // Ensure audio system is ready before playing any sounds
  async ensureAudioReady() {
    if (!this.initialized) {
      // Wait for initialization to complete
      while (!this.initialized) {
        await new Promise(resolve => setTimeout(resolve, 10));
      }
    }
    
    if (!this.audioUnlocked) {
      await this.unlockAudio();
    }
    
    return this.canPlayAudio();
  }
  
  // Pre-initialize audio system to be ready for first interaction
  async preInitializeAudio() {
    // Wait for initialization to complete
    if (!this.initialized) {
      await new Promise(resolve => {
        const checkReady = () => {
          if (this.initialized) {
            resolve();
          } else {
            setTimeout(checkReady, 10);
          }
        };
        checkReady();
      });
    }
    
    // Then unlock audio
    if (!this.audioUnlocked) {
      await this.unlockAudio();
    }
  }

  // Check if audio can be played on this device
  canPlayAudio() {
    return this.initialized && !this.isMuted && this.audioUnlocked;
  }
  
  // Queue the first sound if audio system isn't ready yet
  queueFirstSound(method, ...args) {
    if (!this.pendingFirstSound) {
      this.pendingFirstSound = { method, args };
    }
  }
  
  // Debug localStorage to check for corrupted settings
  debugLocalStorage() {
    try {
      // Check if localStorage is available
      if (typeof localStorage !== 'undefined') {
        
        // Check for corrupted sound settings
        const soundSettings = localStorage.getItem('stackMerge_soundSettings');
        if (soundSettings) {
          try {
            const parsed = JSON.parse(soundSettings);
            
            // Check for suspicious values
            if (parsed.isMuted === true) {
              // Sound is muted
            }
            if (parsed.volume === 0) {
              // Master volume is 0
            }
            if (parsed.soundVolumes) {
              Object.entries(parsed.soundVolumes).forEach(([type, vol]) => {
                if (vol === 0) {
                  // Volume is 0
                }
              });
            }
          } catch (parseError) {
            // Clear corrupted data
            localStorage.removeItem('stackMerge_soundSettings');
          }
        } else {
          // No sound settings found
        }
      } else {
        // localStorage not available
      }
    } catch (error) {
      // Silent error handling
    }
  }
  
  // Simple, reliable audio system that works on all devices
  // Play sound using Web Audio API
  async playWebAudio(soundKey, volumeType = 'other') {
    if (!this.audioContext || !this.audioBuffers[soundKey]) {
      return false;
    }
    
    try {
      // Resume audio context if suspended
      if (this.audioContext.state === 'suspended') {
        await this.audioContext.resume();
        if (this.audioContext.state === 'suspended') return false;
      }
      
      if (this.audioContext.state !== 'running') return false;
      
      // Create audio nodes
      const source = this.audioContext.createBufferSource();
      const gainNode = this.audioContext.createGain();
      
      // Set up audio graph
      source.buffer = this.audioBuffers[soundKey];
      source.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      // Set volume based on type and settings
      const volume = this.getActualVolume(volumeType);
      gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
      
      // Play the sound
      source.start(0);
      
      return true;
    } catch (error) {
      return false;
    }
  }
  
  // Enhanced method to play any sound with Web Audio API fallback
  async playSound(soundKey, volumeType = 'other') {
    if (!this.canPlayAudio()) {
      // If audio system isn't ready yet, queue this sound as the first sound
      if (!this.initialized) {
        this.queueFirstSound('playSound', soundKey, volumeType);
        return Promise.resolve('Sound queued for later playback');
      }
      return Promise.reject('Audio not available');
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      await this.unlockAudio();
    }
    
    // Try Web Audio API first
    const webAudioSuccess = await this.playWebAudio(soundKey, volumeType);
    if (webAudioSuccess) {
      return Promise.resolve();
    }
    
    // Fallback to traditional Audio element for compatibility
    if (this.audioFiles && this.audioFiles[soundKey]) {
      try {
        const audio = new Audio(this.audioFiles[soundKey]);
        audio.volume = this.getActualVolume(volumeType);
        return this.safePlayAudio(audio);
      } catch (error) {
        return Promise.reject(`Fallback audio failed: ${error.message}`);
      }
    }
    
    return Promise.reject(`Sound ${soundKey} not found`);
  }
  

  
  // Play the drop sound effect - simple and reliable
  playDropSound(blockValue = 1) {
    if (!this.canPlayAudio()) {
      // If audio system isn't ready yet, queue this sound as the first sound
      if (!this.initialized) {
        this.queueFirstSound('playDropSound', blockValue);
        return;
      }
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playDropSound(blockValue));
      return;
    }
    
    // Use the simple playSound method
    this.playSound('drop', 'drop').catch(error => {
      // Silent error handling
    });
  }
  
  // Enhanced drop sound that ensures audio system is ready
  async playDropSoundEnhanced(blockValue = 1) {
    try {
      // Ensure audio system is ready
      await this.ensureAudioReady();
      
      // Now play the sound
      await this.playSound('drop', 'drop');
    } catch (error) {
      // Silent error handling
    }
  }
  
  // Generate a peaceful, raindrop-like merge sound effect with cascade progression
  playMergeSound(blockValue = 1) {
    if (!this.canPlayAudio()) {
      // If audio system isn't ready yet, queue this sound as the first sound
      if (!this.initialized) {
        this.queueFirstSound('playMergeSound', blockValue);
        return;
      }
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playMergeSound(blockValue));
      return;
    }
    
    try {
      // Get the current merge count for cascade sounds
      const mergeCount = this.getCurrentMergeCount();
      
      // Determine which cork sound to play based on cascade position
      let corkSoundKey;
      if (mergeCount <= 1) {
        corkSoundKey = 'cork0'; // First merge
      } else if (mergeCount <= 10) {
        corkSoundKey = `cork${mergeCount - 1}`; // cork1 through cork9
      } else {
        corkSoundKey = 'cork9'; // Any remaining merges use cork9
      }
      
      // Use simple playSound method
      this.playSound(corkSoundKey, 'merge').catch(error => {
        // Silent error handling
      });
    } catch (error) {
      // Silent fail - no console spam
    }
  }
  
  // Enhanced merge sound that ensures audio system is ready
  async playMergeSoundEnhanced(blockValue = 1) {
    try {
      // Ensure audio system is ready
      await this.ensureAudioReady();
      
      // Get the current merge count for cascade sounds
      const mergeCount = this.getCurrentMergeCount();
      
      // Determine which cork sound to play based on cascade position
      let corkSoundKey;
      if (mergeCount <= 1) {
        corkSoundKey = 'cork0'; // First merge
      } else if (mergeCount <= 10) {
        corkSoundKey = `cork${mergeCount - 1}`; // cork1 through cork9
      } else {
        corkSoundKey = 'cork9'; // Any remaining merges use cork9
      }
      
      // Use simple playSound method
      await this.playSound(corkSoundKey, 'merge');
    } catch (error) {
      // Silent error handling
    }
  }
  

  

  


  // Set master volume (0.0 to 1.0)
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(1, volume));
    this.saveSoundSettings();
  }
  
  // Toggle mute state
  toggleMute() {
    this.isMuted = !this.isMuted;
    this.saveSoundSettings();
    return this.isMuted;
  }
  
  // Get current mute state
  getMuteState() {
    return this.isMuted;
  }
  
  // Get current volume
  getVolume() {
    return this.volume;
  }
  

  
  // Get current merge sound type preference (always cork sounds now)
  getMergeSoundType() {
    return true; // Always return true for cork sounds
  }
  
  // Set individual sound type volume (0-5 scale)
  setSoundVolume(soundType, volume) {
    if (this.soundVolumes.hasOwnProperty(soundType)) {
      const oldVolume = this.soundVolumes[soundType];
      this.soundVolumes[soundType] = Math.max(0, Math.min(5, Math.round(volume)));
      this.saveSoundSettings();
    }
  }
  
  // Get individual sound type volume (0-5 scale)
  getSoundVolume(soundType) {
    // Check if the sound type exists and has a value (including 0)
    if (this.soundVolumes.hasOwnProperty(soundType)) {
      return this.soundVolumes[soundType];
    }
    // Only return default 3 if the sound type doesn't exist at all
    return 3;
  }
  
  // Get all sound volumes
  getAllSoundVolumes() {
    return { ...this.soundVolumes };
  }
  
  // Set all sound volumes at once
  setAllSoundVolumes(volumes) {
    Object.keys(volumes).forEach(soundType => {
      if (this.soundVolumes.hasOwnProperty(soundType)) {
        const oldVolume = this.soundVolumes[soundType];
        const newVolume = Math.max(0, Math.min(5, Math.round(volumes[soundType])));
        this.soundVolumes[soundType] = newVolume;
      }
    });
  }
  
  // Convert volume scale (0-5) to actual volume (0.0-2.0 for drop/merge, 0.0-1.0 for others)
  getActualVolume(soundType) {
    // If the sound type has a specific volume, use it
    if (this.soundVolumes.hasOwnProperty(soundType)) {
      const volume = this.soundVolumes[soundType];
      let actualVolume;
      
      if (soundType === 'merge') {
        // Enhanced volume scaling for merge sounds: 0 = mute, 1 = quiet, 5 = very loud
        // This gives merge sounds much more presence while keeping the same user control
        // Map 0-5 to 0-1 with a curve that emphasizes higher volumes
        actualVolume = volume === 0 ? 0 : Math.pow(volume / 5, 0.7); // Curved mapping for more presence
      } else {
        // Standard 5-level scaling for all other sounds (drop, coin, bomb, other): 0 = mute, 1 = very quiet, 5 = loud
        // Map 0-5 to 0-1 linearly
        actualVolume = volume === 0 ? 0 : volume / 5;
      }
      
      return actualVolume;
    }
    
    // If no specific volume is set, fall back to "Other" volume
    const fallbackVolume = this.soundVolumes.other || 3;
    let fallbackActual;
    
    fallbackActual = fallbackVolume === 0 ? 0 : fallbackVolume / 5;
    
    return fallbackActual;
  }
  
  // Save sound settings to localStorage
  saveSoundSettings() {
    try {
      const settings = {
        isMuted: this.isMuted,
        volume: this.volume,
        soundVolumes: this.soundVolumes,
        timestamp: Date.now()
      };
      localStorage.setItem('stackMerge_soundSettings', JSON.stringify(settings));
    } catch (error) {
      // Silent error handling
    }
  }
  
  // Load sound settings from localStorage
  loadSoundSettings() {
    try {
      const saved = localStorage.getItem('stackMerge_soundSettings');
      if (saved) {
        const settings = JSON.parse(saved);
        
        // Load settings with validation
        if (typeof settings.isMuted === 'boolean') this.isMuted = settings.isMuted;
        if (typeof settings.volume === 'number') this.volume = Math.max(0, Math.min(1, settings.volume));

        
        // Load individual sound volumes
        if (settings.soundVolumes && typeof settings.soundVolumes === 'object') {
          Object.keys(settings.soundVolumes).forEach(soundType => {
            if (this.soundVolumes.hasOwnProperty(soundType)) {
              const vol = settings.soundVolumes[soundType];
              if (typeof vol === 'number' && vol >= 0 && vol <= 5) {
                this.soundVolumes[soundType] = Math.round(vol);
              }
            }
          });
        }
        
        return true;
      }
    } catch (error) {
      // If loading fails, reset to defaults and clear corrupted data
      this.resetAudioSettings();
    }
    return false;
  }
  
  // Reset audio settings to defaults (useful for fixing corrupted settings)
  resetAudioSettings() {
    // Reset to default values
    this.isMuted = false;
    this.volume = 0.3;

    this.soundVolumes = {
      drop: 3,
      merge: 3,
      coin: 3,
      bomb: 3,
      other: 3
    };
    
    // Clear corrupted localStorage data
    try {
      localStorage.removeItem('stackMerge_soundSettings');
    } catch (error) {
      // Silent error handling
    }
    
    // Save fresh default settings
    this.saveSoundSettings();
  }
  

  
  // Play a random coin sound effect when gold is earned
  playCoinSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playCoinSound());
      return;
    }
    
    try {
      // Randomly select one of the 7 coin sounds
      const coinNumber = Math.floor(Math.random() * 7) + 1;
      const coinKey = `coin${coinNumber}`;
      
      // Use the simple playSound method
      this.playSound(coinKey, 'coin').catch(error => {
        // Silent error handling
      });
    } catch (error) {
      // Silent error handling
    }
  }
  

  

  


  // Load and play the new game sound effect
  playNewGameSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playNewGameSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('newGame', 'other').catch(error => {
      // Silent error handling
    });
  }

  // Load and play the stage progression sound effect
  playStageProgressionSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playStageProgressionSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('stageProgression', 'other').catch(error => {
      // Silent error handling
    });
  }

  // Load and play the game over sound effect
  playGameOverSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playGameOverSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('gameOver', 'other').catch(error => {
      // Silent error handling
    });
  }

  // Load and play the bomb explosion sound effect
  playBombSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playBombSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('bomb', 'bomb').catch(error => {
      // Silent error handling
    });
  }







  // Play purchase sound effect
  playPurchaseSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playPurchaseSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('purchase', 'coin').catch(error => {
      // Silent error handling
    });
  }

  // Play trash sound effect
  playTrashSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playTrashSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('trash', 'other').catch(error => {
      // Silent error handling
    });
  }

  // Play bomb start sound effect (when entering bomb placing state)
  playBombStartSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playBombStartSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('bombStart', 'bomb').catch(error => {
      // Silent error handling
    });
  }

  // Play bomb close sound effect (when canceling bomb placement)
  playBombCloseSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playBombCloseSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('bombClose', 'bomb').catch(error => {
      // Silent error handling
    });
  }

  // Play bomb light sound effect (when bomb is placed)
  playBombLightSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playBombLightSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('bombLight', 'bomb').catch(error => {
      // Silent error handling
    });
  }

  // Play break sound effect (when pickaxe is used to delete a block)
  playBreakSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playBreakSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('break', 'bomb').catch(error => {
      // Silent error handling
    });
  }

  // Play switch sound effect (when swap ability is used)
  playSwitchSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playSwitchSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('switch', 'other').catch(error => {
      // Silent error handling
    });
  }

  playItemUnlockSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playItemUnlockSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('itemUnlock', 'other').catch(error => {
      // Silent error handling
    });
  }

  // Merge count tracking for cascade effects - COMPLETELY SEPARATE FROM AUDIO
  getCurrentMergeCount() {
    return this._currentMergeCount || 0;
  }

  setCurrentMergeCount(count) {
    this._currentMergeCount = count;
  }

  // Debug function for coin sound status - COMPLETELY SEPARATE FROM AUDIO
  getCoinSoundStatus() {
    return {
      loaded: true,
      count: 1,
      expected: 1
    };
  }
  
  // Check if all sounds are preloaded and ready for playback
  areSoundsPreloaded() {
    if (!this.audioBuffers) return false;
    
    const requiredSounds = [
      'drop', 'cork0', 'cork1', 'cork2', 'cork3', 'cork4', 'cork5', 'cork6', 'cork7', 'cork8', 'cork9',
      'coin1', 'coin2', 'coin3', 'coin4', 'coin5', 'coin6', 'coin7',
      'bomb', 'stageProgression', 'newGame', 'gameOver', 'purchase'
    ];
    
    return requiredSounds.every(soundKey => 
      this.audioBuffers[soundKey] && this.audioBuffers[soundKey] instanceof AudioBuffer
    );
  }
  
  // Get preloading status for debugging
  getPreloadStatus() {
    if (!this.audioBuffers) return { status: 'not_initialized', loaded: 0, total: 0 };
    
    const requiredSounds = [
      'drop', 'cork0', 'cork1', 'cork2', 'cork3', 'cork4', 'cork5', 'cork6', 'cork7', 'cork8', 'cork9',
      'coin1', 'coin2', 'coin3', 'coin4', 'coin5', 'coin6', 'coin7',
      'bomb', 'stageProgression', 'newGame', 'gameOver', 'purchase'
    ];
    
    const loadedSounds = requiredSounds.filter(soundKey => 
      this.audioBuffers[soundKey] && this.audioBuffers[soundKey] instanceof AudioBuffer
    );
    
    return {
      status: loadedSounds.length === requiredSounds.length ? 'fully_loaded' : 'partially_loaded',
      loaded: loadedSounds.length,
      total: requiredSounds.length,
      bufferStatus: requiredSounds.reduce((acc, soundKey) => {
        if (this.audioBuffers[soundKey]) {
          acc[soundKey] = 'loaded';
        } else {
          acc[soundKey] = 'missing';
        }
        return acc;
      }, {})
    };
  }
  
  // Force reload all sounds (useful for troubleshooting)
  reloadAllSounds() {
    this.audioBuffers = {};
    this.initialized = false;
    this.initializeWebAudioSystem();
  }
  
  // Wait for all sounds to be ready (returns a promise)
  waitForSoundsReady() {
    return new Promise((resolve) => {
      if (this.areSoundsPreloaded()) {
        resolve();
        return;
      }
      
      // Check every 100ms until sounds are ready
      const checkInterval = setInterval(() => {
        if (this.areSoundsPreloaded()) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
      
      // Timeout after 10 seconds
      setTimeout(() => {
        clearInterval(checkInterval);
        resolve();
      }, 10000);
    });
  }
  
  // Get preloading progress as a percentage
  getPreloadProgress() {
    if (!this.audioBuffers) return 0;
    
    const requiredSounds = [
      'drop', 'cork0', 'cork1', 'cork2', 'cork3', 'cork4', 'cork5', 'cork6', 'cork7', 'cork8', 'cork9',
      'coin1', 'coin2', 'coin3', 'coin4', 'coin5', 'coin6', 'coin7',
      'bomb', 'stageProgression', 'newGame', 'gameOver', 'purchase'
    ];
    
    const loadedSounds = requiredSounds.filter(soundKey => 
      this.audioBuffers[soundKey] && this.audioBuffers[soundKey] instanceof AudioBuffer
    );
    
    return Math.round((loadedSounds.length / requiredSounds.length) * 100);
  }
  
  // Check if a specific sound buffer is ready for playback
  isSoundReady(soundKey) {
    return this.audioBuffers && 
           this.audioBuffers[soundKey] && 
           this.audioBuffers[soundKey] instanceof AudioBuffer;
  }
  
  // Get the number of sound buffers currently loaded
  getLoadedSoundCount() {
    if (!this.audioBuffers) return 0;
    
    const requiredSounds = [
      'drop', 'cork0', 'cork1', 'cork2', 'cork3', 'cork4', 'cork5', 'cork6', 'cork7', 'cork8', 'cork9',
      'coin1', 'coin2', 'coin3', 'coin4', 'coin5', 'coin6', 'coin7',
      'bomb', 'stageProgression', 'newGame', 'gameOver', 'purchase'
    ];
    
    return requiredSounds.filter(soundKey => this.isSoundReady(soundKey)).length;
  }
  
  // Get comprehensive sound system status
  getSoundSystemStatus() {
    return {
      initialized: this.initialized,
      muted: this.isMuted,
      masterVolume: this.volume,
      soundVolumes: this.soundVolumes,
      preloadProgress: this.getPreloadProgress(),
      loadedCount: this.getLoadedSoundCount(),
      totalSounds: 23, // Total number of required sounds
      ready: this.areSoundsPreloaded(),
      webAudioContext: this.audioContext ? this.audioContext.state : 'not initialized',
      audioUnlocked: this.audioUnlocked,
      buffersLoaded: Object.keys(this.audioBuffers || {}).length
    };
  }
}

// Theme Manager for Stack Merge Game
class ThemeManager {
  constructor() {
    this.currentTheme = 'jellyfish'; // Default theme
    this.availableThemes = ['jellyfish', 'alternate'];
    
    // Theme unlock requirements
    this.themeUnlockRequirements = {
      'jellyfish': { unlocked: true, requirement: 'Default theme' },
      'alternate': { unlocked: false, requirement: 'Score 5000+ points' },
      'miner': { unlocked: false, requirement: '?' }
    };
    
    // Load saved theme and unlock status from localStorage (but don't apply it yet)
    this.loadTheme();
    
          // Check if we need to force reset unlocks (from clear all data operation)
    try {
      const forceReset = localStorage.getItem('stackMerge_forceResetUnlocks');
      if (forceReset === 'true') {
        localStorage.removeItem('stackMerge_forceResetUnlocks');
        // Don't load unlock status, keep defaults
      } else {
        // Only load unlock status if not prevented by clear operation
        if (!window.preventThemeUnlockLoad) {
          this.loadUnlockStatus();
        } else {
          window.preventThemeUnlockLoad = false; // Reset the flag
        }
      }
    } catch (e) {
      // Fall back to normal loading
      if (!window.preventThemeUnlockLoad) {
        this.loadUnlockStatus();
      }
    }
    
    // Don't apply theme in constructor - will be applied after game initialization
  }
  
  // Get current theme
  getCurrentTheme() {
    return this.currentTheme;
  }
  
  // Get available themes
  getAvailableThemes() {
    return this.availableThemes;
  }
  
  // Apply a specific theme
  applyTheme(themeName) {
    if (!this.availableThemes.includes(themeName)) {
      themeName = 'jellyfish';
    }
    
    // Check if theme is unlocked
    if (!this.isThemeUnlocked(themeName)) {
      return false;
    }
    
    // Remove all theme classes from body
    document.body.classList.remove('theme-alternate');
    
    // Add the selected theme class
    if (themeName === 'alternate') {
      document.body.classList.add('theme-alternate');
    }
    
    this.currentTheme = themeName;
    
    // Save theme preference
    this.saveTheme();
    
    // Re-rendering game to apply new theme colors...
    if (typeof render === 'function') {
      render();
    }
    
      // Re-rendering next queue to apply new theme colors...
  if (typeof renderNext === 'function') {
    renderNext();
  }
  
  // Update debug custom dropper block colors
  updateDebugBlockColors();
  
  return true;
  }
  
  // Save theme to localStorage
  saveTheme() {
    try {
      localStorage.setItem('stackMerge_theme', this.currentTheme);
    } catch (error) {
      // Silent error handling
    }
  }
  
  // Load theme from localStorage
  loadTheme() {
    try {
      const savedTheme = localStorage.getItem('stackMerge_theme');
      if (savedTheme && this.availableThemes.includes(savedTheme)) {
        this.currentTheme = savedTheme;
      } else {
        this.currentTheme = 'jellyfish';
      }
    } catch (error) {
      this.currentTheme = 'jellyfish';
    }
  }
  
  // Initialize theme after game is ready
  initializeTheme() {
    this.applyTheme(this.currentTheme);
  }
  
  // Reset theme to default
  resetTheme() {
    this.applyTheme('jellyfish');
  }
  
  // Check if a theme is unlocked
  isThemeUnlocked(themeName) {
    return this.themeUnlockRequirements[themeName]?.unlocked || false;
  }
  
  // Get unlock requirement for a theme
  getThemeRequirement(themeName) {
    return this.themeUnlockRequirements[themeName]?.requirement || 'Unknown requirement';
  }
  
  // Unlock a theme
  unlockTheme(themeName) {
    if (this.themeUnlockRequirements[themeName]) {
      this.themeUnlockRequirements[themeName].unlocked = true;
      this.saveUnlockStatus();
      return true;
    }
    return false;
  }
  
  // Get all unlocked themes
  getUnlockedThemes() {
    return this.availableThemes.filter(theme => this.isThemeUnlocked(theme));
  }
  
  // Save unlock status to localStorage
  saveUnlockStatus() {
    try {
      const unlockData = {};
      for (const [theme, data] of Object.entries(this.themeUnlockRequirements)) {
        unlockData[theme] = { unlocked: data.unlocked, requirement: data.requirement };
      }
      localStorage.setItem('stackMerge_themeUnlocks', JSON.stringify(unlockData));
    } catch (error) {
      // Silent error handling
    }
  }
  
  // Load unlock status from localStorage
  loadUnlockStatus() {
    try {
      const unlockData = localStorage.getItem('stackMerge_themeUnlocks');
      if (unlockData) {
        const savedUnlocks = JSON.parse(unlockData);
        // Merge saved unlocks with current requirements
        for (const [theme, data] of Object.entries(savedUnlocks)) {
          if (this.themeUnlockRequirements[theme]) {
            this.themeUnlockRequirements[theme].unlocked = data.unlocked;
          }
        }
      }
    } catch (error) {
      // Silent error handling
    }
  }
}



// Function to update theme selectors with unlock status
function updateThemeSelectors() {
  const themeSelectors = ['themeSelector', 'debugThemeSelector'];
  
  themeSelectors.forEach(selectorId => {
    const selector = document.getElementById(selectorId);
    if (selector) {
      // Clear existing options
      selector.innerHTML = '';
      
      // Add themes with unlock status
      themeManager.availableThemes.forEach(theme => {
        const option = document.createElement('option');
        option.value = theme;
        
        if (themeManager.isThemeUnlocked(theme)) {
          if (theme === 'jellyfish') {
            option.textContent = 'Jellyfish';
          } else if (theme === 'alternate') {
            option.textContent = 'Earth';
          }
          option.disabled = false;
        } else {
          if (theme === 'jellyfish') {
            option.textContent = 'Jellyfish (🔒 Default theme)';
          } else if (theme === 'alternate') {
            option.textContent = `Earth (🔒 ${themeManager.getThemeRequirement(theme)})`;
          }
          option.disabled = true;
        }
        
        selector.appendChild(option);
      });
      
      // Set current theme
      selector.value = themeManager.getCurrentTheme();
    }
  });
}

// Function to update debug custom dropper block colors based on current theme
function updateDebugBlockColors() {
  const currentTheme = themeManager ? themeManager.getCurrentTheme() : 'jellyfish';
  
  // Update all block-item elements in the debug pane
  const debugBlocks = document.querySelectorAll('.debug-pane .block-item[data-value]');
  debugBlocks.forEach(block => {
    const value = block.getAttribute('data-value');
    
    // Skip the "no-block" option
    if (value === 'none') return;
    
    const numValue = parseInt(value);
    if (!isNaN(numValue)) {
      // Apply theme colors using the same functions as the game
      block.style.background = colorFor(numValue);
      block.style.color = getTextColorFor(numValue);
    }
  });
  
  // Also update the largest merge block in the game over screen if it exists
  const largestMergeBlock = document.getElementById('largestMergeBlock');
  if (largestMergeBlock && largestMergeBlock.hasAttribute('data-value')) {
    const value = largestMergeBlock.getAttribute('data-value');
    const numValue = parseInt(value);
    if (!isNaN(numValue)) {
      // Apply theme colors using the same functions as the game
      largestMergeBlock.style.background = colorFor(numValue);
      largestMergeBlock.style.color = getTextColorFor(numValue);
    }
  }
}

// Add debug logging for queue state
function logQueueState(action) {
  // Debug logging removed
}

// Function to validate and repair queue state
function validateQueueState() {
  if (!Array.isArray(nextQueue)) {
    console.error('Queue is not an array, rebuilding...');
    nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
    return false;
  }
  
  if (nextQueue.length !== 3) {
    console.error(`Queue has incorrect length ${nextQueue.length}, rebuilding...`);
    nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
    return false;
  }
  
  // Validate each element in the queue
  for (let i = 0; i < nextQueue.length; i++) {
    const item = nextQueue[i];
    if (!item || typeof item.w !== 'number' || item.w <= 0 || !isFinite(item.w)) {
      console.error(`Invalid item at index ${i}:`, item, 'replacing...');
      nextQueue[i] = getRandomPiece();
      return false;
    }
    
    if (typeof item.bomb !== 'boolean') {
      console.error(`Invalid bomb property at index ${i}:`, item.bomb, 'fixing...');
      item.bomb = false;
      return false;
    }
  }
  
  return true;
}

// Initialize sound manager
const soundManager = new SoundManager();

// Initialize theme manager
const themeManager = new ThemeManager();

// Load saved sound settings
soundManager.loadSoundSettings();

// Pre-initialize audio system to be ready for first interaction
soundManager.preInitializeAudio().catch(error => {
  // Silent error handling - audio will still work, just might have initial delay
});

// weights and probabilities - will be dynamically updated based on stage
let weights = [1, 2]; // Start with 1 and 2, unlock others as player progresses
let probabilities = [0.5, 0.5]; // Equal chance for 1 and 2 initially

// localStorage-based save system
const SAVE_KEY = 'stackMerge_save';

// First-time user detection system
let lastSeenUpdateTimestamp = 0; // Track when user first visited (used for first-time user detection)
let preventGameStateSave = false; // Flag to prevent saving game state after clearing data

// Help button state storage
const HELP_BUTTON_KEY = 'stackMerge_helpClicked';

// Save game state to localStorage
function saveGameState() {
  try {
    // Don't save if we're preventing saves after clear
    if (preventGameStateSave) {
      console.log('🚫 Prevented game state save due to clear operation');
      return;
    }
    
    const gameState = {
      poles: poles,
      score: score || 0,
      gold: gold || 0,
      goldEarnedThisGame: goldEarnedThisGame || 0,
      lifetimeGoldEarned: lifetimeGoldEarned || 0,
      blocksDropped: blocksDropped || 0,
      totalBlocksDropped: totalBlocksDropped || 0,
      totalBombsExploded: totalBombsExploded || 0,
      totalBlocksTrashed: totalBlocksTrashed || 0,
      totalBlocksMined: totalBlocksMined || 0,
      totalSwapsUsed: totalSwapsUsed || 0,
      lifetimeItemsPurchased: lifetimeItemsPurchased || 0,
      currentTargetBlockSize: currentTargetBlockSize || STARTING_BLOCK_SIZE,
      currentStage: currentStage || 1,
      weights: weights || [1, 2],
      probabilities: probabilities || [0.5, 0.5],
      nextQueue: nextQueue || [getRandomPiece(), getRandomPiece(), getRandomPiece()],
      bombConversionCost: bombConversionCost || 100,
      trashButtonCost: trashButtonCost || 25,
      pickaxeButtonCost: pickaxeButtonCost || 1000,
      swapButtonCost: swapButtonCost || 50,
      bombConversionPresses: bombConversionPresses || 0,
      trashButtonPresses: trashButtonPresses || 0,
      pickaxeButtonPresses: pickaxeButtonPresses || 0,
      swapButtonPresses: swapButtonPresses || 0,
      swapMode: swapMode || false,
      swapSelectedIndex: swapSelectedIndex || 0,
      bombSelected: bombSelected || false,
      previousBombCost: previousBombCost || bombConversionCost,
      pickaxeEnabled: window.pickaxeEnabled || true,
      pickaxeMode: pickaxeMode || false,
      bombOwned: bombOwned || 0,
      trashOwned: trashOwned || 0,
      pickaxeOwned: pickaxeOwned || 0,
      swapOwned: swapOwned || 0,
      bombEverPurchased: bombEverPurchased || false,
      trashEverPurchased: trashEverPurchased || false,
      pickaxeEverPurchased: pickaxeEverPurchased || false,
      swapEverPurchased: swapEverPurchased || false,
      
      // Save powerup discovery state
      bombDiscoveredThisGame: bombDiscoveredThisGame || false,
      trashDiscoveredThisGame: trashDiscoveredThisGame || false,
      pickaxeDiscoveredThisGame: pickaxeDiscoveredThisGame || false,
      swapDiscoveredThisGame: swapDiscoveredThisGame || false,


      soundVolumes: soundManager.getAllSoundVolumes(),
      isMuted: soundManager.getMuteState(),
      currentTheme: themeManager.getCurrentTheme(),
      themeUnlocks: themeManager.themeUnlockRequirements,
      currentActiveDecayFactor: currentActiveDecayFactor,
      lastSeenUpdateTimestamp: lastSeenUpdateTimestamp || 0, // Used for first-time user detection
      highScore: window.highScore || 0,
      totalGames: window.totalGames || 0,
      hasShownPersonalBest: hasShownPersonalBest || false,
      timestamp: Date.now()
    };
    
    const saveData = JSON.stringify(gameState);
    
    // Save to localStorage
    localStorage.setItem(SAVE_KEY, saveData);
  } catch (error) {
    // Silent error handling
  }
}

// Restore game state from loaded data
function restoreGameState(gameState) {
  try {
    
    // Validate the loaded data
    if (!gameState.poles || !Array.isArray(gameState.poles) || gameState.poles.length !== 4) {
      return false;
    }
    
    // Check if save is too old (more than 30 days)
    const saveAge = Date.now() - gameState.timestamp;
    const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 days in milliseconds
    if (saveAge > maxAge) {
      clearGameSave();
      return false;
    }
    
    // Restore game state
    const oldPoles = [...poles];
    const oldScore = score;
    const oldGold = gold;
    
    poles = gameState.poles;
    score = gameState.score || 0;
    gold = gameState.gold || 0;
    goldEarnedThisGame = gameState.goldEarnedThisGame || 0;
    lifetimeGoldEarned = gameState.lifetimeGoldEarned || 0;
    blocksDropped = gameState.blocksDropped || 0;
    totalBlocksDropped = gameState.totalBlocksDropped || 0;
    totalBombsExploded = gameState.totalBombsExploded || 0;
    totalBlocksTrashed = gameState.totalBlocksTrashed || 0;
    totalBlocksMined = gameState.totalBlocksMined || 0;
    totalSwapsUsed = gameState.totalSwapsUsed || 0;
    lifetimeItemsPurchased = gameState.lifetimeItemsPurchased || 0;
    
    // Restore high score from saved state
    window.highScore = gameState.highScore || 0;
    
    // Restore total games counter from saved state
    window.totalGames = gameState.totalGames || 0;
    
    // Restore personal best flag from saved state
    hasShownPersonalBest = gameState.hasShownPersonalBest || false;
    
        // Restore gold tracking variables (with fallbacks for old saves)
    goldEarnedThisGame = gameState.goldEarnedThisGame || 0;
    lifetimeGoldEarned = gameState.lifetimeGoldEarned || 0;
    
    // Update statistics modal if it's open
    if (statsModal && !statsModal.classList.contains('hidden')) {
      updateStatsModal();
    }
    
    currentTargetBlockSize = gameState.currentTargetBlockSize || STARTING_BLOCK_SIZE;
    currentStage = gameState.currentStage || 1;
    weights = gameState.weights || [1, 2];
    probabilities = gameState.probabilities || [0.5, 0.5];
    nextQueue = gameState.nextQueue || [getRandomPiece(), getRandomPiece(), getRandomPiece()];
    
    // Restore the current active decay factor
    currentActiveDecayFactor = gameState.currentActiveDecayFactor || PROBABILITY_DECAY_FACTOR;
    
    // Restore button costs from saved state
    const oldBombCost = bombConversionCost;
    const oldTrashCost = trashButtonCost;
    const oldPickaxeCost = pickaxeButtonCost;
    const oldSwapCost = swapButtonCost;
    bombConversionCost = gameState.bombConversionCost || 100;
    trashButtonCost = gameState.trashButtonCost || 25;
    pickaxeButtonCost = gameState.pickaxeButtonCost || 1000;
    swapButtonCost = gameState.swapButtonCost || 50;
    bombConversionPresses = gameState.bombConversionPresses || 0;
    trashButtonPresses = gameState.trashButtonPresses || 0;
    pickaxeButtonPresses = gameState.pickaxeButtonPresses || 0;
    swapButtonPresses = gameState.swapButtonPresses || 0;
    swapMode = gameState.swapMode || false;
    swapSelectedIndex = gameState.swapSelectedIndex || 0;
    
    // Restore pickaxe enabled state from saved state
    window.pickaxeEnabled = gameState.pickaxeEnabled || true;
    
    // Restore bomb selection state from saved state
    bombSelected = gameState.bombSelected || false;
    previousBombCost = gameState.previousBombCost || bombConversionCost;
    
    // Restore pickaxe mode state from saved state
    pickaxeMode = gameState.pickaxeMode || false;
    
    // Restore owned quantities from saved state
    bombOwned = gameState.bombOwned || 0;
    trashOwned = gameState.trashOwned || 0;
    pickaxeOwned = gameState.pickaxeOwned || 0;
    swapOwned = gameState.swapOwned || 0;
    
    // Restore purchase tracking from saved state
    bombEverPurchased = gameState.bombEverPurchased || false;
    trashEverPurchased = gameState.trashEverPurchased || false;
    pickaxeEverPurchased = gameState.pickaxeEverPurchased || false;
    swapEverPurchased = gameState.swapEverPurchased || false;
    
    // Restore powerup discovery state from saved state
    bombDiscoveredThisGame = gameState.bombDiscoveredThisGame || false;
    trashDiscoveredThisGame = gameState.trashDiscoveredThisGame || false;
    pickaxeDiscoveredThisGame = gameState.pickaxeDiscoveredThisGame || false;
    swapDiscoveredThisGame = gameState.swapDiscoveredThisGame || false;

    
    // Update powerup ownership badges
    updatePowerupOwnershipBadges();
    
    // Update powerup button visibility based on purchase history
    updatePowerupButtonVisibility();
    


    
    // Restore sound volumes from saved state
    if (gameState.soundVolumes && typeof gameState.soundVolumes === 'object') {
      soundManager.setAllSoundVolumes(gameState.soundVolumes);
    }
    
    // Restore master mute state from saved state
    if (gameState.isMuted !== undefined) {
      soundManager.isMuted = gameState.isMuted;
    }
    
    // Restore theme from saved state
    if (gameState.currentTheme && themeManager.getAvailableThemes().includes(gameState.currentTheme)) {
      themeManager.applyTheme(gameState.currentTheme);
    }
    
    // Restore theme unlock status from saved state (unless prevented by force reset)
    if (gameState.themeUnlocks && typeof gameState.themeUnlocks === 'object' && !window.preventThemeUnlockLoad) {
      for (const [theme, data] of Object.entries(gameState.themeUnlocks)) {
        if (themeManager.themeUnlockRequirements[theme]) {
          themeManager.themeUnlockRequirements[theme].unlocked = data.unlocked;
        }
      }
    } else if (window.preventThemeUnlockLoad) {
      // Skipped theme unlock restoration due to force reset
    }
    
    // Update theme selectors after restoring unlock status
    if (typeof updateThemeSelectors === 'function') {
      updateThemeSelectors();
    }
    
    // Restore first-time user detection timestamp
    lastSeenUpdateTimestamp = gameState.lastSeenUpdateTimestamp || 0;
    console.log('🔄 Restored lastSeenUpdateTimestamp from save:', lastSeenUpdateTimestamp);
    

    
    // Update sound button to reflect restored mute state
    const soundBtn = document.getElementById('soundBtn');
    if (soundBtn) {
      const isMuted = soundManager.getMuteState();
      soundBtn.textContent = isMuted ? '🔇' : '🔊';
      soundBtn.title = 'Sound Controls';
    }
    
    // Update cost displays after restoring game state
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostEl) {
      trashCostEl.textContent = formatNumber(trashButtonCost);
    }
    if (pickaxeCostEl) {
      pickaxeCostEl.textContent = formatNumber(pickaxeButtonCost);
    }

    
    // Update button states to reflect restored bomb selection state
    updateBombConversionButtonState();
    updatePickaxeButtonState();
    updateTrashButtonState();
    updateSwapButtonState();
    
    // Re-render to apply pickaxe mode visual state if it was active
    if (pickaxeMode) {
      render();
    }
    
    // Apply pickaxe visual state if it was enabled
    if (window.pickaxeEnabled) {
      // Make pickaxe button visible
      if (pickaxeButton) {
        pickaxeButton.classList.remove('hidden');
      }
      

      
      // Button sizing is now handled automatically by CSS
    }
    
    return true;
  } catch (error) {
    return false;
  }
}



// Load game state from localStorage
function loadGameState() {
  try {
    // Check if we need to force reset unlocks (from clear all data operation)
    try {
      const forceReset = localStorage.getItem('stackMerge_forceResetUnlocks');
      if (forceReset === 'true') {
        localStorage.removeItem('stackMerge_forceResetUnlocks');
        return false; // Don't load any game state, start fresh
      }
          } catch (e) {
        // Silent error handling
      }
    
    const saveData = localStorage.getItem(SAVE_KEY);
    if (saveData) {
      const gameState = JSON.parse(saveData);
      return restoreGameState(gameState);
    } else {
      return false;
    }
  } catch (error) {
    return false;
  }
}



// Function to manually trigger welcome modal for testing
function testWelcomeModal() {
  console.log('🧪 Manually triggering welcome modal');
  showWelcomeModal();
}

// Function to completely clear all game data (cookies AND localStorage)
function clearAllGameData() {
  // Reset the game to a fresh state before clearing data
  // This ensures we don't accidentally save any in-progress game state
  try {
    resetGame(true);
  } catch (error) {
    // Silent error handling
  }
  
  // Clear cookies - use multiple methods to ensure they're cleared
  try {
    // Clear main save cookie and its chunks
    const cookies = document.cookie.split(';');
    cookies.forEach(cookie => {
      const cookieName = cookie.split('=')[0].trim();
      if (cookieName.startsWith('stackMerge_')) {
        // Try multiple cookie clearing methods
        document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/`;
        document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=${window.location.hostname}`;
        document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=.${window.location.hostname}`;
        document.cookie = `${cookieName}=; max-age=0; path=/`;
        document.cookie = `${cookieName}=; max-age=0; path=/; domain=${window.location.hostname}`;
        document.cookie = `${cookieName}=; max-age=0; path=/; domain=.${window.location.hostname}`;
      }
    });
  } catch (e) {
    // Silent error handling
  }
  
  // Clear localStorage
  try {
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('stackMerge_')) {
        keysToRemove.push(key);
      }
    }
    
    keysToRemove.forEach(key => {
      localStorage.removeItem(key);
    });
    
    // Also specifically clear theme unlock data to ensure it's reset
    localStorage.removeItem('stackMerge_themeUnlocks');
  } catch (e) {
    // Silent error handling
  }
  
  // Reset the useLocalStorage flag
  useLocalStorage = false;
  
  // Reset the first-time user detection timestamp
  lastSeenUpdateTimestamp = 0;
  console.log('🧹 Clear data: Set lastSeenUpdateTimestamp to 0');
  
  // Set flag to prevent any game state saving until page reload
  preventGameStateSave = true;
  console.log('🧹 Clear data: Set preventGameStateSave to true');
  
  // Reset the high score
  window.highScore = 0;
  
  // Reset the total games counter
  window.totalGames = 0;
  
  // Reset lifetime gold earned
  lifetimeGoldEarned = 0;
  
  // Reset total blocks dropped count
  totalBlocksDropped = 0;
  
  // Reset total bombs exploded count
  totalBombsExploded = 0;
  
  // Reset total blocks trashed count
  totalBlocksTrashed = 0;
  
  // Reset total blocks mined count
  totalBlocksMined = 0;
  
  // Reset total swaps used count
  totalSwapsUsed = 0;
  
  // Reset lifetime items purchased count
  lifetimeItemsPurchased = 0;
  
  // Reset other important game state variables
  hasShownPersonalBest = false;
  bombConversionCost = 100; // Reset to default cost
  trashButtonCost = 25; // Reset to default cost
  pickaxeButtonCost = 1000; // Reset to default cost
  swapButtonCost = 50; // Reset to default cost
  bombConversionPresses = 0;
  trashButtonPresses = 0;
  pickaxeButtonPresses = 0;
  swapButtonPresses = 0;
  swapMode = false; // Reset swap mode
  swapSelectedIndex = 0; // Reset swap selected index
  bombSelected = false;
  trashMode = false; // Reset trash mode
  previousBombCost = 100;
  pickaxeMode = false; // Reset pickaxe mode
  currentActiveDecayFactor = PROBABILITY_DECAY_FACTOR; // Reset to default decay factor
  
  // Update the cost displays immediately after resetting
  updatePowerupCostDisplays();
  
  // Update button states to ensure they're properly reset
  updateBombConversionButtonState();
  updatePickaxeButtonState();
  updateTrashButtonState();
  updateSwapButtonState();
  
  // Reset sound settings to defaults
  if (soundManager) {
    try {
      soundManager.resetAudioSettings();
    } catch (e) {
      // Silent error handling
    }
  }
  
  // Set flag to prevent theme unlock loading after clear
  window.preventThemeUnlockLoad = true;
  
  // Set a persistent flag in localStorage to ensure unlock status is reset on next load
  try {
    localStorage.setItem('stackMerge_forceResetUnlocks', 'true');
  } catch (e) {
    // Silent error handling
  }
  
  // Reset theme unlock status to defaults
  if (themeManager) {
    themeManager.themeUnlockRequirements = {
      'jellyfish': { unlocked: true, requirement: 'Default theme' },
      'alternate': { unlocked: false, requirement: 'Score 5000+ points' },
      'miner': { unlocked: false, requirement: '?' }
    };
    // Don't save unlock status during clear - let the force reset flag handle it
    // themeManager.saveUnlockStatus();
    themeManager.applyTheme('jellyfish'); // Reset to default theme
  }
  
  // Force clear any remaining unlock data from localStorage
  try {
    localStorage.removeItem('stackMerge_themeUnlocks');
    localStorage.removeItem('stackMerge_theme');
  } catch (e) {
    // Silent error handling
  }
  
  // Completely reset the ThemeManager to ensure fresh state
  if (themeManager) {
    // Force reset the unlock requirements
    themeManager.themeUnlockRequirements = {
      'jellyfish': { unlocked: true, requirement: 'Default theme' },
      'alternate': { unlocked: false, requirement: 'Score 5000+ points' },
      'miner': { unlocked: false, requirement: '?' }
    };
    
    // Don't save unlock status during clear - let the force reset flag handle it
    // themeManager.saveUnlockStatus();
    
    // Force apply default theme
    themeManager.currentTheme = 'jellyfish';
    themeManager.applyTheme('jellyfish');
  }
  
  // Remove settings button glow effect
  const settingsBtn = document.getElementById('settingsBtn');
  if (settingsBtn) {
    settingsBtn.classList.remove('settings-glow');
  }
  
  // Reset game state variables to defaults
  score = 0;
  gold = 0;
  goldEarnedThisGame = 0;
  blocksDropped = 0;
  placing = false;
  lastPlacementTime = 0;
  currentTargetBlockSize = STARTING_BLOCK_SIZE;
  currentStackCapacity = MAX_HEIGHT;
  currentStage = 1;
  lastGoldAmount = 0;
  
  // Reset weights and probabilities to defaults
  weights = [1, 2];
  probabilities = [0.5, 0.5];
  
  // Reset next queue
  nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
  
  // Reset poles to empty
  poles = [[],[],[],[]];
  

  customBlockMode = false;
  customBlockSize = null;
  customBlockBomb = false;
  
  // Reset debug UI elements to defaults
  if (bombToggle) bombToggle.checked = false;
  
  // Update debug pane to reflect cleared state
  if (typeof updateDebugPane === 'function') {
    updateDebugPane();
  }
  
  // Update cost displays after reset
  if (bombCostEl) {
    bombCostEl.textContent = formatNumber(bombConversionCost);
  }
  if (trashCostEl) {
    trashCostEl.textContent = formatNumber(trashButtonCost);
  }
  if (pickaxeCostEl) {
    pickaxeCostEl.textContent = formatNumber(pickaxeButtonCost);
  }

  
  // Update button states after reset
  updateBombConversionButtonState();
  updateTrashButtonState();
  updatePickaxeButtonState();
  
  // Update theme selectors to reflect reset unlock status
  if (typeof updateThemeSelectors === 'function') {
    // Add a small delay to ensure DOM elements are ready
    setTimeout(() => {
      updateThemeSelectors();
      
      // Force another update after a longer delay to ensure everything is properly set
      setTimeout(() => {
        updateThemeSelectors();
      }, 500);
    }, 100);
  }
  

  
      // Also clear any saved game state that might restore the timestamp
    try {
      // Force clear any existing game state
      const gameState = {
        lastSeenUpdateTimestamp: 0,
        timestamp: Date.now()
      };
      
      // Save this "cleared" state to overwrite any existing data
      localStorage.setItem(SAVE_KEY, JSON.stringify(gameState));
    } catch (e) {
      // Silent error handling
    }
    
      // Force clear the main game save data to ensure unlock status is not restored
  try {
    localStorage.removeItem(SAVE_KEY);
  } catch (e) {
    // Silent error handling
  }
  
  // Force a complete re-render to ensure the queue display matches the reset state
  if (typeof render === 'function') {
    render();
  }
}

// Function to check current storage state
function checkStorageState() {
  // Check cookies
  const cookies = document.cookie.split(';');
  const stackMergeCookies = cookies.filter(cookie => 
    cookie.trim().split('=')[0].startsWith('stackMerge_')
  );
  
  // Check localStorage
  const localStorageKeys = [];
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('stackMerge_')) {
        localStorageKeys.push(key);
      }
    }
  } catch (e) {
    // Silent error handling
  }
}

// Help button storage functions
function setHelpButtonClicked() {
  try {
    localStorage.setItem(HELP_BUTTON_KEY, 'true');
  } catch (error) {
    // Silent error handling
  }
}

function hasHelpButtonBeenClicked() {
  try {
    return localStorage.getItem(HELP_BUTTON_KEY) === 'true';
  } catch (error) {
    return false;
  }
}

// Clear saved game data
function clearGameSave() {
  try {
    // Clear localStorage save data
    localStorage.removeItem(SAVE_KEY);
  } catch (error) {
    // Silent error handling
  }
}

// Auto-save game state periodically and on important events
function setupAutoSave() {
  // Test cookie functionality first
  
  // Try to set a simple test cookie
  document.cookie = 'test_cookie=hello';
  
  // Check if test cookie was set
  const testCookie = document.cookie.includes('test_cookie');
  
  if (!testCookie) {
    // Check if it's a local file issue
    if (window.location.protocol === 'file:') {
      // Local file protocol detected - cookies are blocked by browser security
    }
    
    // Automatically switch to localStorage
    useLocalStorage = true;
    
    // Test localStorage functionality
    try {
      localStorage.setItem('test_storage', 'hello');
      const testValue = localStorage.getItem('test_storage');
      if (testValue === 'hello') {
        localStorage.removeItem('test_storage');
      }
    } catch (e) {
      // Silent error handling
    }
  } else {
    // Basic cookie functionality working
    
    // Clean up test cookie
    document.cookie = 'test_cookie=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
  }
  
  // Auto-save every 30 seconds during gameplay
  setInterval(() => {
    if (score > 0 || gold > 0) { // Only save if there's actual progress
      saveGameState();
    }
  }, 30000);
  
  // Save on page unload/visibility change
  window.addEventListener('beforeunload', () => {
    saveGameState();
  });
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      saveGameState();
    }
  });
}

// Number formatting utility function
function formatNumber(num) {
  if (num < 1000) {
    return num.toString();
  } else if (num < 1000000) {
    return (num / 1000).toFixed(1) + 'k';
  } else if (num < 1000000000) {
    return (num / 1000000).toFixed(1) + 'm';
  } else if (num < 1000000000000) {
    return (num / 1000000000).toFixed(1) + 'b';
  } else if (num < 1000000000000000) {
    return (num / 1000000000000).toFixed(1) + 't';
  } else if (num < 1000000000000000000) {
    return (num / 1000000000000000).toFixed(1) + 'q';
  } else {
    return (num / 1000000000000000000).toFixed(1) + 'Q';
  }
}

// Score formatting utility function - displays all digits with commas every three digits, no decimals
function formatScore(num) {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, '<span class="score-comma">,</span>');
}

// Multiplier formatting utility function
function formatMultiplier(num) {
  if (num < 100000) {
    return num.toString() + ' x';
  } else {
    // Use scientific notation for 100,000 and above without + sign
    const exp = Math.floor(Math.log10(num));
    const mantissa = (num / Math.pow(10, exp)).toFixed(1);
    return mantissa + 'e' + exp + ' x';
  }
}

// Centralized display update functions
function updateScoreDisplay() {
  const scoreDisplay = document.querySelector('.score-value');
  if (scoreDisplay) {
    // Preserve the score label and update only the score content
    const scoreLabel = scoreDisplay.querySelector('.score-label');
    scoreDisplay.innerHTML = `<div class="score-star">⭐</div><div class="score-text">${formatScore(score)}</div>`;
    // Re-add the label if it was removed
    if (scoreLabel && !scoreDisplay.querySelector('.score-label')) {
      scoreDisplay.insertBefore(scoreLabel, scoreDisplay.firstChild);
    }
  }
  // Update debug score display with exact value
  if (debugScore) {
    debugScore.innerHTML = formatScore(score);
  }
  
  // Check for new personal best during gameplay
  const previousHighScore = window.highScore || 0;
  
  if (score > previousHighScore && score > 0) {
    // Always update high score when current score exceeds it
    window.highScore = score;
    
    // Update statistics modal if it's open
    if (statsModal && !statsModal.classList.contains('hidden')) {
      updateStatsModal();
    }
    
    // Only show personal best message once per game AND if this isn't the user's first game
    if (!hasShownPersonalBest && window.totalGames > 0) {
      hasShownPersonalBest = true;
      
      // Show the personal best animation
      showPersonalBest();
      
      // Show the personal best animation
      showPersonalBest();
    } else if (!hasShownPersonalBest && window.totalGames === 0) {
      // First game ever - don't show personal best message
      hasShownPersonalBest = true; // Still mark as shown to prevent showing later in this game
    } else {
      // High score updated during gameplay
    }
  }
  
  // Auto-save when score changes
  if (score > 0) {
    saveGameState();
  }
}

function updateGoldDisplay(shouldPulse = false) {
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    // Preserve the gold label and update only the gold content
    const goldLabel = goldDisplay.querySelector('.gold-label');
    const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
    const oldMultiplier = goldDisplay.querySelector('.stage-multiplier-badge')?.textContent;
    const newMultiplier = formatMultiplier(stageMultiplier);
    
    // Only show badge for stage 2 and higher
    const badgeHTML = currentStage >= 2 ? `<div class="stage-multiplier-badge" id="stageMultiplierBadge">${newMultiplier}</div>` : '';
    
    goldDisplay.innerHTML = `
      <div class="gold-emoji">💰</div>
      <div class="gold-text">${formatNumber(gold)}</div>
      ${badgeHTML}
    `;
    
    // Update powerup button visibility when gold changes
    updatePowerupButtonVisibility();
    // Re-add the label if it was removed
    if (goldLabel && !goldDisplay.querySelector('.gold-label')) {
      goldDisplay.insertBefore(goldLabel, goldDisplay.firstChild);
    }
    
    // Add pulse animation for stage progression if multiplier changed and badge exists
    if (oldMultiplier && oldMultiplier !== newMultiplier && currentStage >= 2) {
      const badge = goldDisplay.querySelector('.stage-multiplier-badge');
      if (badge) {
        badge.classList.add('pulse');
        setTimeout(() => {
          badge.classList.remove('pulse');
        }, 600);
      }
    }
    
    // Add pulse animation when explicitly requested (for gold changes)
    if (shouldPulse) {
      goldDisplay.classList.add('pulse');
      setTimeout(() => {
        goldDisplay.classList.remove('pulse');
      }, 300);
    }
  }
  
  // Update shop gold display
  const shopGoldDisplay = document.querySelector('.shop-gold-text');
  if (shopGoldDisplay) {
    shopGoldDisplay.textContent = formatNumber(gold);
  }
  
  // Update debug gold display with exact value
  if (debugGold) {
    debugGold.textContent = gold;
  }
  
  // Update powerup badges when gold changes (to show/hide cost badges)
  updatePowerupOwnershipBadges();
  
  // Auto-save when gold changes
  if (gold > 0) {
    saveGameState();
  }
}
const MAX_HEIGHT = 10;
const BOMB_CHANCE = 0.01; // 1% chance for bombs
const BOMB_DELAY_BLOCKS = 50; // No bombs for first 50 blocks
const STARTING_BLOCK_SIZE = 512; // Starting block size to merge for new stacks
const PROBABILITY_DECAY_FACTOR = 0.7; // Each block is 70% as likely as the previous one
// 
// PROBABILITY SYSTEM EXPLANATION:
// 
// The game uses a hybrid probability system:
// 
// FOUNDATION BLOCKS (equal probability):
// - Block 1: 100% base probability
// - Block 2: 100% base probability  
// - Block 4: 100% base probability

// DECAY BLOCKS (exponential decay):
// - Block 8: 60% base probability (0.6^1)
// - Block 16: 36% base probability (0.6^2)
// - Block 32: 21.6% base probability (0.6^3)
// - Block 64: 12.96% base probability (0.6^4)
// - And so on...
//
// These base probabilities are then normalized to sum to 100%.
// This creates a stable early game foundation while maintaining
// exponential rarity for higher-tier blocks.

// Initialize the current active decay factor
let currentActiveDecayFactor = PROBABILITY_DECAY_FACTOR;

function getRandomWeight(){
  // Validate probabilities before selecting
  if (!validateProbabilityDistribution()) {
    const randomIndex = Math.floor(Math.random() * weights.length);
    return weights[randomIndex];
  }
  
  let r = Math.random();
  let cum = 0;
  
  for(let i=0;i<probabilities.length;i++){
    cum += probabilities[i];
    if (r < cum) {
      return weights[i];
    }
  }
  
  // Fallback - this should rarely happen if probabilities are correct
  if (weights.length > 0) {
    return weights[weights.length-1];
  } else {
    console.error('No weights available, falling back to 1');
    return 1;
  }
}

function getRandomPiece(){
  // Prevent bombs from spawning for the first 50 blocks
  const canSpawnBomb = blocksDropped >= BOMB_DELAY_BLOCKS;
  const bombChance = canSpawnBomb ? BOMB_CHANCE : 0;
  
  const weight = getRandomWeight();
  
  // Validate the weight before returning
  if (typeof weight !== 'number' || weight <= 0 || !isFinite(weight)) {
    console.error('Invalid weight generated:', weight, 'falling back to 1');
    return { w: 1, bomb: false };
  }
  
  return { w: weight, bomb: Math.random() < bombChance };
}

let poles = [[],[],[],[]];
let score = 0;
let gold = 0; // Track accumulated gold
let goldEarnedThisGame = 0; // Track gold earned in current game
let lifetimeGoldEarned = 0; // Track total gold earned across all games
let totalBlocksDropped = 0; // Track total blocks dropped across all games
let totalBombsExploded = 0; // Track total bombs exploded across all games
let totalBlocksTrashed = 0; // Track total blocks trashed across all games
let totalBlocksMined = 0; // Track total blocks mined with pickaxe across all games
let totalSwapsUsed = 0; // Track total swaps used across all games
let lifetimeItemsPurchased = 0; // Track total items purchased across all games

// Shop owned quantities
let bombOwned = 0; // Track owned bomb powerups
let trashOwned = 0; // Track owned trash can powerups
let pickaxeOwned = 0; // Track owned pickaxe powerups
let swapOwned = 0; // Track owned swap powerups

// Track if each powerup has ever been purchased (for showing in grid)
let bombEverPurchased = false;
let trashEverPurchased = false;
let pickaxeEverPurchased = false;
let swapEverPurchased = false;

// Track if each powerup has been discovered during current game session
let bombDiscoveredThisGame = false;
let trashDiscoveredThisGame = false;
let pickaxeDiscoveredThisGame = false;
let swapDiscoveredThisGame = false;



// Initialize high score tracking
window.highScore = window.highScore || 0;
// Initialize total games counter
window.totalGames = window.totalGames || 0;
let hasShownPersonalBest = false; // Track if we've shown personal best this game
let blocksDropped = 0; // Track total blocks dropped for bomb delay
let placing = false; // block multiple rapid placements while animating
let lastPlacementTime = 0; // track when placement started for timeout safety
let currentTargetBlockSize = STARTING_BLOCK_SIZE; // Current block size needed to unlock new stack
let swapAnimating = false; // block placements while swap animation is running
let currentStackCapacity = MAX_HEIGHT; // Current maximum height for each stack (no longer reduced per stage)
let currentStage = 1; // Current stage (1 = starting, 2 = after first stack unlock, etc.)

// Bomb conversion button state
let bombConversionCost = 100;
let bombConversionPresses = 0; // Number of times button has been pressed
let lastGoldAmount = 0; // Track last gold amount to prevent unnecessary updates
let bombSelected = false; // Track if a bomb is currently selected but not yet placed
let trashMode = false; // Track if trash can mode is active
let previousBombCost = 100; // Store the previous bomb cost before conversion

// Trash button state
let trashButtonCost = 25;
let trashButtonPresses = 0; // Number of times button has been pressed

// Pickaxe button state
let pickaxeButtonCost = 1000;
let pickaxeButtonPresses = 0; // Number of times button has been pressed
let pickaxeMode = false; // Track if pickaxe mode is active

// Swap button state
let swapButtonCost = 50;
let swapButtonPresses = 0; // Number of times button has been pressed
let swapMode = false; // Track if swap mode is active
let swapSelectedIndex = 0; // Track which block in queue is selected (0 = first, 1 = second, 2 = third)

// Initialize pickaxe enabled state
window.pickaxeEnabled = window.pickaxeEnabled || true;

// Initialize next queue (probabilities will be set up after functions are defined)
let nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];

// Emergency reset keyboard shortcut (Ctrl+R) - will be set up after gameDiv is defined



function checkForNewStack() {
  // Stage progression without adding new stacks
  // IMPORTANT: This function should NEVER modify the poles array
  // Poles should remain at exactly 4 permanently
  
  // Safety check: ensure we still have exactly 4 poles
  if (poles.length !== 4) {
    poles = [[],[],[],[]];
  }
  
  // Increment stage counter for gold multiplier
  currentStage++;
  // Double the target block size for the next unlock
  currentTargetBlockSize *= 2;
  // Don't call updateBlockRange() here - let the merge system handle block unlocking
  const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
  
  // Save game state after stage progression
  saveGameState();
}

function checkForNewBlockSize(mergedSize) {
  // Check if this merge unlocks a new block size for future drops
  // The merged size should be available as a droppable piece
  if (!weights.includes(mergedSize)) {
    weights.push(mergedSize);
    
    // Check if this was a stage-triggering block
    if (mergedSize === currentTargetBlockSize * 2) {
      // This was a stage progression block
    } else {
      // This was a regular merge unlock
    }
    
    // Implement a better probability distribution system
    // Lower tier blocks should remain more common, higher tiers progressively rarer
    updateProbabilityDistribution();
    
    // Save game state after unlocking new block size
    saveGameState();
  }
}

function updateProbabilityDistribution() {
  try {
    // Call the custom version with the current active decay factor
    updateProbabilityDistributionCustom(currentActiveDecayFactor);
  } catch (error) {
    throw error; // Re-throw to be caught by the caller
  }
}

function updateProbabilityDistributionCustom(decayFactor) {
  try {
    // Create a hybrid probability system with foundation blocks and exponential decay
    // Foundation blocks (1, 2, 4) get equal probabilities for stable early game
    // Higher blocks (8+) follow an exponential decay curve for progression
    
    const numBlocks = weights.length;
    
    if (numBlocks === 0) {
      return;
    }
    
    // Sort weights to ensure they're in ascending order for proper curve calculation
    const sortedWeights = [...weights].sort((a, b) => a - b);
    const sortedIndices = sortedWeights.map(w => weights.indexOf(w));
    
    // Calculate base probabilities using exponential decay
    const baseProbabilities = [];
    
    for (let i = 0; i < numBlocks; i++) {
      const blockSize = sortedWeights[i];
      
      if (i < 3) {
        // First three blocks (1, 2, 4) get equal, high probabilities
        // This creates a stable foundation for the early game
        baseProbabilities.push(1.0);
      } else {
        // Starting from block 8 (index 3), apply exponential decay
        // Each subsequent block is progressively rarer
        const decayPosition = i - 2; // Start decay from position 1 (after the foundation blocks)
        const baseProbability = Math.pow(decayFactor, decayPosition);
        baseProbabilities.push(baseProbability);
      }
    }
    
    // Normalize probabilities to sum to 1.0
    const totalProbability = baseProbabilities.reduce((sum, p) => sum + p, 0);
    
    if (totalProbability === 0) {
      probabilities = new Array(numBlocks).fill(1.0 / numBlocks);
    } else {
      // Map the normalized probabilities back to the original weights order
      const normalizedProbs = baseProbabilities.map(p => p / totalProbability);
      probabilities = new Array(numBlocks);
      
      // Place probabilities back in original order
      sortedIndices.forEach((originalIndex, sortedIndex) => {
        probabilities[originalIndex] = normalizedProbs[sortedIndex];
      });
    }
    
    // Verify probabilities sum to 1.0 (with small floating point tolerance)
    const actualSum = probabilities.reduce((sum, p) => sum + p, 0);
    if (Math.abs(actualSum - 1.0) > 0.0001) {
      // Force normalization
      const correctedSum = probabilities.reduce((sum, p) => sum + p, 0);
      probabilities = probabilities.map(p => p / correctedSum);
    }
    
    // Final validation
    validateProbabilityDistribution();
    
    // Log the current state for debugging
    logProbabilityState();
    
    // Update the debug display
    updateDebugProbabilitiesDisplay();
  } catch (error) {
    console.error('❌ Error in updateProbabilityDistributionCustom:', error);
    console.error('Error stack:', error.stack);
    throw error; // Re-throw to be caught by the caller
  }
}

function validateProbabilityDistribution() {
  // Validate that probabilities are mathematically correct
  if (!probabilities || probabilities.length === 0) {
    console.error('Probabilities array is empty or undefined');
    return false;
  }
  
  if (probabilities.length !== weights.length) {
    console.error(`Mismatch: ${probabilities.length} probabilities vs ${weights.length} weights`);
    return false;
  }
  
  // Check for negative probabilities
  const negativeProbs = probabilities.filter(p => p < 0);
  if (negativeProbs.length > 0) {
    console.error('Found negative probabilities:', negativeProbs);
    return false;
  }
  
  // Check that probabilities sum to 1.0 (with tolerance for floating point errors)
  const sum = probabilities.reduce((s, p) => s + p, 0);
  if (Math.abs(sum - 1.0) > 0.0001) {
    return false;
  }
  
  // Check that all probabilities are finite numbers
  const invalidProbs = probabilities.filter(p => !isFinite(p));
  if (invalidProbs.length > 0) {
    return false;
  }
  
  return true;
}

// updateBlockRange function removed - block unlocking now handled entirely by checkForNewBlockSize





function showGoldEarned(amount) {
  // Create the gold earned display element
  const goldEl = document.createElement('div');
  goldEl.className = 'gold-earned';
  
  // Debug: Check if formatNumber is available and working
  
  goldEl.textContent = `+${formatNumber(amount)}`;
  
  // Position it at a specific point with text centered on that point
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    const rect = goldDisplay.getBoundingClientRect();
    
    // First, add the element to the DOM temporarily to measure its width
    document.body.appendChild(goldEl);
    const textWidth = goldEl.offsetWidth;
    
    // Calculate the desired position (2px right of gold display right edge)
    let desiredLeft = rect.right + 2;
    
    // Check if the text would be cut off by the right edge of the screen
    const screenRight = window.innerWidth;
    // Since text starts at left edge, the right edge is at desiredLeft + textWidth
    const textRightEdge = desiredLeft + textWidth;
    
    // If text would be cut off, adjust position to the left
    if (textRightEdge > screenRight - 10) { // Leave 10px margin from screen edge
      desiredLeft = screenRight - 10 - textWidth;
    }
    
    // Ensure we don't go too far left (keep it within reasonable bounds)
    const minLeft = Math.max(0, rect.left - 20); // Don't go more than 20px left of the gold display, and never go off-screen left
    if (desiredLeft < minLeft) {
      desiredLeft = minLeft;
    }
    

    
    // Position the element so its left edge starts at desiredLeft
    goldEl.style.left = desiredLeft + 'px';
    goldEl.style.top = (rect.top + 5) + 'px';
  } else {
    // Fallback positioning if gold display not found
    goldEl.style.left = '50%';
    goldEl.style.top = '50%';
    goldEl.style.transform = 'translate(-50%, -50%)';
  }
  
  // Add pulse animation to the gold count
  if (goldDisplay) {
    goldDisplay.classList.add('pulse');
    setTimeout(() => {
      goldDisplay.classList.remove('pulse');
    }, 300);
  }
  
  // Remove after animation completes
  setTimeout(() => {
    if (goldEl.parentNode) {
      goldEl.parentNode.removeChild(goldEl);
    }
  }, 1200);
}

function showPersonalBest() {
  // Create the personal best display element
  const personalBestEl = document.createElement('div');
  personalBestEl.className = 'personal-best';
  personalBestEl.textContent = 'New Record!';
  
  // Position it centered above the score display
  const scoreDisplay = document.querySelector('.score-value');
  if (scoreDisplay) {
    const rect = scoreDisplay.getBoundingClientRect();
    personalBestEl.style.left = (rect.left + rect.width / 2) + 'px';
    personalBestEl.style.top = (rect.top - 40) + 'px'; // Position 40px above the score display
    personalBestEl.style.textAlign = 'center';
  } else {
    // Fallback positioning if score display not found
    personalBestEl.style.left = '50%';
    personalBestEl.style.top = '30%';
  }
  
  document.body.appendChild(personalBestEl);
  
  // Play the personal best sound effect
  if (soundManager && soundManager.canPlayAudio()) {
    soundManager.playSound('personalBest', 'other').catch(error => {
      // Silent error handling
    });
  }
  
  // Add pulse animation to the score display
  if (scoreDisplay) {
    scoreDisplay.classList.add('pulse');
    setTimeout(() => {
      scoreDisplay.classList.remove('pulse');
    }, 300);
  }
  
  // Remove after animation completes (increased from 1.5s to 3s)
  setTimeout(() => {
    if (personalBestEl.parentNode) {
      personalBestEl.parentNode.removeChild(personalBestEl);
    }
  }, 3000);
}

function handleBombConversion() {
  logQueueState('bombConversion-start');
  
  // Validate queue state before proceeding
  validateQueueState();
  
  // Check if there's a next block to work with
  if (nextQueue.length === 0) {
    console.warn('Attempted bomb conversion with empty queue');
    return;
  }
  
  const currentBlock = nextQueue[0];
  
  // Validate current block
  if (!currentBlock || typeof currentBlock.w === 'undefined') {
    console.error('Invalid block in queue:', currentBlock);
    return;
  }
  
  // If a bomb is already selected, allow undoing the selection
  if (bombSelected && currentBlock.bomb) {
    // Undo bomb selection
    currentBlock.bomb = false;
    // Note: No gold to refund since payment hasn't been made yet
    bombConversionCost = previousBombCost; // Restore previous cost
    bombSelected = false;
    
    // Play bomb close sound effect
    if (soundManager && soundManager.canPlayAudio()) {
      soundManager.playBombCloseSound();
    }
    
    // No need to update gold display since no gold was deducted
    
    // Re-render to show the regular block
    renderNext();
    
    // Update all button states
    updateBombConversionButtonState();
    updatePickaxeButtonState();
    updateTrashButtonState();
    updateSwapButtonState();
    

    
    // Save game state after undoing bomb selection
    saveGameState();
    return;
  }
  
  // Check if the next block is already a bomb (either natural or from previous conversion)
  if (currentBlock.bomb) {
    return;
  }
  
  // Check if player has at least one bomb owned or can afford to buy one
  if (bombOwned < 1) {
    // If player can afford to buy a bomb, purchase it first
    if (canAffordPowerup('bomb')) {
      purchaseBomb(false); // false = not from shop
      // After purchasing, stop here - don't continue with bomb conversion
      return;
    } else {
      return;
    }
  }
  
  // Store the current cost before converting
  previousBombCost = bombConversionCost;
  
  // Convert the current next block to a bomb (don't deduct gold yet)
  // Gold will be deducted when the bomb block is actually placed
  if (currentBlock) {
    currentBlock.bomb = true;
    bombSelected = true; // Mark that a bomb is selected
    
    // Play bomb start sound effect
    if (soundManager && soundManager.canPlayAudio()) {
      soundManager.playBombStartSound();
    }
    
    // Update gold display
    updateGoldDisplay();
    
    // Re-render to show the bomb
    renderNext();
    
    // Also re-render the main game to ensure pole placement logic is updated
    // This ensures that if bomb status affects any placement decisions, they're properly reflected
    render();
    
    // Note: Cost will increase when the bomb block is actually placed, not when selected
    // Update all button states
    updateAllPowerupButtonStates();
    
    // Save game state after bomb conversion and cost increase
    saveGameState();
  }
  
  logQueueState('bombConversion-end');
}

function handleTrashButton() {
  logQueueState('trashButton-start');
  
  // Validate queue state before proceeding
  validateQueueState();
  
  // Check if player has at least one trash can owned or can afford to buy one
  if (trashOwned < 1) {
    // If player can afford to buy a trash can, purchase it first
    if (canAffordPowerup('trash')) {
      purchaseTrash(false); // false = not from shop
      // After purchasing, stop here - don't continue with trash usage
      return;
    } else {
      return;
    }
  }
  
  // Check if there's a next block to remove
  if (nextQueue.length === 0) {
    return;
  }
  
  // If trash mode is already active, allow undoing the selection
  if (trashMode) {
    // Undo trash mode
    trashMode = false;
    
    // Play bomb close sound effect (reusing bomb close sound for trash mode)
    if (soundManager && soundManager.canPlayAudio()) {
      soundManager.playBombCloseSound();
    }
    
    // Update all powerup button states
    updateAllPowerupButtonStates();
    renderNext(); // Re-render to remove X overlay
    render(); // Re-render the main game to re-enable stacks
    return;
  }
  
  // Activate trash mode
  trashMode = true;
  
  // Play bomb start sound effect (reusing bomb start sound for trash mode)
  if (soundManager && soundManager.canPlayAudio()) {
    soundManager.playBombStartSound();
  }
  
  // Update all powerup button states
  updateAllPowerupButtonStates();
  
  // Re-render to show trash mode visual indicators
  renderNext();
  render(); // Re-render the main game to show disabled stacks
  
  logQueueState('trashButton-end');
}

function handleTrashConfirmation() {
  logQueueState('trashConfirmation-start');
  
  // Validate queue state before proceeding
  validateQueueState();
  
  // Check if there's a next block to remove
  if (nextQueue.length === 0) {
    return;
  }
  
  // Decrease owned trash can count
  trashOwned--;
  updatePowerupOwnershipBadges();
  
  // Remove the current next block from the queue
  const removedBlock = nextQueue.shift();
  
  // Play trash sound effect
  if (soundManager && soundManager.canPlayAudio()) {
    soundManager.playTrashSound();
  }
  
  // Track total blocks trashed
  totalBlocksTrashed++;
  
  // Add a new random block to the end of the queue to maintain 3 blocks
  nextQueue.push(getRandomPiece());
  
  // Deactivate trash mode
  trashMode = false;
  
  // Play the same animation as placing a block, but don't place it
  animateNextQueueAdvance(true, 0).then(() => {
    // After the queue animation completes, re-render to update pole placement logic
    // This ensures that the new next block can be properly evaluated for placement
    render();
  }); // true = queue already modified, 0 = remove first block
  
  // Update button cost display
  const trashCostEl = document.getElementById('trashCost');
  if (trashCostEl) {
    trashCostEl.textContent = formatNumber(trashButtonCost);
  }
  
  // Update powerup button states to reflect new owned count
  updateTrashButtonState();
  if (trashCostElMobile) {
    trashCostElMobile.textContent = formatNumber(trashButtonCost);
  }
  
  // Update button state (cost changed, so force update)
  updateTrashButtonState();
  
  // Save game state after using trash button and cost increase
  saveGameState();
  
  logQueueState('trashConfirmation-end');
}

function handlePickaxeButton() {
  logQueueState('pickaxeButton-start');
  
  // Validate queue state before proceeding
  validateQueueState();
  
  // Check if player has at least one pickaxe owned or can afford to buy one
  if (pickaxeOwned < 1) {
    // If player can afford to buy a pickaxe, purchase it first
    if (canAffordPowerup('pickaxe')) {
      purchasePickaxe(false); // false = not from shop
      // After purchasing, stop here - don't continue with pickaxe usage
      return;
    } else {
      return;
    }
  }
  
  // Toggle pickaxe mode
  if (pickaxeMode) {
    // Deactivate pickaxe mode
    pickaxeMode = false;
    
    // Play bomb close sound effect (reusing bomb close sound for pickaxe mode)
    if (soundManager && soundManager.canPlayAudio()) {
      soundManager.playBombCloseSound();
    }
    
    // Update all powerup button states
    updateAllPowerupButtonStates();
    render(); // Re-render to remove pickaxe mode visual indicators
    return;
  }
  
  // Activate pickaxe mode
  pickaxeMode = true;
  
  // Play bomb start sound effect (reusing bomb start sound for pickaxe mode)
  if (soundManager && soundManager.canPlayAudio()) {
    soundManager.playBombStartSound();
  }
  
  // Update all powerup button states
  updateAllPowerupButtonStates();
  
  // Re-render to show pickaxe mode visual indicators
  render();
  
  logQueueState('pickaxeButton-end');
}

async function handleSwapButton() {
  logQueueState('swapButton-start');
  
  // Validate queue state before proceeding
  validateQueueState();
  
  // Check if player has at least one swap owned or can afford to buy one
  if (swapOwned < 1) {
    // If player can afford to buy a swap, purchase it first
    if (canAffordPowerup('swap')) {
      purchaseSwap(false); // false = not from shop
      // After purchasing, stop here - don't continue with swap usage
      return;
    } else {
      return;
    }
  }
  
  // Check if there are at least 2 blocks in the queue
  if (nextQueue.length < 2) {
    return;
  }
  
  // Play switch sound effect for each button press
  if (soundManager && soundManager.canPlayAudio()) {
    soundManager.playSwitchSound();
  }
  
  // If not in swap mode, enter swap mode and select the second block
  if (!swapMode) {
    swapMode = true;
    swapSelectedIndex = 1; // Start by selecting the second block
    renderNext(); // Update highlighting
    updateAllPowerupButtonStates(); // Update button states
    saveGameState();
    logQueueState('swapButton-end');
    return;
  }
  
  // If already in swap mode, cycle through the queue positions
  if (swapSelectedIndex === 1) {
    // Currently on second block, move to third block
    swapSelectedIndex = 2;
    renderNext(); // Update highlighting
    saveGameState();
    logQueueState('swapButton-end');
    return;
  }
  
  if (swapSelectedIndex === 2) {
    // Currently on third block, return to first block and exit swap mode
    swapMode = false;
    swapSelectedIndex = 0;
    renderNext(); // Update highlighting
    updateAllPowerupButtonStates(); // Update button states
    saveGameState();
    logQueueState('swapButton-end');
    return;
  }
  
  logQueueState('swapButton-end');
}

async function handlePickaxeBlockRemoval(poleIndex, blockIndex = null) {
  // Find the pole that was clicked
  const pole = poles[poleIndex];
  
  // Check if the pole has any blocks
  if (pole.length === 0) {
    return; // Nothing to remove
  }
  
  // If no specific block index provided, default to top block
  if (blockIndex === null) {
    blockIndex = pole.length - 1;
  }
  
  // Ensure the block index is within bounds
  if (blockIndex < 0 || blockIndex >= pole.length) {
    return; // Invalid block index
  }
  
  // Play break sound effect immediately when block is selected
  if (soundManager && soundManager.canPlayAudio()) {
    soundManager.playBreakSound();
  }
  
  // DEACTIVATE PICKAXE MODE IMMEDIATELY - FIRST THING THAT HAPPENS
  pickaxeMode = false;
  
  // Decrease owned pickaxe count
  pickaxeOwned--;
  updatePowerupOwnershipBadges();
  
  // Track total blocks mined with pickaxe
  totalBlocksMined++;
  
  // Update all powerup button states
  updateAllPowerupButtonStates();
  

  
  // Add explosion effect to the block being removed
  const poleDiv = gameDiv.children[poleIndex];
  const blocks = poleDiv.querySelectorAll('.disc');
  const blockToRemove = blocks[blockIndex];
  
  if (blockToRemove) {
    // Add the bomb explosion effect to the block being removed
    blockToRemove.classList.add('bomb-explosion');
  }
  
  // Wait for the explosion animation to complete before removing the block
  if (blockToRemove) {
    await new Promise(resolve => {
      // Wait for the explosion animation to complete
      setTimeout(resolve, 500); // 500ms matches the bomb explosion animation duration
    });
    
    // Clean up the explosion class
    blockToRemove.classList.remove('bomb-explosion');
  }
  
  // Remove the specific block that was clicked
  const removedBlock = poles[poleIndex].splice(blockIndex, 1)[0];
  
  // Save game state after using pickaxe
  saveGameState();
  
  // Call render() to update visual state
  render();
  
  // Check if there are any merges possible after removing the block
  if (poles[poleIndex].length > 1) {
    // Look for any adjacent equal blocks that can merge
    let hasMerges = false;
    for (let i = 0; i < poles[poleIndex].length - 1; i++) {
      if (poles[poleIndex][i].w === poles[poleIndex][i + 1].w) {
        hasMerges = true;
        break;
      }
    }
    
    if (hasMerges) {
      // Small delay to ensure render completes before merge cascade
      setTimeout(() => animateMergeCascade(poleIndex), 50);
    }
  }
}



function updateBombConversionButtonState() {
  // Always update when called since we call this strategically
  
  if (bombConversionBtn) {
    // If a bomb is selected, the button should always be enabled for undo
    if (bombSelected) {
      bombConversionBtn.disabled = false;
      bombConversionBtn.classList.add('undo-mode');
      bombConversionBtn.title = "Press again to undo bomb selection";
      const emojiEl = bombConversionBtn.querySelector('.powerup-emoji');
      if (emojiEl) emojiEl.textContent = "↩️";
      
      // Disable other powerup buttons when bomb is in undo mode
      if (trashButton) {
        trashButton.disabled = true;
        trashButton.title = "Bomb is active - complete or undo first";
      }
      if (pickaxeButton) {
        pickaxeButton.disabled = true;
        pickaxeButton.title = "Bomb is active - complete or undo first";
      }
      if (swapButton) {
        swapButton.disabled = true;
        swapButton.title = "Bomb is active - complete or undo first";
      }
    } else {
      // Check if the next block is already a bomb (either natural or from previous conversion)
      const nextBlockIsBomb = nextQueue.length > 0 && nextQueue[0].bomb;
      
      if (nextBlockIsBomb) {
        // Next block is already a bomb, disable the button
        bombConversionBtn.disabled = true;
        bombConversionBtn.classList.remove('undo-mode');
        bombConversionBtn.title = "Next block is already a bomb";
        const emojiEl = bombConversionBtn.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "💣";
      } else {
        // Next block is not a bomb, check if player has at least one bomb owned or can afford one
        const hasBombOwned = bombOwned >= 1;
        const canAffordBomb = canAffordPowerup('bomb');
        bombConversionBtn.disabled = !hasBombOwned && !canAffordBomb;
        bombConversionBtn.classList.remove('undo-mode');
        bombConversionBtn.title = "Convert next block to bomb (press again to undo)";
        const emojiEl = bombConversionBtn.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "💣";
      }
      
      // Re-enable other powerup buttons when bomb is not in undo mode
      // But check if other modes are active first
      if (trashMode) {
        // Trash mode is active, disable bomb button
        bombConversionBtn.disabled = true;
        bombConversionBtn.title = "Trash is active - complete or undo first";
      } else if (swapMode) {
        // Swap mode is active, disable bomb button
        bombConversionBtn.disabled = true;
        bombConversionBtn.title = "Swap is active - complete or cycle first";
      } else {
        // No other modes active, check if player has at least one bomb owned or can afford one
        const hasBombOwned = bombOwned >= 1;
        const canAffordBomb = canAffordPowerup('bomb');
        bombConversionBtn.disabled = !hasBombOwned && !canAffordBomb;
        bombConversionBtn.title = "Convert next block to bomb (press again to undo)";
      }
      
      if (trashButton) {
        const hasTrashOwned = trashOwned >= 1;
        const canAffordTrash = canAffordPowerup('trash');
        trashButton.disabled = !hasTrashOwned && !canAffordTrash;
        trashButton.title = "Remove next block from queue";
      }
      if (pickaxeButton) {
        const hasPickaxeOwned = pickaxeOwned >= 1;
        const canAffordPickaxe = canAffordPowerup('pickaxe');
        pickaxeButton.disabled = !hasPickaxeOwned && !canAffordPickaxe;
        pickaxeButton.title = "Remove any block from stacks (press again to deactivate)";
      }
    }
    
    // Update the tracked gold amount
    lastGoldAmount = gold;
  }
  

}

function updateTrashButtonState() {
  // Always update when called since we call this strategically
  
  if (trashButton) {
    // If trash mode is active, the button should always be enabled for undo
    if (trashMode) {
      trashButton.disabled = false;
      trashButton.classList.add('undo-mode');
      trashButton.title = "Press again to undo trash selection";
      const emojiEl = trashButton.querySelector('.powerup-emoji');
      if (emojiEl) emojiEl.textContent = "↩️";
      
      // Disable other powerup buttons when trash is in undo mode
      if (bombConversionBtn) {
        bombConversionBtn.disabled = true;
        bombConversionBtn.title = "Trash is active - complete or undo first";
      }
      if (pickaxeButton) {
        pickaxeButton.disabled = true;
        pickaxeButton.title = "Trash is active - complete or undo first";
      }
      if (swapButton) {
        swapButton.disabled = true;
        swapButton.title = "Trash is active - complete or undo first";
      }
    } else {
      // Check if other powerups are in undo mode
      const otherPowerupActive = bombSelected || pickaxeMode || swapMode;
      
      if (otherPowerupActive) {
        // Another powerup is active, disable trash button
        trashButton.disabled = true;
        trashButton.classList.remove('undo-mode');
        if (bombSelected) {
          trashButton.title = "Bomb is active - complete or undo first";
        } else if (pickaxeMode) {
          trashButton.title = "Pickaxe is active - complete or deactivate first";
        } else if (swapMode) {
          trashButton.title = "Swap is active - complete or cycle first";
        }
        const emojiEl = trashButton.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "🗑️";
      } else {
        // No other powerups active, check if player has at least one trash can owned or can afford one
        const hasTrashOwned = trashOwned >= 1;
        const canAffordTrash = canAffordPowerup('trash');
        trashButton.disabled = !hasTrashOwned && !canAffordTrash;
        trashButton.classList.remove('undo-mode');
        trashButton.title = "Remove next block from queue";
        const emojiEl = trashButton.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "🗑️";
      }
    }
    
    // Update the tracked gold amount
    lastGoldAmount = gold;
  }
  

}

function updatePickaxeButtonState() {
  // Always update when called since we call this strategically
  
  if (pickaxeButton) {
    const hasPickaxeOwned = pickaxeOwned >= 1;
    
    if (pickaxeMode) {
      // Pickaxe mode is active - button should be enabled for deactivation
      pickaxeButton.disabled = false;
      pickaxeButton.classList.add('undo-mode');
      pickaxeButton.title = "Press again to deactivate pickaxe mode";
      const emojiEl = pickaxeButton.querySelector('.powerup-emoji');
      if (emojiEl) emojiEl.textContent = "↩️";
      
      // Disable other powerup buttons when pickaxe is in undo mode
      if (bombConversionBtn) {
        bombConversionBtn.disabled = true;
        bombConversionBtn.title = "Pickaxe is active - complete or deactivate first";
      }
      if (trashButton) {
        trashButton.disabled = true;
        trashButton.title = "Pickaxe is active - complete or deactivate first";
      }
      if (swapButton) {
        swapButton.disabled = true;
        swapButton.title = "Pickaxe is active - complete or deactivate first";
      }
    } else {
      // Pickaxe mode is not active - check if other powerups are active first
      if (bombSelected) {
        // Bomb is active, disable pickaxe button
        pickaxeButton.disabled = true;
        pickaxeButton.classList.remove('undo-mode');
        pickaxeButton.title = "Bomb is active - complete or undo first";
        const emojiEl = pickaxeButton.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "⛏️";
      } else if (trashMode) {
        // Trash mode is active, disable pickaxe button
        pickaxeButton.disabled = true;
        pickaxeButton.classList.remove('undo-mode');
        pickaxeButton.title = "Trash is active - complete or undo first";
        const emojiEl = pickaxeButton.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "⛏️";
      } else if (swapMode) {
        // Swap mode is active, disable pickaxe button
        pickaxeButton.disabled = true;
        pickaxeButton.classList.remove('undo-mode');
        pickaxeButton.title = "Swap is active - complete or cycle first";
        const emojiEl = pickaxeButton.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "⛏️";
      } else {
        // No other powerups active - check if player has at least one pickaxe owned or can afford one
        const canAffordPickaxe = canAffordPowerup('pickaxe');
        pickaxeButton.disabled = !hasPickaxeOwned && !canAffordPickaxe;
        pickaxeButton.classList.remove('undo-mode');
        pickaxeButton.title = "Remove any block from stacks (press again to deactivate)";
        const emojiEl = pickaxeButton.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "⛏️";
      }
      
      // Update the cost display immediately when the undo emoji changes to ⛏️
      const pickaxeCostEl = document.getElementById('pickaxeCost');
      if (pickaxeCostEl) {
        pickaxeCostEl.textContent = formatNumber(pickaxeButtonCost);
      }
      
      // Re-enable other powerup buttons when pickaxe is not in undo mode
      // But only if they're not in their own undo mode
      if (bombConversionBtn && !bombSelected && !trashMode && !swapMode) {
        const hasBombOwned = bombOwned >= 1;
        const canAffordBomb = canAffordPowerup('bomb');
        bombConversionBtn.disabled = !hasBombOwned && !canAffordBomb;
        bombConversionBtn.title = "Convert next block to bomb (press again to undo)";
      }
      if (trashButton && !bombSelected && !trashMode && !swapMode) {
        const hasTrashOwned = trashOwned >= 1;
        const canAffordTrash = canAffordPowerup('trash');
        trashButton.disabled = !hasTrashOwned && !canAffordTrash;
        trashButton.title = "Remove next block from queue";
      }
    }
    
    // Update the tracked gold amount
    lastGoldAmount = gold;
  }
}

function updateSwapButtonState() {
  // Always update when called since we call this strategically
  
  if (swapButton) {
    // Check if other powerups are in undo mode
    const otherPowerupActive = bombSelected || pickaxeMode || trashMode;
    
    if (otherPowerupActive) {
      // Another powerup is active, disable swap button
      swapButton.disabled = true;
      swapButton.classList.remove('undo-mode');
      const emojiEl = swapButton.querySelector('.powerup-emoji');
      if (emojiEl) emojiEl.textContent = "🔄";
      if (bombSelected) {
        swapButton.title = "Bomb is active - complete or undo first";
      } else if (pickaxeMode) {
        swapButton.title = "Pickaxe is active - complete or deactivate first";
      } else if (trashMode) {
        swapButton.title = "Trash is active - complete or undo first";
      }
    } else {
      // No other powerups active, check if player has at least one swap owned or can afford one
      const hasSwapOwned = swapOwned >= 1;
      const canAffordSwap = canAffordPowerup('swap');
      
      // Check if next two blocks in queue are the same (would be wasteful to swap)
      const nextTwoBlocksSame = nextQueue.length >= 2 && 
                                nextQueue[0].w === nextQueue[1].w;
      
      // Disable if no swap owned AND can't afford one OR if next two blocks are the same
      swapButton.disabled = (!hasSwapOwned && !canAffordSwap) || nextTwoBlocksSame;
      
      if (!hasSwapOwned && !canAffordSwap) {
        swapButton.title = "Select block to drop from queue";
        swapButton.classList.remove('undo-mode');
        const emojiEl = swapButton.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "🔄";
      } else if (nextTwoBlocksSame) {
        swapButton.title = "Next two blocks are the same - swap would be wasteful";
        swapButton.classList.remove('undo-mode');
        const emojiEl = swapButton.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "🔄";
      } else if (swapMode) {
        // In swap mode, show current selection with undo styling
        const positionNames = ['first', 'second', 'third'];
        swapButton.title = `Selected: ${positionNames[swapSelectedIndex]} block - click to cycle or place block`;
        swapButton.classList.add('undo-mode');
        const emojiEl = swapButton.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "➡️";
        
        // Disable other powerup buttons when swap is in undo mode
        if (bombConversionBtn) {
          bombConversionBtn.disabled = true;
          bombConversionBtn.title = "Swap is active - complete or cycle first";
        }
        if (trashButton) {
          trashButton.disabled = true;
          trashButton.title = "Swap is active - complete or cycle first";
        }
        if (pickaxeButton) {
          pickaxeButton.disabled = true;
          pickaxeButton.title = "Swap is active - complete or cycle first";
        }
      } else {
        swapButton.title = "Select block to drop from queue";
        swapButton.classList.remove('undo-mode');
        const emojiEl = swapButton.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "🔄";
      }
    }
    
    // Update the tracked gold amount
    lastGoldAmount = gold;
  }
}

// More targeted update function for when we know gold has changed
// Use this instead of updateBombConversionButtonState() when gold changes during gameplay
function updateBombButtonIfGoldChanged() {
  updateBombConversionButtonState();
}

// More targeted update function for trash button when we know gold has changed
function updateTrashButtonIfGoldChanged() {
  updateTrashButtonState();
}

// More targeted update function for swap button when we know gold has changed
function updateSwapButtonIfGoldChanged() {
  updateSwapButtonState();
}

// General function to update all powerup buttons when gold has changed
function updateAllPowerupButtonsIfGoldChanged() {
  updateBombButtonIfGoldChanged();
  updateTrashButtonIfGoldChanged();
  updatePickaxeButtonIfGoldChanged();
  updateSwapButtonIfGoldChanged();
}

// More targeted update function for pickaxe button when we know gold has changed
function updatePickaxeButtonIfGoldChanged() {
  updatePickaxeButtonState();
}

// AI state
let aiEnabled = false;
let aiInterval = null;
const AI_DELAY_MS = 500;

// Speed control state


// Debug pane state
let debugPane = null;
let debugClose = null;
let bombToggle = null;
let bombStatus = null;
let debugScore = null;
let debugGold = null;
let debugStacks = null;
let debugCapacity = null;
let debugTarget = null;
let debugMaxBlock = null;
  let debugBlocksDropped = null;
  let debugTotalBlocksDropped = null;
  let debugTotalBombsExploded = null;
  let debugTotalBlocksTrashed = null;
  let debugTotalBlocksMined = null;
  let debugTotalSwapsUsed = null;
  let debugLifetimeItemsPurchased = null;
  let debugBombStatus = null;
  let debugStage = null;



let customBlockMode = false;
let customBlockSize = null;
let customBlockBomb = false;

// DOM refs
const gameDiv = document.getElementById('game');
const nextContainer = document.getElementById('nextContainer');
const scoreEl = document.getElementById('scoreDisplay');
const goldEl = document.getElementById('goldDisplay');

const helpBtn = document.getElementById('helpBtn');
const helpModal = document.getElementById('helpModal');
const helpClose = document.getElementById('helpClose');

// Bomb conversion button DOM refs
const bombConversionBtn = document.getElementById('bombConversionBtn');
const bombCostEl = document.getElementById('bombCost');

// Trash button DOM refs
const trashButton = document.getElementById('trashButton');
const trashCostEl = document.getElementById('trashCost');

// Pickaxe button DOM refs
const pickaxeButton = document.getElementById('pickaxeButton');
const pickaxeCostEl = document.getElementById('pickaxeCost');

// Swap button DOM refs
const swapButton = document.getElementById('swapButton');
const swapCostEl = document.getElementById('swapCost');

// Button element status for debugging

// Debug pane DOM refs
debugPane = document.getElementById('debugPane');
debugClose = document.getElementById('debugClose');
bombToggle = document.getElementById('bombToggle');
bombStatus = document.getElementById('bombStatus');
debugScore = document.getElementById('debugScore');
debugGold = document.getElementById('debugGold');
debugStacks = document.getElementById('debugStacks');
debugCapacity = document.getElementById('debugCapacity');
debugTarget = document.getElementById('debugTarget');
debugMaxBlock = document.getElementById('debugMaxBlock');
              debugBlocksDropped = document.getElementById('debugBlocksDropped');
        debugTotalBlocksDropped = document.getElementById('debugTotalBlocksDropped');
        debugTotalBombsExploded = document.getElementById('debugTotalBombsExploded');
        debugTotalBlocksTrashed = document.getElementById('debugTotalBlocksTrashed');
        debugTotalBlocksMined = document.getElementById('debugTotalBlocksMined');
        debugTotalSwapsUsed = document.getElementById('debugTotalSwapsUsed');
        debugLifetimeItemsPurchased = document.getElementById('debugLifetimeItemsPurchased');
        debugBombStatus = document.getElementById('debugBombStatus');
        debugStage = document.getElementById('debugStage');
const grantGoldBtn = document.getElementById('grantGoldBtn');
const grantScoreBtn = document.getElementById('grantScoreBtn');


// Emergency reset keyboard shortcut (Ctrl+R)
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 'r') {
    e.preventDefault();
    placing = false; // Force reset placing state
    swapAnimating = false; // Force reset swap animating state
    
    // Re-enable hover effects and pointer events on all poles
    if (gameDiv && gameDiv.children) {
      const allPoles = Array.from(gameDiv.children);
      allPoles.forEach(poleDiv => {
        poleDiv.style.pointerEvents = '';
        poleDiv.classList.remove('no-hover');
      });
    }
    
    resetGame(true);
  }
});





// Function to update help guide examples with current theme colors
function updateHelpGuideColors() {
  // Update merge examples
  const mergeExamples = document.querySelectorAll('.merge-example .merge-block');
  mergeExamples.forEach(block => {
    const dataValue = block.getAttribute('data-value');
    if (dataValue) {
      const numValue = parseInt(dataValue);
      if (!isNaN(numValue)) {
        block.style.background = colorFor(numValue);
        block.style.color = getTextColorFor(numValue);
      }
    }
  });
  
  // Update stage progression examples
  const stageBlocks = document.querySelectorAll('.next-stage-block');
  stageBlocks.forEach(block => {
    const text = block.textContent;
    const numValue = parseInt(text);
    if (!isNaN(numValue)) {
      block.style.background = colorFor(numValue);
      block.style.color = getTextColorFor(numValue);
    }
  });
}

// Help modal wiring
function openHelp(){ 
  helpModal.classList.remove('hidden'); 
  
  // Update help guide colors with current theme
  setTimeout(() => {
    updateHelpGuideColors();
  }, 100); // Small delay to ensure modal is fully rendered
  
  // Dynamically position the help modal content below the close button on mobile
  const helpModalContent = document.querySelector('.help-modal');
  const closeButton = document.getElementById('helpClose');
  
  if (helpModalContent && closeButton && window.innerWidth <= 768) {
    // Use a small delay to ensure the modal is fully rendered before calculating position
    setTimeout(() => {
      positionHelpModalMobile();
    }, 50);
  } else if (helpModalContent) {
    // Position for desktop with delay to ensure rendering
    setTimeout(() => {
      positionHelpModalDesktop();
    }, 50);
  }
  
  // Save that the help button has been clicked and remove the glow
  setHelpButtonClicked();
  helpBtn.classList.remove('help-glow');
}

// Function to calculate safe viewport dimensions for mobile
function calculateSafeViewport() {
  // Get the actual viewport dimensions
  const visualViewport = window.visualViewport || window;
  
  // Get safe area insets (iOS specific)
  const safeAreaTop = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sat') || '0');
  const safeAreaBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sab') || '0');
  
  // Calculate the actual safe viewport
  const safeTop = Math.max(safeAreaTop, 0);
  const safeBottom = Math.max(safeAreaBottom, 0);
  
  // Use visualViewport.height for more accurate mobile viewport
  const viewportHeight = visualViewport.height || window.innerHeight;
  const safeHeight = viewportHeight - safeTop - safeBottom;
  
  return {
    top: safeTop,
    bottom: safeBottom,
    height: safeHeight,
    viewportHeight: viewportHeight,
    width: visualViewport.width || window.innerWidth
  };
}

// Function to position help modal on mobile with proper safe viewport handling
function positionHelpModalMobile() {
  const helpModalContent = document.querySelector('.help-modal');
  const closeButton = document.getElementById('helpClose');
  
  if (!helpModalContent || !closeButton) return;
  
  const safeViewport = calculateSafeViewport();
  
  // Position close button at the top of safe area with some padding
  const closeButtonTop = safeViewport.top + 20;
  closeButton.style.top = `${closeButtonTop}px`;
  
  // Calculate close button dimensions
  const closeButtonRect = closeButton.getBoundingClientRect();
  const closeButtonHeight = closeButtonRect.height;
  
  // Position help modal below close button with spacing
  const modalTop = closeButtonTop + closeButtonHeight + 20;
  helpModalContent.style.top = `${modalTop}px`;
  
  // Calculate maximum height for the modal to fit within safe viewport
  const availableHeight = safeViewport.height - (modalTop - safeViewport.top) - 40;
  helpModalContent.style.maxHeight = `${availableHeight}px`;
  
  // Reset padding to normal
  helpModalContent.style.paddingTop = '20px';
  
  // Mobile help modal positioned
}

// Function to position help modal on desktop
function positionHelpModalDesktop() {
  const helpModalContent = document.querySelector('.help-modal');
  const closeButton = document.getElementById('helpClose');
  
  if (!helpModalContent || !closeButton) return;
  
  // On desktop, we need to position the modal content below the close button
  // The close button is positioned with fixed positioning, so we calculate its position
  const closeButtonRect = closeButton.getBoundingClientRect();
  const closeButtonBottom = closeButtonRect.bottom;
  
  // Position the modal content below the close button with spacing
  const modalTop = closeButtonBottom + 20;
  helpModalContent.style.top = `${modalTop}px`;
  
  // Calculate maximum height to ensure content fits within viewport
  const availableHeight = window.innerHeight - modalTop - 80; // 80px bottom margin for desktop spacing
  helpModalContent.style.maxHeight = `${availableHeight}px`;
  
  // Reset other positioning properties
  helpModalContent.style.paddingTop = '20px';
  
  // Desktop help modal positioned below close button
}

// Function to reposition help modal content when needed
function repositionHelpModal() {
  const helpModalContent = document.querySelector('.help-modal');
  // Only reposition if help modal is actually visible
  if (helpModalContent && !helpModalContent.classList.contains('hidden')) {
    if (window.innerWidth <= 768) {
      positionHelpModalMobile();
    } else {
      positionHelpModalDesktop();
    }
  }
}

// Add event listeners for viewport changes and device rotation
window.addEventListener('resize', repositionHelpModal);

// Listen for visual viewport changes (important for mobile browsers)
// Only reposition when help modal is actually open to prevent unnecessary layout shifts
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', () => {
    // Only reposition if help modal is visible
    const helpModalContent = document.querySelector('.help-modal');
    if (helpModalContent && !helpModalContent.classList.contains('hidden')) {
      repositionHelpModal();
    }
  });
}

// Listen for orientation changes
window.addEventListener('orientationchange', () => {
  setTimeout(repositionHelpModal, 100); // Delay to allow orientation change to complete
});
function closeHelp(){ helpModal.classList.add('hidden'); }
if (helpBtn) {
  helpBtn.addEventListener('click', () => {

    openHelp();
  });
}

if (helpClose) {
  helpClose.addEventListener('click', closeHelp);
}

// Shop modal functionality
const shopModal = document.getElementById('shopModal');

const shopClose = document.getElementById('shopClose');



function closeShop() {
  shopModal.classList.add('hidden');
}



if (shopClose) {
  shopClose.addEventListener('click', closeShop);
}

// Welcome modal functionality
const welcomeModal = document.getElementById('welcomeModal');
const welcomeYesBtn = document.getElementById('welcomeYesBtn');
const welcomeSkipBtn = document.getElementById('welcomeSkipBtn');

function showWelcomeModal() {
  if (welcomeModal) {
    welcomeModal.classList.remove('hidden');
  }
}

function closeWelcomeModal() {
  if (welcomeModal) {
    welcomeModal.classList.add('hidden');
  }
}

if (welcomeYesBtn) {
  welcomeYesBtn.addEventListener('click', () => {
    closeWelcomeModal();
    // Mark that user has seen the welcome message
    lastSeenUpdateTimestamp = 1;
    saveGameState();
    // Open the help modal to show the How to Play guide
    if (typeof openHelp === 'function') {
      openHelp();
    }
  });
}

if (welcomeSkipBtn) {
  welcomeSkipBtn.addEventListener('click', () => {
    closeWelcomeModal();
    // Mark that user has seen the welcome message
    lastSeenUpdateTimestamp = 1;
    saveGameState();
  });
}

// Close welcome modal when clicking outside of it
if (welcomeModal) {
  welcomeModal.addEventListener('click', (e) => {
    if (e.target === welcomeModal) {
      closeWelcomeModal();
      // Mark that user has seen the welcome message
      lastSeenUpdateTimestamp = 1;
      saveGameState();
    }
  });
}

// Function to update all powerup button states
function updateAllPowerupButtonStates() {
  // Call individual button state functions to ensure proper undo mode styling
  updateBombConversionButtonState();
  updateTrashButtonState();
  updatePickaxeButtonState();
  updateSwapButtonState();
}

// Function to check if player can afford a powerup
function canAffordPowerup(powerupType) {
  switch (powerupType) {
    case 'bomb':
      return gold >= bombConversionCost;
    case 'trash':
      return gold >= trashButtonCost;
    case 'swap':
      return gold >= swapButtonCost;
    case 'pickaxe':
      return gold >= pickaxeButtonCost;
    default:
      return false;
  }
}

// Function to get the cost of a powerup
function getPowerupCost(powerupType) {
  switch (powerupType) {
    case 'bomb':
      return bombConversionCost;
    case 'trash':
      return trashButtonCost;
    case 'swap':
      return swapButtonCost;
    case 'pickaxe':
      return pickaxeButtonCost;
    default:
      return 0;
  }
}

// Function to update badge color based on count
function updateBadgeColor(badgeElement, count) {
  if (!badgeElement) return;
  
  // Remove all existing color classes
  badgeElement.classList.remove('count-0', 'count-1-plus');
  
  // Add appropriate color class based on count
  if (count === 0) {
    badgeElement.classList.add('count-0');
  } else if (count >= 1) {
    badgeElement.classList.add('count-1-plus');
  }
}

// Function to trigger badge scale animation
function triggerBadgeAnimation(badgeId) {
  const badge = document.getElementById(badgeId);
  if (badge) {
    // Remove any existing animation class
    badge.classList.remove('scale-animation');
    // Force a reflow to ensure the class removal is processed
    badge.offsetHeight;
    // Add the animation class
    badge.classList.add('scale-animation');
    // Remove the class after animation completes
    setTimeout(() => {
      badge.classList.remove('scale-animation');
    }, 400);
  }
}

// Function to update powerup ownership badges
function updatePowerupOwnershipBadges() {
  const bombOwnershipBadge = document.getElementById('bombOwnershipBadge');
  const trashOwnershipBadge = document.getElementById('trashOwnershipBadge');
  const pickaxeOwnershipBadge = document.getElementById('pickaxeOwnershipBadge');
  const swapOwnershipBadge = document.getElementById('swapOwnershipBadge');
  
  const bombCostBadge = document.getElementById('bombCostBadge');
  const trashCostBadge = document.getElementById('trashCostBadge');
  const pickaxeCostBadge = document.getElementById('pickaxeCostBadge');
  const swapCostBadge = document.getElementById('swapCostBadge');
  
  // Bomb badges
  if (bombOwnershipBadge) {
    if (bombOwned > 0) {
      // Show ownership badge when owned
      bombOwnershipBadge.textContent = bombOwned;
      bombOwnershipBadge.style.display = 'block';
      updateBadgeColor(bombOwnershipBadge, bombOwned);
    } else {
      // Hide ownership badge when not owned
      bombOwnershipBadge.style.display = 'none';
    }
  }
  if (bombCostBadge) {
    if (bombOwned === 0) {
      // Show cost badge only when not owned
      bombCostBadge.textContent = formatNumber(bombConversionCost);
      bombCostBadge.style.display = 'block';
      if (canAffordPowerup('bomb')) {
        bombCostBadge.classList.remove('disabled');
      } else {
        bombCostBadge.classList.add('disabled');
      }
    } else {
      // Hide cost badge when owned
      bombCostBadge.style.display = 'none';
    }
  }
  
  // Trash badges
  if (trashOwnershipBadge) {
    if (trashOwned > 0) {
      // Show ownership badge when owned
      trashOwnershipBadge.textContent = trashOwned;
      trashOwnershipBadge.style.display = 'block';
      updateBadgeColor(trashOwnershipBadge, trashOwned);
    } else {
      // Hide ownership badge when not owned
      trashOwnershipBadge.style.display = 'none';
    }
  }
  if (trashCostBadge) {
    if (trashOwned === 0) {
      // Show cost badge only when not owned
      trashCostBadge.textContent = formatNumber(trashButtonCost);
      trashCostBadge.style.display = 'block';
      if (canAffordPowerup('trash')) {
        trashCostBadge.classList.remove('disabled');
      } else {
        trashCostBadge.classList.add('disabled');
      }
    } else {
      // Hide cost badge when owned
      trashCostBadge.style.display = 'none';
    }
  }
  
  // Pickaxe badges
  if (pickaxeOwnershipBadge) {
    if (pickaxeOwned > 0) {
      // Show ownership badge when owned
      pickaxeOwnershipBadge.textContent = pickaxeOwned;
      pickaxeOwnershipBadge.style.display = 'block';
      updateBadgeColor(pickaxeOwnershipBadge, pickaxeOwned);
    } else {
      // Hide ownership badge when not owned
      pickaxeOwnershipBadge.style.display = 'none';
    }
  }
  if (pickaxeCostBadge) {
    if (pickaxeOwned === 0) {
      // Show cost badge only when not owned
      pickaxeCostBadge.textContent = formatNumber(pickaxeButtonCost);
      pickaxeCostBadge.style.display = 'block';
      if (canAffordPowerup('pickaxe')) {
        pickaxeCostBadge.classList.remove('disabled');
      } else {
        pickaxeCostBadge.classList.add('disabled');
      }
    } else {
      // Hide cost badge when owned
      pickaxeCostBadge.style.display = 'none';
    }
  }
  
  // Swap badges
  if (swapOwnershipBadge) {
    if (swapOwned > 0) {
      // Show ownership badge when owned
      swapOwnershipBadge.textContent = swapOwned;
      swapOwnershipBadge.style.display = 'block';
      updateBadgeColor(swapOwnershipBadge, swapOwned);
    } else {
      // Hide ownership badge when not owned
      swapOwnershipBadge.style.display = 'none';
    }
  }
  if (swapCostBadge) {
    if (swapOwned === 0) {
      // Show cost badge only when not owned
      swapCostBadge.textContent = formatNumber(swapButtonCost);
      swapCostBadge.style.display = 'block';
      if (canAffordPowerup('swap')) {
        swapCostBadge.classList.remove('disabled');
      } else {
        swapCostBadge.classList.add('disabled');
      }
    } else {
      // Hide cost badge when owned
      swapCostBadge.style.display = 'none';
    }
  }
}

// Function to update powerup button visibility based on purchase history and affordability
function updatePowerupButtonVisibility() {
  const bombBtn = document.getElementById('bombConversionBtn');
  const trashBtn = document.getElementById('trashButton');
  const pickaxeBtn = document.getElementById('pickaxeButton');
  const swapBtn = document.getElementById('swapButton');
  
  // Track if any powerup was discovered for the first time in this update
  let anyPowerupDiscovered = false;
  
  // Show/hide buttons based on whether they've ever been purchased OR if they're currently purchasable
  // Use visibility instead of display to maintain layout positioning
  if (bombBtn) {
    const shouldShow = bombEverPurchased || bombDiscoveredThisGame || canAffordPowerup('bomb');
    if (shouldShow) {
      bombBtn.style.visibility = 'visible';
      bombBtn.style.opacity = '1';
      // Only set pointer-events to auto if button is not disabled
      if (!bombBtn.disabled) {
        bombBtn.style.pointerEvents = 'auto';
      }
      // Mark as discovered if it became visible due to affordability
      if (canAffordPowerup('bomb') && !bombDiscoveredThisGame) {
        bombDiscoveredThisGame = true;
        anyPowerupDiscovered = true;
      }
    } else {
      bombBtn.style.visibility = 'hidden';
      bombBtn.style.pointerEvents = 'none';
      bombBtn.style.opacity = '0';
    }
  }
  if (trashBtn) {
    const shouldShow = trashEverPurchased || trashDiscoveredThisGame || canAffordPowerup('trash');
    if (shouldShow) {
      trashBtn.style.visibility = 'visible';
      trashBtn.style.opacity = '1';
      // Only set pointer-events to auto if button is not disabled
      if (!trashBtn.disabled) {
        trashBtn.style.pointerEvents = 'auto';
      }
      // Mark as discovered if it became visible due to affordability
      if (canAffordPowerup('trash') && !trashDiscoveredThisGame) {
        trashDiscoveredThisGame = true;
        anyPowerupDiscovered = true;
      }
    } else {
      trashBtn.style.visibility = 'hidden';
      trashBtn.style.pointerEvents = 'none';
      trashBtn.style.opacity = '0';
    }
  }
  if (pickaxeBtn) {
    const shouldShow = pickaxeEverPurchased || pickaxeDiscoveredThisGame || canAffordPowerup('pickaxe');
    if (shouldShow) {
      pickaxeBtn.style.visibility = 'visible';
      pickaxeBtn.style.opacity = '1';
      // Only set pointer-events to auto if button is not disabled
      if (!pickaxeBtn.disabled) {
        pickaxeBtn.style.pointerEvents = 'auto';
      }
      // Mark as discovered if it became visible due to affordability
      if (canAffordPowerup('pickaxe') && !pickaxeDiscoveredThisGame) {
        pickaxeDiscoveredThisGame = true;
        anyPowerupDiscovered = true;
      }
    } else {
      pickaxeBtn.style.visibility = 'hidden';
      pickaxeBtn.style.pointerEvents = 'none';
      pickaxeBtn.style.opacity = '0';
    }
  }
  if (swapBtn) {
    const shouldShow = swapEverPurchased || swapDiscoveredThisGame || canAffordPowerup('swap');
    if (shouldShow) {
      swapBtn.style.visibility = 'visible';
      swapBtn.style.opacity = '1';
      // Only set pointer-events to auto if button is not disabled
      if (!swapBtn.disabled) {
        swapBtn.style.pointerEvents = 'auto';
      }
      // Mark as discovered if it became visible due to affordability
      if (canAffordPowerup('swap') && !swapDiscoveredThisGame) {
        swapDiscoveredThisGame = true;
        anyPowerupDiscovered = true;
      }
    } else {
      swapBtn.style.visibility = 'hidden';
      swapBtn.style.pointerEvents = 'none';
      swapBtn.style.opacity = '0';
    }
  }
  
  // Play item unlock sound if any powerup was discovered for the first time
  if (anyPowerupDiscovered && soundManager && soundManager.canPlayAudio()) {
    soundManager.playItemUnlockSound();
  }
}





// Function to update shop display with current owned quantities and costs
function updateShopDisplay() {
  const bombOwnedCount = document.getElementById('bombOwnedCount');
  const trashOwnedCount = document.getElementById('trashOwnedCount');
  const pickaxeOwnedCount = document.getElementById('pickaxeOwnedCount');
  const swapOwnedCount = document.getElementById('swapOwnedCount');
  const shopBombCost = document.getElementById('shopBombCost');
  const shopTrashCost = document.getElementById('shopTrashCost');
  const shopPickaxeCost = document.getElementById('shopPickaxeCost');
  const shopSwapCost = document.getElementById('shopSwapCost');
  
  const shopBombOwnershipBadge = document.getElementById('shopBombOwnershipBadge');
  const shopTrashOwnershipBadge = document.getElementById('shopTrashOwnershipBadge');
  const shopPickaxeOwnershipBadge = document.getElementById('shopPickaxeOwnershipBadge');
  const shopSwapOwnershipBadge = document.getElementById('shopSwapOwnershipBadge');
  
  if (shopBombOwnershipBadge) {
    if (bombOwned > 0) {
      shopBombOwnershipBadge.textContent = bombOwned;
      shopBombOwnershipBadge.style.display = 'block';
      updateBadgeColor(shopBombOwnershipBadge, bombOwned);
    } else {
      shopBombOwnershipBadge.style.display = 'none';
    }
  }
  if (shopTrashOwnershipBadge) {
    if (trashOwned > 0) {
      shopTrashOwnershipBadge.textContent = trashOwned;
      shopTrashOwnershipBadge.style.display = 'block';
      updateBadgeColor(shopTrashOwnershipBadge, trashOwned);
    } else {
      shopTrashOwnershipBadge.style.display = 'none';
    }
  }
  if (shopPickaxeOwnershipBadge) {
    if (pickaxeOwned > 0) {
      shopPickaxeOwnershipBadge.textContent = pickaxeOwned;
      shopPickaxeOwnershipBadge.style.display = 'block';
      updateBadgeColor(shopPickaxeOwnershipBadge, pickaxeOwned);
    } else {
      shopPickaxeOwnershipBadge.style.display = 'none';
    }
  }
  if (shopSwapOwnershipBadge) {
    if (swapOwned > 0) {
      shopSwapOwnershipBadge.textContent = swapOwned;
      shopSwapOwnershipBadge.style.display = 'block';
      updateBadgeColor(shopSwapOwnershipBadge, swapOwned);
    } else {
      shopSwapOwnershipBadge.style.display = 'none';
    }
  }
  
  // Also update the powerup ownership badges
  updatePowerupOwnershipBadges();
  
  if (shopBombCost) {
    shopBombCost.textContent = formatNumber(bombConversionCost);
  }
  if (shopTrashCost) {
    shopTrashCost.textContent = formatNumber(trashButtonCost);
  }
  if (shopPickaxeCost) {
    shopPickaxeCost.textContent = formatNumber(pickaxeButtonCost);
  }
  if (shopSwapCost) {
    shopSwapCost.textContent = formatNumber(swapButtonCost);
  }
  
  // Update button affordability
  updateShopButtonAffordability();
}

// Function to update shop button affordability
function updateShopButtonAffordability() {
  const shopBombBtn = document.getElementById('shopBombBtn');
  const shopTrashBtn = document.getElementById('shopTrashBtn');
  const shopPickaxeBtn = document.getElementById('shopPickaxeBtn');
  const shopSwapBtn = document.getElementById('shopSwapBtn');
  
  if (shopBombBtn) {
    const canAfford = gold >= bombConversionCost;
    shopBombBtn.disabled = !canAfford;
  }
  
  if (shopTrashBtn) {
    const canAfford = gold >= trashButtonCost;
    shopTrashBtn.disabled = !canAfford;
  }
  
  if (shopPickaxeBtn) {
    const canAfford = gold >= pickaxeButtonCost;
    shopPickaxeBtn.disabled = !canAfford;
  }
  
  if (shopSwapBtn) {
    const canAfford = gold >= swapButtonCost;
    shopSwapBtn.disabled = !canAfford;
  }
}

// Function to trigger shop gold display shrinking animation
function triggerShopGoldShrink() {
  const shopGoldValue = document.getElementById('shopGoldDisplay');
  if (shopGoldValue) {
    shopGoldValue.classList.add('shrink');
    setTimeout(() => {
      shopGoldValue.classList.remove('shrink');
    }, 300);
  }
}

// Function to show gold lost animation in item shop
function showShopGoldLost(amount) {
  // Create the gold lost display element
  const goldLostEl = document.createElement('div');
  goldLostEl.className = 'gold-lost';
  goldLostEl.textContent = `-${formatNumber(amount)}`;
  
  // Position it relative to the shop gold display
  const shopGoldDisplay = document.getElementById('shopGoldDisplay');
  if (shopGoldDisplay) {
    const rect = shopGoldDisplay.getBoundingClientRect();
    
    // First, add the element to the DOM temporarily to measure its width
    document.body.appendChild(goldLostEl);
    const textWidth = goldLostEl.offsetWidth;
    
    // Calculate the desired position (2px right of shop gold display right edge)
    let desiredLeft = rect.right + 2;
    
    // Check if the text would be cut off by the right edge of the screen
    const screenRight = window.innerWidth;
    const textRightEdge = desiredLeft + textWidth;
    
    // If text would be cut off, adjust position to the left
    if (textRightEdge > screenRight - 10) { // Leave 10px margin from screen edge
      desiredLeft = screenRight - 10 - textWidth;
    }
    
    // Ensure we don't go too far left (keep it within reasonable bounds)
    const minLeft = Math.max(0, rect.left - 20); // Don't go more than 20px left of the gold display, and never go off-screen left
    if (desiredLeft < minLeft) {
      desiredLeft = minLeft;
    }
    
    // Position the element so its left edge starts at desiredLeft
    goldLostEl.style.left = desiredLeft + 'px';
    goldLostEl.style.top = (rect.top + 5) + 'px';
  } else {
    // Fallback positioning if shop gold display not found
    goldLostEl.style.left = '50%';
    goldLostEl.style.top = '50%';
    goldLostEl.style.transform = 'translate(-50%, -50%)';
  }
  
  // Remove after animation completes
  setTimeout(() => {
    if (goldLostEl.parentNode) {
      goldLostEl.parentNode.removeChild(goldLostEl);
    }
  }, 1200);
}

// Function to show gold lost animation relative to main gold display
function showMainGoldLost(amount) {
  // Create the gold lost display element
  const goldLostEl = document.createElement('div');
  goldLostEl.className = 'gold-lost';
  goldLostEl.textContent = `-${formatNumber(amount)}`;
  
  // Position it relative to the main gold display
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    const rect = goldDisplay.getBoundingClientRect();
    
    // First, add the element to the DOM temporarily to measure its width
    document.body.appendChild(goldLostEl);
    const textWidth = goldLostEl.offsetWidth;
    
    // Calculate the desired position (2px right of main gold display right edge)
    let desiredLeft = rect.right + 2;
    
    // Check if the text would be cut off by the right edge of the screen
    const screenRight = window.innerWidth;
    const textRightEdge = desiredLeft + textWidth;
    
    // If text would be cut off, adjust position to the left
    if (textRightEdge > screenRight - 10) { // Leave 10px margin from screen edge
      desiredLeft = screenRight - 10 - textWidth;
    }
    
    // Ensure we don't go too far left (keep it within reasonable bounds)
    const minLeft = Math.max(0, rect.left - 20); // Don't go more than 20px left of the gold display, and never go off-screen left
    if (desiredLeft < minLeft) {
      desiredLeft = minLeft;
    }
    
    // Position the element so its left edge starts at desiredLeft
    goldLostEl.style.left = desiredLeft + 'px';
    goldLostEl.style.top = (rect.top + 5) + 'px';
  } else {
    // Fallback positioning if main gold display not found
    goldLostEl.style.left = '50%';
    goldLostEl.style.top = '50%';
    goldLostEl.style.transform = 'translate(-50%, -50%)';
  }
  
  // Remove after animation completes
  setTimeout(() => {
    if (goldLostEl.parentNode) {
      goldLostEl.parentNode.removeChild(goldLostEl);
    }
  }, 1200);
}

// Shop purchase functions
function purchaseBomb(fromShop = true) {
  if (gold >= bombConversionCost) {
    const cost = bombConversionCost;
    gold -= cost;
    bombOwned++;
    bombEverPurchased = true; // Mark as ever purchased

    lifetimeItemsPurchased++; // Track total items purchased
    bombConversionCost *= 2; // Double the cost
    updateGoldDisplay();
    updatePowerupOwnershipBadges();
    updateShopDisplay();
    updateBombConversionButtonState();
    updateAllPowerupButtonStates(); // Update all button states after gold change
    updatePowerupButtonVisibility(); // Show the button in the grid

    saveGameState();
    soundManager.playPurchaseSound();
    
    // Show appropriate gold lost animation based on where purchase came from
    if (fromShop) {
      triggerShopGoldShrink();
      showShopGoldLost(cost);
      // Trigger badge animation for shop bomb badge
      triggerBadgeAnimation('shopBombOwnershipBadge');
    } else {
      showMainGoldLost(cost);
    }
  }
}

function purchaseTrash(fromShop = true) {
  if (gold >= trashButtonCost) {
    const cost = trashButtonCost;
    gold -= cost;
    trashOwned++;
    trashEverPurchased = true; // Mark as ever purchased

    lifetimeItemsPurchased++; // Track total items purchased
    trashButtonCost *= 2; // Double the cost
    updateGoldDisplay();
    updatePowerupOwnershipBadges();
    updateShopDisplay();
    updateTrashButtonState();
    updateAllPowerupButtonStates(); // Update all button states after gold change
    updatePowerupButtonVisibility(); // Show the button in the grid

    saveGameState();
    soundManager.playPurchaseSound();
    
    // Show appropriate gold lost animation based on where purchase came from
    if (fromShop) {
      triggerShopGoldShrink();
      showShopGoldLost(cost);
      // Trigger badge animation for shop trash badge
      triggerBadgeAnimation('shopTrashOwnershipBadge');
    } else {
      showMainGoldLost(cost);
    }
  }
}

function purchasePickaxe(fromShop = true) {
  if (gold >= pickaxeButtonCost) {
    const cost = pickaxeButtonCost;
    gold -= cost;
    pickaxeOwned++;
    pickaxeEverPurchased = true; // Mark as ever purchased

    lifetimeItemsPurchased++; // Track total items purchased
    pickaxeButtonCost *= 10; // Multiply cost by 10x
    updateGoldDisplay();
    updatePowerupOwnershipBadges();
    updateShopDisplay();
    updatePickaxeButtonState();
    updateAllPowerupButtonStates(); // Update all button states after gold change
    updatePowerupButtonVisibility(); // Show the button in the grid

    saveGameState();
    soundManager.playPurchaseSound();
    
    // Show appropriate gold lost animation based on where purchase came from
    if (fromShop) {
      triggerShopGoldShrink();
      showShopGoldLost(cost);
      // Trigger badge animation for shop pickaxe badge
      triggerBadgeAnimation('shopPickaxeOwnershipBadge');
    } else {
      showMainGoldLost(cost);
    }
  }
}

function purchaseSwap(fromShop = true) {
  if (gold >= swapButtonCost) {
    const cost = swapButtonCost;
    gold -= cost;
    swapOwned++;
    swapEverPurchased = true; // Mark as ever purchased

    lifetimeItemsPurchased++; // Track total items purchased
    swapButtonCost *= 2; // Double the cost
    updateGoldDisplay();
    updatePowerupOwnershipBadges();
    updateShopDisplay();
    updateSwapButtonState();
    updateAllPowerupButtonStates(); // Update all button states after gold change
    updatePowerupButtonVisibility(); // Show the button in the grid

    saveGameState();
    soundManager.playPurchaseSound();
    
    // Show appropriate gold lost animation based on where purchase came from
    if (fromShop) {
      triggerShopGoldShrink();
      showShopGoldLost(cost);
      // Trigger badge animation for shop swap badge
      triggerBadgeAnimation('shopSwapOwnershipBadge');
    } else {
      showMainGoldLost(cost);
    }
  }
}

// Update the openShop function to refresh the display
function openShop() {
  updateShopDisplay();
  // Also update powerup button states to reflect owned quantities
  updateBombConversionButtonState();
  updateTrashButtonState();
  updatePickaxeButtonState();
  updateSwapButtonState();
  // Update powerup ownership badges
  updatePowerupOwnershipBadges();
  shopModal.classList.remove('hidden');
}

// Add event listeners for shop purchase buttons
const shopBombBtn = document.getElementById('shopBombBtn');
const shopTrashBtn = document.getElementById('shopTrashBtn');
const shopPickaxeBtn = document.getElementById('shopPickaxeBtn');
const shopSwapBtn = document.getElementById('shopSwapBtn');

if (shopBombBtn) {
  shopBombBtn.addEventListener('click', purchaseBomb);
}

if (shopTrashBtn) {
  shopTrashBtn.addEventListener('click', purchaseTrash);
}

if (shopPickaxeBtn) {
  shopPickaxeBtn.addEventListener('click', purchasePickaxe);
}

if (shopSwapBtn) {
  shopSwapBtn.addEventListener('click', purchaseSwap);
}

// Powerup tooltip functionality
const powerupTooltipModal = document.getElementById('powerupTooltipModal');
const powerupTooltipClose = document.getElementById('powerupTooltipClose');
const powerupTooltipEmoji = document.getElementById('powerupTooltipEmoji');
const powerupTooltipTitle = document.getElementById('powerupTooltipTitle');
const powerupTooltipDescription = document.getElementById('powerupTooltipDescription');
const powerupTooltipUsage = document.getElementById('powerupTooltipUsage');

// Powerup descriptions data
const powerupDescriptions = {
  bomb: {
    emoji: '💣',
    title: 'Bomb',
    description: 'Converts the next block to a bomb block.',
    usage: 'When a bomb block merges with a block of the same value, it destroys the entire stack.'
  },
  trash: {
    emoji: '🗑️',
    title: 'Trash Can',
    description: 'Removes the next block from the queue.',
    usage: 'Click on the trash can to immediately remove the next block.'
  },
  swap: {
    emoji: '🔄',
    title: 'Swap',
    description: 'Swaps the next two blocks in the queue.',
    usage: 'Click on the swap item to immediately swap the next two blocks.'
  },
  pickaxe: {
    emoji: '⛏️',
    title: 'Pickaxe',
    description: 'Removes any single block from any stack.',
    usage: 'Click on the pickaxe, then click on a block to remove it.'
  }
};

// Function to show powerup tooltip
function showPowerupTooltip(powerupType) {
  const powerup = powerupDescriptions[powerupType];
  if (!powerup) return;
  
  powerupTooltipEmoji.textContent = powerup.emoji;
  powerupTooltipTitle.textContent = powerup.title;
  powerupTooltipDescription.textContent = powerup.description;
  powerupTooltipUsage.textContent = powerup.usage;
  
  powerupTooltipModal.classList.remove('hidden');
}

// Function to hide powerup tooltip
function hidePowerupTooltip() {
  powerupTooltipModal.classList.add('hidden');
}

// Event listeners for powerup tooltip
if (powerupTooltipClose) {
  powerupTooltipClose.addEventListener('click', hidePowerupTooltip);
}

// Close tooltip when clicking backdrop
if (powerupTooltipModal) {
  powerupTooltipModal.addEventListener('click', (e) => {
    if (e.target === powerupTooltipModal) {
      hidePowerupTooltip();
    }
  });
}

// Event listeners for fake powerup buttons in shop
const shopBombPowerupBtn = document.getElementById('shopBombPowerupBtn');
const shopTrashPowerupBtn = document.getElementById('shopTrashPowerupBtn');
const shopSwapPowerupBtn = document.getElementById('shopSwapPowerupBtn');
const shopPickaxePowerupBtn = document.getElementById('shopPickaxePowerupBtn');

if (shopBombPowerupBtn) {
  shopBombPowerupBtn.addEventListener('click', () => showPowerupTooltip('bomb'));
}

if (shopTrashPowerupBtn) {
  shopTrashPowerupBtn.addEventListener('click', () => showPowerupTooltip('trash'));
}

if (shopSwapPowerupBtn) {
  shopSwapPowerupBtn.addEventListener('click', () => showPowerupTooltip('swap'));
}

if (shopPickaxePowerupBtn) {
  shopPickaxePowerupBtn.addEventListener('click', () => showPowerupTooltip('pickaxe'));
}

// Reset Local Data button event listener
const resetDataBtn = document.getElementById('resetDataBtn');
if (resetDataBtn) {
  resetDataBtn.addEventListener('click', () => {
    if (confirm('Are you sure you want to clear all data? This will delete all player statistics and settings.')) {
      clearAllGameData();
      closeHelp(); // Close the help modal
      

    }
  });
}

if (helpModal) {
  helpModal.addEventListener('click', (e) => { if (e.target === helpModal) closeHelp(); });
}

// Statistics modal DOM refs and functionality
const showStatsBtn = document.getElementById('showStatsBtn');
const statsModal = document.getElementById('statsModal');

// Function to update statistics modal
function updateStatsModal() {
  const statsHighScore = document.getElementById('statsHighScore');
  const statsLifetimeGold = document.getElementById('statsLifetimeGold');
  const statsTotalBlocksDropped = document.getElementById('statsTotalBlocksDropped');
  const statsTotalBombsExploded = document.getElementById('statsTotalBombsExploded');
  const statsTotalBlocksTrashed = document.getElementById('statsTotalBlocksTrashed');
  const statsTotalBlocksMined = document.getElementById('statsTotalBlocksMined');
  const statsTotalSwapsUsed = document.getElementById('statsTotalSwapsUsed');
  const statsLifetimeItemsPurchased = document.getElementById('statsLifetimeItemsPurchased');
  
  if (statsHighScore) {
    statsHighScore.innerHTML = formatScore(window.highScore || 0);
  }
  
  if (statsLifetimeGold) {
    statsLifetimeGold.textContent = formatNumber(lifetimeGoldEarned || 0);
  }
  
  if (statsTotalBlocksDropped) {
    statsTotalBlocksDropped.textContent = formatNumber(totalBlocksDropped || 0);
  }
  
  if (statsTotalBombsExploded) {
    statsTotalBombsExploded.textContent = formatNumber(totalBombsExploded || 0);
  }
  
  if (statsTotalBlocksTrashed) {
    statsTotalBlocksTrashed.textContent = formatNumber(totalBlocksTrashed || 0);
  }
  
  if (statsTotalBlocksMined) {
    statsTotalBlocksMined.textContent = formatNumber(totalBlocksMined || 0);
  }
  
  if (statsTotalSwapsUsed) {
    statsTotalSwapsUsed.textContent = formatNumber(totalSwapsUsed || 0);
  }
  
  if (statsLifetimeItemsPurchased) {
    statsLifetimeItemsPurchased.textContent = formatNumber(lifetimeItemsPurchased || 0);
  }
}

// Function to open statistics modal
function openStats() {
  statsModal.classList.remove('hidden');
  updateStatsModal();
}

// Function to close statistics modal
function closeStats() {
  statsModal.classList.add('hidden');
}

// Statistics modal event listeners
if (showStatsBtn) {
  showStatsBtn.addEventListener('click', openStats);
}

if (statsModal) {
  statsModal.addEventListener('click', (e) => { if (e.target === statsModal) closeStats(); });
}

// Sound button event listener
if (soundBtn) {
        soundBtn.addEventListener('click', () => {

        openSoundControlModal();
      });
}

// Settings button event listener
const settingsBtn = document.getElementById('settingsBtn');
if (settingsBtn) {
  settingsBtn.addEventListener('click', () => {
    // Remove the glow effect when settings is opened
    settingsBtn.classList.remove('settings-glow');
    openSettingsModal();
  });
}



// Set initial sound button state
if (soundBtn) {
  const isMuted = soundManager.getMuteState();
  soundBtn.textContent = isMuted ? '🔇' : '🔊';
  soundBtn.title = 'Sound Controls';
}
window.addEventListener('keydown', (e) => { 
  if (e.key === 'Escape' && helpModal && !helpModal.classList.contains('hidden')) {
    closeHelp();
  }
});

// Bomb conversion button event listener
if (bombConversionBtn) {
  bombConversionBtn.addEventListener('click', () => {

    handleBombConversion();
  });
  
  // Add touch events for mobile active state feedback
  bombConversionBtn.addEventListener('touchstart', () => {
    bombConversionBtn.classList.add('mobile-active');
  }, { passive: true });
  
  bombConversionBtn.addEventListener('touchend', () => {
    bombConversionBtn.classList.remove('mobile-active');
  }, { passive: true });
} else {
  console.error('❌ Bomb conversion button not found!');
}

// Trash button event listener
if (trashButton) {
  trashButton.addEventListener('click', () => {

    handleTrashButton();
  });
  
  // Add touch events for mobile active state feedback
  trashButton.addEventListener('touchstart', () => {
    trashButton.classList.add('mobile-active');
  }, { passive: true });
  
  trashButton.addEventListener('touchend', () => {
    trashButton.classList.remove('mobile-active');
  }, { passive: true });
} else {
  console.error('❌ Trash button not found!');
}

// Pickaxe button event listener
if (pickaxeButton) {
  pickaxeButton.addEventListener('click', () => {

    handlePickaxeButton();
  });
  
  // Add touch events for mobile active state feedback
  pickaxeButton.addEventListener('touchstart', () => {
    pickaxeButton.classList.add('mobile-active');
  }, { passive: true });
  
  pickaxeButton.addEventListener('touchend', () => {
    pickaxeButton.classList.remove('mobile-active');
  }, { passive: true });
} else {
  console.error('❌ Pickaxe button not found!');
}

// Swap button event listener
if (swapButton) {
  swapButton.addEventListener('click', () => {

    handleSwapButton();
  });
  
  // Add touch events for mobile active state feedback
  swapButton.addEventListener('touchstart', () => {
    swapButton.classList.add('mobile-active');
  }, { passive: true });
  
  swapButton.addEventListener('touchend', () => {
    swapButton.classList.remove('mobile-active');
  }, { passive: true });
} else {
  console.error('❌ Swap button not found!');
}

// Game over popup - any click anywhere closes it
const gameOverButton = document.getElementById('gameOverButton');
if (gameOverButton) {
  // Add click listener to the document to close game over popup on any click
  document.addEventListener('click', () => {
    if (gameOverButton.classList.contains('show')) {
      gameOverButton.classList.remove('show');
    }
  });
}

// Global user interaction detection for universal audio compatibility
document.addEventListener('click', () => {
  if (soundManager && !soundManager.audioUnlocked) {
    soundManager.unlockAudio();
  }
});

// Touch event detection for mobile devices
document.addEventListener('touchstart', () => {
  if (soundManager && !soundManager.audioUnlocked) {
    soundManager.unlockAudio();
  }
}, { passive: true });

// Add button event listener for new game
const addBtn = document.getElementById('addBtn');
if (addBtn) {
  addBtn.addEventListener('click', () => {

    openNewGameModal();
  });
}

// New game modal button event listeners
const confirmNewGameBtn = document.getElementById('confirmNewGameBtn');
if (confirmNewGameBtn) {
  confirmNewGameBtn.addEventListener('click', () => {

    handleNewGameConfirmation();
  });
}

const cancelNewGameBtn = document.getElementById('cancelNewGameBtn');
if (cancelNewGameBtn) {
  cancelNewGameBtn.addEventListener('click', handleNewGameCancel);
}

// Close new game modal when clicking outside
const newGameModal = document.getElementById('newGameModal');
if (newGameModal) {
  newGameModal.addEventListener('click', (e) => {
    if (e.target === newGameModal) {
      closeNewGameModal();
    }
  });
}

// Close new game modal with Escape key
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && newGameModal && !newGameModal.classList.contains('hidden')) {
    closeNewGameModal();
  }
});

// Settings Modal Functions
function openSettingsModal() {
  const modal = document.getElementById('settingsModal');
  if (modal) {
    modal.classList.remove('hidden');
    
    // Force update theme selectors when settings modal is opened
    if (typeof updateThemeSelectors === 'function') {
      setTimeout(() => {
        updateThemeSelectors();
      }, 50);
    }
  }
}

function closeSettingsModal() {
  const modal = document.getElementById('settingsModal');
  if (modal) {
    modal.classList.add('hidden');
  }
  
  // Only remove the glow effect if no new themes were unlocked
  // (This prevents the glow from being removed when a theme is unlocked)
  const settingsBtn = document.getElementById('settingsBtn');
  if (settingsBtn && !window.themeJustUnlocked) {
    settingsBtn.classList.remove('settings-glow');
  }
  
  // Reset the flag
  window.themeJustUnlocked = false;
}

function initializeSettingsModal() {
  // Settings close button
  const closeBtn = document.getElementById('settingsClose');
  if (closeBtn) {
    closeBtn.addEventListener('click', closeSettingsModal);
  }
  
  // Close modal when clicking outside
  const modal = document.getElementById('settingsModal');
  if (modal) {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeSettingsModal();
      }
    });
  }
  
  // Close modal with Escape key
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal && !modal.classList.contains('hidden')) {
      closeSettingsModal();
    }
  });
  
  // Theme selector
  const themeSelector = document.getElementById('themeSelector');
  if (themeSelector) {
    // Set initial value
    themeSelector.value = themeManager.getCurrentTheme();
    
    // Add change event listener
    themeSelector.addEventListener('change', (e) => {
      const selectedTheme = e.target.value;
      
      // Check if theme is unlocked
      if (!themeManager.isThemeUnlocked(selectedTheme)) {
        // Show locked theme message
        showLockedThemeMessage(selectedTheme, themeManager.getThemeRequirement(selectedTheme));
        // Reset selector to current theme
        e.target.value = themeManager.getCurrentTheme();
        return;
      }
      
      const success = themeManager.applyTheme(selectedTheme);
      if (success) {
        // Update help guide colors if help modal is open
        if (helpModal && !helpModal.classList.contains('hidden')) {
          updateHelpGuideColors();
        }
      }
    });
  }
  

}



// Code entry handler
function handleCodeEntry(code) {
  // No codes currently available
  return false;
}



// Sound Control Modal Functions
function openSoundControlModal() {
  const modal = document.getElementById('soundControlModal');
  if (modal) {
    // Update UI with current sound settings
    updateSoundControlUI();
    
    modal.classList.remove('hidden');
  }
}

function closeSoundControlModal() {
  const modal = document.getElementById('soundControlModal');
  if (modal) {
    modal.classList.add('hidden');
  }
}

function updateSoundControlUI() {
  // Update master mute button
  const masterMuteBtn = document.getElementById('masterMuteBtn');
  if (masterMuteBtn) {
    const isMuted = soundManager.getMuteState();
    masterMuteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
    masterMuteBtn.classList.toggle('muted', isMuted);
  }
  
  // Update volume sliders and values using the dedicated function
  updateVolumeSliders();
}

function initializeSoundControlModal() {
  // Master mute button
  const masterMuteBtn = document.getElementById('masterMuteBtn');
  if (masterMuteBtn) {
    // Initialize master mute button state
    const isMuted = soundManager.isMuted;
    masterMuteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
    masterMuteBtn.classList.toggle('muted', isMuted);
    
    masterMuteBtn.addEventListener('click', () => {

      const isMuted = soundManager.toggleMute();
      masterMuteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
      masterMuteBtn.classList.toggle('muted', isMuted);
      
      // Update sound button in title bar
      const soundBtn = document.getElementById('soundBtn');
      if (soundBtn) {
        soundBtn.textContent = isMuted ? '🔇' : '🔊';
        soundBtn.title = 'Sound Controls';
      }
      
      // Save game state to cookies to persist the mute change
      saveGameState();
    });
  }
  
  // Volume sliders
  const soundTypes = ['drop', 'merge', 'coin', 'bomb', 'other'];
  soundTypes.forEach(soundType => {
    const slider = document.getElementById(`${soundType}VolumeSlider`);
    const value = document.getElementById(`${soundType}VolumeValue`);
    
    if (slider && value) {
      // Initialize slider and value display with current volume from sound manager
      const currentVolume = soundManager.getSoundVolume(soundType);
      slider.value = currentVolume;
      value.textContent = currentVolume;
      
      slider.addEventListener('input', (e) => {

        const newVolume = parseInt(e.target.value);
        soundManager.setSoundVolume(soundType, newVolume);
        value.textContent = newVolume;
        
        // Save game state to cookies to persist the volume change
        saveGameState();
      });
      
      // Play test sound only when slider is released (change event)
      slider.addEventListener('change', (e) => {
        const finalVolume = parseInt(e.target.value);
        

        
        // Test the volume change only when slider is released
        testVolumeChange(soundType, finalVolume);
      });
    }
  });
  
  // Close button
  const closeBtn = document.getElementById('soundControlClose');
  if (closeBtn) {
    closeBtn.addEventListener('click', closeSoundControlModal);
  }
  

  

  
  // Close modal when clicking outside
  const modal = document.getElementById('soundControlModal');
  if (modal) {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeSoundControlModal();
      }
    });
  }
  
  // Close modal with Escape key
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal && !modal.classList.contains('hidden')) {
      closeSoundControlModal();
    }
  });
}

// Function to update volume sliders with current values
function updateVolumeSliders() {
  const soundTypes = ['drop', 'merge', 'coin', 'bomb', 'other'];
  soundTypes.forEach(soundType => {
    const slider = document.getElementById(`${soundType}VolumeSlider`);
    const value = document.getElementById(`${soundType}VolumeValue`);
    
    if (slider && value) {
      const currentVolume = soundManager.getSoundVolume(soundType);
      slider.value = currentVolume;
      value.textContent = currentVolume;
    } else {
      console.warn(`⚠️ Missing elements for ${soundType}: slider=${!!slider}, value=${!!value}`);
    }
  });
}

// Initialize button states

try {
  updateBombConversionButtonState();
} catch (error) {
  console.error('❌ Error initializing bomb conversion button state:', error);
}

try {
  updateTrashButtonState();
} catch (error) {
  console.error('❌ Error initializing trash button state:', error);
}

try {
  updatePickaxeButtonState();
} catch (error) {
  console.error('❌ Error initializing pickaxe button state:', error);
}

// Initialize cost displays
if (bombCostEl) {
  bombCostEl.textContent = formatNumber(bombConversionCost);
}
if (trashCostEl) {
  trashCostEl.textContent = formatNumber(trashButtonCost);
}
if (pickaxeCostEl) {
  pickaxeCostEl.textContent = formatNumber(pickaxeButtonCost);
}

// Debug button wiring
if (debugBtn) {
  debugBtn.addEventListener('click', openDebugPane);
}

// Initialize debug button visibility based on environment
document.addEventListener('DOMContentLoaded', () => {
  const debugBtn = document.getElementById('debugBtn');
  
  if (debugBtn) {
    if (isDevelopment()) {
      debugBtn.style.display = 'block';
    } else {
      debugBtn.style.display = 'none';
    }
  }
  
  // Initialize sound control modal after DOM is loaded
  initializeSoundControlModal();
  
  // Initialize settings modal after DOM is loaded
  initializeSettingsModal();
  
  // Set up debug pane event listeners after DOM is loaded
  if (debugClose) {
    debugClose.addEventListener('click', closeDebugPane);
    // Add touch event for mobile devices
    debugClose.addEventListener('touchend', (e) => {
      e.preventDefault(); // Prevent default touch behavior
      closeDebugPane();
    });
  }
  if (debugPane) {
    // Removed problematic event listeners that were causing unexpected closing
    // Debug pane now only closes via X button or Escape key
  }
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && debugPane && debugPane.classList.contains('show')) closeDebugPane(); });
  
  // Force scroll to top immediately when DOM is ready
  
  // Try to clear any stored scroll position
  try {
    if (window.history && window.history.scrollRestoration) {
      window.history.scrollRestoration = 'manual';
    }
  } catch (e) {
    // Could not disable scroll restoration
  }
  
  window.scrollTo(0, 0);
  if (window.visualViewport) {
    window.visualViewport.scrollTop = 0;
  }
});

// Test function to verify volume changes are working
function testVolumeChange(soundType, volume) {
  // Get the actual volume value that would be used
  const actualVolume = soundManager.getActualVolume(soundType);
  
  // Test playing a sound if the volume is not 0
  if (actualVolume > 0) {
    // Play a test sound based on the sound type
    switch (soundType) {
      case 'drop':
        soundManager.playDropSound(1);
        break;
      case 'merge':
        soundManager.playMergeSound(2);
        break;
      case 'coin':
        soundManager.playCoinSound();
        break;
      case 'bomb':
        soundManager.playBombSound();
        break;
      case 'other':
        soundManager.playNewGameSound();
        break;
    }
  }
}



function toggleAI(enable){
  if(enable === aiEnabled) return;
  aiEnabled = enable;
  

  

  
  if(aiEnabled){
    // start AI interval
    if(aiInterval) clearInterval(aiInterval);
    // make an immediate move then interval
    aiStep();
    // Set up the initial interval with default speed
    aiInterval = setInterval(aiStep, 1000);
  } else {
    if(aiInterval) clearInterval(aiInterval);
    aiInterval = null;
    

  }
}







function updateStackHeight() {
  // Stack height is now fixed at MAX_HEIGHT (10) - no more dynamic reduction
  // Base height varies by screen size for mobile responsiveness
  // Each slot needs: disc height + margin-top
  // 10 slots need: (disc height + margin) × 10 + pole padding
  let baseHeight = 542; // Desktop: 42px disc + 9px margin = 51px per slot, 10 slots = 510px + 32px padding = 542px
  
  // Check if we're on mobile and adjust height accordingly
  if (window.innerWidth <= 480) {
    // Extra small mobile: 26px disc + 4px margin = 30px per slot
    // 10 slots: 30px × 10 = 300px + 16px padding (8px top + 8px bottom) = 316px
    baseHeight = 316;
  } else if (window.innerWidth <= 768) {
    // Regular mobile: 30px disc + 6px margin = 36px per slot  
    // 10 slots: 36px × 10 = 360px + 24px padding (12px top + 12px bottom) = 384px
    baseHeight = 384;
  }
  
  // Update CSS custom property for stack height
  document.documentElement.style.setProperty('--stack-height', baseHeight + 'px');
}

function updateDebugPane() {
  if (debugScore) debugScore.innerHTML = formatScore(score);
  if (debugGold) debugGold.textContent = gold;
  if (debugStacks) debugStacks.textContent = poles.length;
  if (debugCapacity) debugCapacity.textContent = currentStackCapacity;
  if (debugTarget) debugTarget.textContent = currentTargetBlockSize * 2;
  if (debugMaxBlock) debugMaxBlock.textContent = Math.max(...weights);
                if (debugBlocksDropped) debugBlocksDropped.textContent = blocksDropped;
        if (debugTotalBlocksDropped) debugTotalBlocksDropped.textContent = totalBlocksDropped;
        if (debugTotalBombsExploded) debugTotalBombsExploded.textContent = totalBombsExploded;
        if (debugTotalBlocksTrashed) debugTotalBlocksTrashed.textContent = totalBlocksTrashed;
        if (debugTotalBlocksMined) debugTotalBlocksMined.textContent = totalBlocksMined;
        if (debugTotalSwapsUsed) debugTotalSwapsUsed.textContent = totalSwapsUsed;
        if (debugLifetimeItemsPurchased) debugLifetimeItemsPurchased.textContent = lifetimeItemsPurchased;
  if (debugBombStatus) debugBombStatus.textContent = blocksDropped >= BOMB_DELAY_BLOCKS ? 'Enabled' : 'Disabled';
  if (debugStage) debugStage.textContent = currentStage;
  
  // Update probabilities display
  updateDebugProbabilitiesDisplay();
}



// Debug pane wiring
function openDebugPane(){ 
  if (debugPane) {
    // Reset any fallback styles that might have been applied
    debugPane.style.display = '';
    debugPane.style.transform = '';
    debugPane.style.transition = '';
    
    debugPane.classList.add('show'); 
    syncDebugControls();
    
    // Reset the grant buttons to start with 1 each time
    resetGrantButtons();
    
    console.log('Debug pane opened');
  } else {
    console.log('Debug pane element not found when trying to open');
  }
}
function closeDebugPane(){ 
  console.log('closeDebugPane called');
  
  if (debugPane) {
    console.log('Debug pane found, hiding with display:none');
    
    // Simple and reliable: just hide it immediately
    debugPane.style.display = 'none';
    
    // Also remove the show class for consistency
    debugPane.classList.remove('show');
    
    console.log('Debug pane hidden successfully');
    
    // Keep custom block mode active when debug pane is closed
    // customBlockMode will only be reset when "No Block" is selected
  } else {
    console.log('Debug pane element not found');
  }
}

// New Game Modal Functions
function openNewGameModal() {
  const newGameModal = document.getElementById('newGameModal');
  if (newGameModal) {
    newGameModal.classList.remove('hidden');
  }
}

function closeNewGameModal() {
  const newGameModal = document.getElementById('newGameModal');
  if (newGameModal) {
    newGameModal.classList.add('hidden');
  }
}

function handleNewGameConfirmation() {
  closeNewGameModal();
  // Play new game sound effect when starting a new game
  soundManager.playNewGameSound();
  resetGame(true);
}

function handleNewGameCancel() {
  closeNewGameModal();
}

function syncDebugControls() {
  
  // Sync sound controls
  if (debugVolumeSlider) {
    debugVolumeSlider.value = Math.round(soundManager.getVolume() * 100);
  }
  updateDebugVolumeLabel();
  
  if (debugMuteToggle) {
    debugMuteToggle.checked = soundManager.getMuteState();
  }
  updateDebugMuteStatus();
  
  // Sync probability curve controls
  if (debugDecaySlider) {
    // Always show the current active decay factor
    debugDecaySlider.value = currentActiveDecayFactor;
    updateDebugDecayLabel(currentActiveDecayFactor);
  } else {
    updateDebugDecayLabel(currentActiveDecayFactor);
  }
  
  // Update probabilities display
  updateDebugProbabilitiesDisplay();
  
  // Set up event listeners for debug controls (only if they exist)
  if (debugVolumeSlider) {
    // Remove existing listeners to avoid duplicates
    debugVolumeSlider.removeEventListener('input', handleVolumeChange);
    debugVolumeSlider.addEventListener('input', handleVolumeChange);
  }
  
  if (debugMuteToggle) {
    // Remove existing listeners to avoid duplicates
    debugMuteToggle.removeEventListener('change', handleMuteToggle);
    debugMuteToggle.addEventListener('change', handleMuteToggle);
  }
  
  if (debugDecaySlider) {
    // Remove existing listeners to avoid duplicates
    debugDecaySlider.removeEventListener('input', handleDecayChange);
    debugDecaySlider.addEventListener('input', handleDecayChange);
  }
  
  if (debugUpdateProbBtn) {
    // Remove existing listeners to avoid duplicates
    debugUpdateProbBtn.removeEventListener('click', handleUpdateProbabilities);
    debugUpdateProbBtn.addEventListener('click', handleUpdateProbabilities);
  }
  

  
  // Set up test personal best button event listener
  const testPersonalBestBtn = document.getElementById('testPersonalBestBtn');
  if (testPersonalBestBtn) {
    // Remove existing listeners to avoid duplicates
    testPersonalBestBtn.removeEventListener('click', handleTestPersonalBest);
    testPersonalBestBtn.addEventListener('click', handleTestPersonalBest);
  }
  
  // Set up test game over button event listener
  const testGameOverBtn = document.getElementById('testGameOverBtn');
  if (testGameOverBtn) {
    // Remove existing listeners to avoid duplicates
    testGameOverBtn.removeEventListener('click', handleTestGameOver);
    testGameOverBtn.addEventListener('click', handleTestGameOver);
  }
  
  // Set up test unlock theme button event listener
  const testUnlockThemeBtn = document.getElementById('testUnlockThemeBtn');
  if (testUnlockThemeBtn) {
    // Remove existing listeners to avoid duplicates
    testUnlockThemeBtn.removeEventListener('click', handleTestUnlockTheme);
    testUnlockThemeBtn.addEventListener('click', handleTestUnlockTheme);
  }
  
  // Set up test lock theme button event listener
  const testLockThemeBtn = document.getElementById('testLockThemeBtn');
  if (testLockThemeBtn) {
    // Remove existing listeners to avoid duplicates
    testLockThemeBtn.removeEventListener('click', handleTestLockTheme);
    testLockThemeBtn.addEventListener('click', handleTestLockTheme);
  }
  
  // Set up debug button event listeners
  if (grantGoldBtn) {
    // Remove existing listeners to avoid duplicates
    grantGoldBtn.removeEventListener('click', handleGrantGold);
    grantGoldBtn.addEventListener('click', handleGrantGold);
  }
  
  if (grantScoreBtn) {
    // Remove existing listeners to avoid duplicates
    grantScoreBtn.removeEventListener('click', handleGrantScore);
    grantScoreBtn.addEventListener('click', handleGrantScore);
  }
  
  const checkCoinStatusBtn = document.getElementById('checkCoinStatusBtn');
  if (checkCoinStatusBtn) {
    // Remove existing listeners to avoid duplicates
    checkCoinStatusBtn.removeEventListener('click', handleCheckCoinStatus);
    checkCoinStatusBtn.addEventListener('click', handleCheckCoinStatus);
  }
  
  // Set up block grid interface event listeners
  document.querySelectorAll('.block-item').forEach(blockItem => {
    // Remove existing listeners to avoid duplicates
    blockItem.removeEventListener('click', () => handleBlockItemClick(blockItem));
    blockItem.addEventListener('click', () => handleBlockItemClick(blockItem));
  });
  
  // Set up bomb toggle event listener
  if (bombToggle) {
    // Remove existing listeners to avoid duplicates
    bombToggle.removeEventListener('change', handleBombToggle);
    bombToggle.addEventListener('change', handleBombToggle);
  }
  
  // Set up debug theme selector event listener
  const debugThemeSelector = document.getElementById('debugThemeSelector');
  if (debugThemeSelector) {
    // Remove existing listeners to avoid duplicates
    debugThemeSelector.removeEventListener('change', handleDebugThemeChange);
    debugThemeSelector.addEventListener('change', handleDebugThemeChange);
    
    // Set initial value
    debugThemeSelector.value = themeManager.getCurrentTheme();
  }
  
  // Set up powerup pricing debug button event listeners
  const debugPowerupPricingBtn = document.getElementById('debugPowerupPricingBtn');
  if (debugPowerupPricingBtn) {
    // Remove existing listeners to avoid duplicates
    debugPowerupPricingBtn.removeEventListener('click', handleDebugPowerupPricing);
    debugPowerupPricingBtn.addEventListener('click', handleDebugPowerupPricing);
  }
  
  const debugResetPowerupPricingBtn = document.getElementById('debugResetPowerupPricingBtn');
  if (debugResetPowerupPricingBtn) {
    // Remove existing listeners to avoid duplicates
    debugResetPowerupPricingBtn.removeEventListener('click', handleDebugResetPowerupPricing);
    debugResetPowerupPricingBtn.addEventListener('click', handleDebugResetPowerupPricing);
  }
  

}

// Debug pane controls will be set up in syncDebugControls()

// Debug button event listeners will be set up in syncDebugControls()

// Debug auto-play controls - will be set up in syncDebugControls()

// Event listener handler functions for debug controls
function handleVolumeChange(e) {
  const volume = parseInt(e.target.value) / 100;
  soundManager.setVolume(volume);
  updateDebugVolumeLabel();
}

function handleDebugThemeChange(e) {
  const selectedTheme = e.target.value;
  
  // Check if theme is unlocked
  if (!themeManager.isThemeUnlocked(selectedTheme)) {
    // Show locked theme message
    showLockedThemeMessage(selectedTheme, themeManager.getThemeRequirement(selectedTheme));
    // Reset selector to current theme
    e.target.value = themeManager.getCurrentTheme();
    return;
  }
  
  const success = themeManager.applyTheme(selectedTheme);
  if (success) {
    // Update help guide colors if help modal is open
    if (helpModal && !helpModal.classList.contains('hidden')) {
      updateHelpGuideColors();
    }
  }
}

function handleMuteToggle(e) {
  const isMuted = soundManager.toggleMute();
  updateDebugMuteStatus();
  // Update the main sound button to match
  const soundBtn = document.getElementById('soundBtn');
  if (soundBtn) {
    soundBtn.textContent = isMuted ? '🔇' : '🔊';
    soundBtn.title = isMuted ? 'Unmute sound' : 'Mute sound';
  }
}

function handleDecayChange(e) {
  const decayFactor = parseFloat(e.target.value);
  updateDebugDecayLabel(decayFactor);
}

function handleUpdateProbabilities() {
  const decayFactor = parseFloat(debugDecaySlider.value);
  updateProbabilityDistributionWithDecay(decayFactor);
}





function handleGrantGold() {
  // Get the current button text to determine the amount to add
  const button = document.getElementById('grantGoldBtn');
  let currentAmount = 1; // Start with 1
  
  if (button) {
    const buttonText = button.textContent;
    const match = buttonText.match(/Grant (\d+) Gold/);
    if (match) {
      currentAmount = parseInt(match[1]);
    }
  }
  
  // Add the current amount
  gold += currentAmount;
  goldEarnedThisGame += currentAmount; // Track gold earned in current game
  lifetimeGoldEarned += currentAmount; // Track lifetime gold earned
  
  // Double the amount for next time
  const nextAmount = currentAmount * 2;
  
  // Update button text
  if (button) {
    button.textContent = `Grant ${nextAmount} Gold`;
  }
  
  // Update gold display with pulse animation
  updateGoldDisplay(true);
  
  // Update statistics modal if it's open
  if (statsModal && !statsModal.classList.contains('hidden')) {
    updateStatsModal();
  }
  // Update all powerup button states when gold changes
  updateAllPowerupButtonsIfGoldChanged();
  
  // Play coin sound effect for earning gold
  soundManager.playCoinSound();
  
  // Save game state after granting gold
  saveGameState();
}

function resetGrantButtons() {
  // Reset both grant buttons to start with 1
  const scoreBtn = document.getElementById('grantScoreBtn');
  const goldBtn = document.getElementById('grantGoldBtn');
  
  if (scoreBtn) {
    scoreBtn.textContent = 'Grant 1 Score';
  }
  
  if (goldBtn) {
    goldBtn.textContent = 'Grant 1 Gold';
  }
}

function handleGrantScore() {
  // Get the current button text to determine the amount to add
  const button = document.getElementById('grantScoreBtn');
  let currentAmount = 1; // Start with 1
  
  if (button) {
    const buttonText = button.textContent;
    const match = buttonText.match(/Grant (\d+) Score/);
    if (match) {
      currentAmount = parseInt(match[1]);
    }
  }
  
  // Add the current amount
  score += currentAmount;
  
  // Double the amount for next time
  const nextAmount = currentAmount * 2;
  
  // Update button text
  if (button) {
    button.textContent = `Grant ${nextAmount} Score`;
  }
  
  // Update score display
  updateScoreDisplay();
  
  // Save game state after granting score
  saveGameState();
}

function handleCheckCoinStatus() {
  const status = soundManager.getCoinSoundStatus();
  
  if (status.loaded && status.count === status.expected) {
    // All coin sounds loaded successfully
  } else {
    console.warn('⚠️ Coin sound loading issues detected');
  }
}

function handleTestPersonalBest() {
  showPersonalBest();
  
  // Automatically close the debug pane after showing the test message
  // This provides a better UX by not keeping the debug pane open after testing
  setTimeout(() => {
    closeDebugPane();
    // Debug pane automatically closed after testing personal best message
  }, 150); // Small delay to ensure the message is visible before closing
}

function handleTestGameOver() {
  console.log('handleTestGameOver called');
  
  // Set some sample data to make the game over screen look realistic
  if (weights && weights.length > 0) {
    const highestBlock = Math.max(...weights);
  }
  
  // Set a sample score for testing the final score display
  const originalScore = score;
  score = 1234567; // Sample score for testing
  
  // Force the personal best flag to true so the test always shows "new personal best" message
  hasShownPersonalBest = true;
  
  // Show the game over screen
  showGameOver();
  
  // Restore the original score after showing the game over screen
  setTimeout(() => {
    score = originalScore;
  }, 100);
  
  // Only auto-close debug pane on mobile devices where screen space is limited
  // On desktop, keep it open for easier testing
  const isMobile = window.innerWidth <= 768 || ('ontouchstart' in window) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  console.log('Screen width:', window.innerWidth);
  console.log('Touch support:', 'ontouchstart' in window);
  console.log('User agent:', navigator.userAgent);
  console.log('Is mobile detected:', isMobile);
  
  if (isMobile) {
    console.log('Mobile detected - will auto-close debug pane');
    // On mobile, close immediately to avoid covering the screen
    setTimeout(() => {
      console.log('Timeout callback executing...');
      console.log('Debug pane element:', debugPane);
      console.log('Debug pane has show class:', debugPane && debugPane.classList.contains('show'));
      if (debugPane && debugPane.classList.contains('show')) {
        closeDebugPane();
        console.log('Debug pane automatically closed on mobile after testing game over screen');
      } else {
        console.log('Debug pane not found or not showing - cannot close');
      }
    }, 50); // Shorter delay on mobile for better UX
  } else {
    console.log('Desktop detected - keeping debug pane open for easier testing');
  }
}

function handleTestUnlockTheme() {
  // Test unlocking the Earth theme
  if (themeManager.unlockTheme('alternate')) {
    
    // Play theme unlock sound
    if (soundManager && soundManager.canPlayAudio()) {
      soundManager.playSound('themeUnlock', 'other').catch(error => {
        // Theme unlock sound error logged silently
      });
    }
    
    // Add green glow to settings button to indicate new theme available
    const settingsBtn = document.getElementById('settingsBtn');
    if (settingsBtn) {
      settingsBtn.classList.add('settings-glow');
    }
    
    // Update theme selectors to show the new unlock status
    updateThemeSelectors();
  }
}

function handleTestLockTheme() {
  // Test locking the Earth theme
  if (themeManager.themeUnlockRequirements['alternate']) {
    themeManager.themeUnlockRequirements['alternate'].unlocked = false;
    themeManager.saveUnlockStatus();
    
    // Remove settings button glow effect
    const settingsBtn = document.getElementById('settingsBtn');
    if (settingsBtn) {
      settingsBtn.classList.remove('settings-glow');
    }
    
    // Update theme selectors to show the new lock status
    updateThemeSelectors();
    
    // Show a message
    alert('Earth theme has been locked for testing. You can unlock it again with the Test Theme Unlock button or by scoring 5000+ in a real game.');
  }
}

function handleDebugPowerupPricing() {
  // Set all powerup costs to 999000
  bombConversionCost = 999000;
  trashButtonCost = 999000;
  pickaxeButtonCost = 999000;
  
  // Update the display elements
  updatePowerupCostDisplays();
  
  // Update button states to reflect new costs
  updateBombConversionButtonState();
  updatePickaxeButtonState();
  updateTrashButtonState();
  updateSwapButtonState();
  
  // Save the game state to persist the changes
  saveGameState();
}

function handleDebugResetPowerupPricing() {
  // Reset all powerup costs to default (25)
  bombConversionCost = 100;
  trashButtonCost = 25;
  pickaxeButtonCost = 1000;
  swapButtonCost = 50;
  
  // Update the display elements
  updatePowerupCostDisplays();
  
  // Update button states to reflect new costs
  updateBombConversionButtonState();
  updatePickaxeButtonState();
  updateTrashButtonState();
  updateSwapButtonState();
  
  // Save the game state to persist the changes
  saveGameState();
}



function updatePowerupCostDisplays() {
  // Get all the cost display elements
  const bombCostEl = document.getElementById('bombCost');
  const trashCostEl = document.getElementById('trashCost');
  const pickaxeCostEl = document.getElementById('pickaxeCost');
  
  // Update powerup cost displays
  if (bombCostEl) {
    bombCostEl.textContent = formatNumber(bombConversionCost);
  }
  if (trashCostEl) {
    trashCostEl.textContent = formatNumber(trashButtonCost);
  }
  if (pickaxeCostEl) {
    pickaxeCostEl.textContent = formatNumber(pickaxeButtonCost);
  }
}

function handleBlockItemClick(blockItem) {
  // Remove previous selection
  document.querySelectorAll('.block-item').forEach(item => item.classList.remove('selected'));
  
  // Select this block
  blockItem.classList.add('selected');
  
  // Check if "No Block" is selected
  if (blockItem.dataset.value === 'none') {
    customBlockSize = null;
    customBlockMode = false;
  } else {
    // Update the custom block size
    const value = parseInt(blockItem.dataset.value);
    customBlockSize = value;
    
    // Enable custom block mode
    customBlockMode = true;
    
    // Automatically close the debug pane when a custom block is selected
    // This allows immediate dropping of the selected block
    setTimeout(() => {
      closeDebugPane();
      // Debug pane automatically closed after selecting custom block
    }, 150); // Small delay to ensure the selection is visible before closing
  }
  
  // Re-render to update pole enabling/disabling based on the new custom block
  render();
}

function handleBombToggle(e) {
  customBlockBomb = e.target.checked;
  bombStatus.textContent = customBlockBomb ? 'Yes' : 'No';
  
  // Re-render to update pole enabling/disabling if custom block mode is active
  if (customBlockMode && customBlockSize) {
    render();
  }
}





function updateDebugVolumeLabel() {
  const volume = Math.round(soundManager.getVolume() * 100);
  debugVolumeLabel.textContent = volume + '%';
}

function updateDebugMuteStatus() {
  const isMuted = soundManager.getMuteState();
  debugMuteStatus.textContent = isMuted ? 'Yes' : 'No';
  

}

function updateDebugDecayLabel(decayFactor) {
  debugDecayLabel.textContent = decayFactor.toFixed(2);
}

function updateDebugProbabilitiesDisplay() {
  const probDiv = document.getElementById('debugProbabilities');
  if (!probDiv) return;
  
  if (!probabilities || probabilities.length === 0) {
    probDiv.innerHTML = '<em>No probabilities available</em>';
    return;
  }
  
  let html = '<div style="margin-bottom: 8px;"><strong>Block | Probability | Cumulative</strong></div>';
  
  let cumulative = 0;
  for (let i = 0; i < weights.length; i++) {
    cumulative += probabilities[i];
    const percentage = (probabilities[i] * 100).toFixed(2);
    const cumulativePercentage = (cumulative * 100).toFixed(2);
    
    // Different styling for foundation vs decay blocks
    const isFoundation = i < 3;
    const blockColor = isFoundation ? '#10B981' : '#0ea5e9'; // Green for foundation, blue for decay
    const bgColor = i % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'transparent';
    const borderStyle = isFoundation ? '2px solid #10B981' : 'none';
    
    html += `<div style="margin: 2px 0; padding: 2px 4px; background: ${bgColor}; border-radius: 2px; border: ${borderStyle};">
      <span style="color: ${blockColor}; font-weight: 600;">${weights[i]}</span> | 
      <span style="color: #10B981;">${percentage}%</span> | 
      <span style="color: #F59E0B;">${cumulativePercentage}%</span>
      ${isFoundation ? ' <span style="color: #10B981; font-size: 10px;">(Foundation)</span>' : ''}
    </div>`;
  }
  
  probDiv.innerHTML = html;
}

function updateProbabilityDistributionWithDecay(decayFactor) {
  // Update the current active decay factor
  currentActiveDecayFactor = decayFactor;
  
  // Recalculate probabilities with the new decay factor
  updateProbabilityDistributionCustom(decayFactor);
  
  // Update the debug display
  updateDebugDecayLabel(decayFactor);
  
  // Update the slider to reflect the current active setting
  if (debugDecaySlider) {
    debugDecaySlider.value = decayFactor;
  }
}

function colorFor(w){
  // Get current theme
  const currentTheme = themeManager ? themeManager.getCurrentTheme() : 'jellyfish';
  
  if (currentTheme === 'alternate') {
    // Vibrant, clearly differentiated colors for each block value
    const alternateColors = [
      '#E4DFBB', // warm cream - value 1
      '#7A6658', // medium brown - value 2
      '#6D8C69', // sage green - value 4
      '#0A472C', // dark green - value 8
      '#054A91', // deep blue - value 16
      '#36A1F3', // medium blue - value 32
      '#EF767A', // coral pink - value 64
      '#D9A06E', // light orange - value 128
      '#C9AA30', // golden yellow - value 256
      '#626C66', // gray-green - value 512
      '#434A42', // dark gray-green - value 1024
      '#3B2631', // dark burgundy - value 2048
      '#32021F', // dark burgundy - value 4096
      '#28112B', // very dark purple - value 8192
      '#000000'  // pitch black - value 16384
    ];
    
    const log2w = Math.log2(w);
    const colorIndex = Math.min(Math.floor(log2w), alternateColors.length - 1);
    return alternateColors[colorIndex];

  } else {
    // Default jellyfish theme colors
    const jellyfishColors = [
      '#cfef08', // lime green - value 1 (subtle)
      '#10B981', // emerald-500 - value 2 (soft green)
      '#2563EB', // blue-600 - value 4 (medium blue)
      '#7C3AED', // violet-600 - value 8 (violet - midpoint between blue and dark purple)
      '#581C87', // violet-800 - value 16 (dark purple)
      '#D946EF', // fuchsia-500 - value 32 (bright fuchsia - clearly different from 16)
      '#EC4899', // pink-500 - value 64 (hot pink)
      '#e86758', // red-500 - value 128 (intense red)
      '#F59E0B', // amber-500 - value 256 (bright amber)
      '#ea580c', // orange-600 - value 512 (vibrant orange)
      '#dc2626', // red-600 - value 1024 (bright red)
      '#9d174d', // rose-700 - value 2048 (darker magenta)
      '#7c2d6d',    // darker purple-magenta - value 4096
      '#64748b', // gray - value 8192
      '#fff'     // white - value 16384
    ];
    
    const log2w = Math.log2(w);
    const colorIndex = Math.min(Math.floor(log2w), jellyfishColors.length - 1);
    return jellyfishColors[colorIndex];
  }
}

function labelForPiece(piece){
  if (piece && piece.bomb) {
    // Format bomb text for large numbers (6+ digits)
    const displayValue = piece.w >= 100000 ? formatNumber(piece.w) : piece.w;
    return `<div class="bomb-content"><div class="bomb-emoji">💣</div><div class="bomb-text">${displayValue}</div></div>`;
  }
  // Format regular block text for large numbers (6+ digits)
  return piece.w >= 100000 ? formatNumber(piece.w) : String(piece.w);
}

function getTextColorFor(w){
  // Get current theme
  const currentTheme = themeManager ? themeManager.getCurrentTheme() : 'jellyfish';
  
  if (currentTheme === 'alternate') {
    // For alternate theme, use white text for all blocks except value 1
    return w === 1 ? '#000000' : '#ffffff';

  } else {
    // Default jellyfish theme: black text for lime green block (value 1) and blocks >= 16384, white for others
    return (w === 1 || w >= 16384) ? '#000000' : '#ffffff';
  }
}

function render(){
  // Prevent infinite render loops
  if (window.isRendering) {
    console.warn('❌ Render already in progress, skipping duplicate call');
    return;
  }
  
  // Set rendering flag to prevent safety checks from interfering
  window.isRendering = true;
  
  // build poles
  gameDiv.innerHTML = '';
  
  // Safety check: ensure we only have exactly 4 poles
  if (poles.length !== 4) {
    console.warn(`Warning: Expected 4 poles but found ${poles.length}. Resetting to 4 poles.`);
    poles = [[],[],[],[]];
  }
  

  
  poles.forEach((pole, idx) => {
    const poleDiv = document.createElement('div');
    const isAtCapacity = pole.length >= currentStackCapacity;
    
    // Determine which piece to check against for pole enabling/disabling
    let pieceToCheck;
    if (customBlockMode && customBlockSize) {
      pieceToCheck = { w: customBlockSize, bomb: customBlockBomb };
    } else {
      pieceToCheck = nextQueue[0];
    }
    
    const playable = canPlaceOnPole(pieceToCheck, pole);
    const isDisabled = trashMode || (isAtCapacity && !playable);
    
    // Debug logging for trash mode
    if (trashMode) {
      console.log(`Trash mode active - pole ${idx}: isDisabled=${isDisabled}, playable=${playable}, isAtCapacity=${isAtCapacity}`);
    }
    
    poleDiv.className = 'pole' + (isDisabled && !pickaxeMode ? ' full' : '');
    
    // Preserve the no-hover state if we're currently placing
    if (placing) {
      poleDiv.classList.add('no-hover');
      poleDiv.style.pointerEvents = 'none';
    }
    
    // If stack is disabled (full and can't merge), disable interactions
    // But allow pickaxe interactions even on disabled stacks
    if (isDisabled) {
      if (!pickaxeMode) {
        poleDiv.classList.add('no-hover');
        poleDiv.style.pointerEvents = 'none';
        poleDiv.style.cursor = 'not-allowed';
      }
    }
    
    poleDiv.setAttribute('role', 'button');
    poleDiv.tabIndex = (isDisabled && !pickaxeMode) ? -1 : 0;
    poleDiv.setAttribute('aria-label', `Stack ${idx + 1}, contains ${pole.length} blocks${isAtCapacity ? (playable ? ', merge available' : (pickaxeMode ? ', pickaxe available' : ', blocked')) : ''}`);
    poleDiv.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (!isDisabled || pickaxeMode) {
          if (pickaxeMode) {
            // In pickaxe mode, remove the top block
            handlePickaxeBlockRemoval(idx, null).catch(console.error);
          } else {
            placeOnPole(idx);
          }
        }
      }
    });
    // existing discs (no animation class)
    pole.forEach(p => {
      const d = document.createElement('div');
      d.className = 'disc';
      if (p.bomb) {
        d.innerHTML = labelForPiece(p);
      } else {
        d.textContent = labelForPiece(p);
      }
      d.style.background = p.bomb ? '#000' : colorFor(p.w);
      d.style.color = p.bomb ? '#fff' : getTextColorFor(p.w);
      
      // Add dynamic gold glow effect for white blocks (16384+)
      if (!p.bomb && p.w >= 16384) {
        d.classList.add('white-block-glow');
        
        // Calculate glow intensity based on block value
        const log2Value = Math.log2(p.w);
        const baseLog2 = Math.log2(16384); // 14
        const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
        
        // Set CSS custom properties for dynamic glow
        d.style.setProperty('--glow-intensity', intensityMultiplier.toString());
        d.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
        d.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
        d.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
        d.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
        d.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
      }
      
      poleDiv.appendChild(d);
    });
    
    // Add click handler if stack is not disabled OR if pickaxe mode is active
    if (!isDisabled || pickaxeMode) {
      console.log('Adding click handler to pole', idx, 'isDisabled:', isDisabled, 'pickaxeMode:', pickaxeMode, 'trashMode:', trashMode);
      poleDiv.addEventListener('click', (e) => {
        // Ensure audio is unlocked on first click
        if (soundManager && !soundManager.audioUnlocked) {
          soundManager.unlockAudio();
        }
        
        // Check if pickaxe mode is active
        if (pickaxeMode) {
          console.log('Pickaxe mode active, processing click on pole', idx);
          // In pickaxe mode, we need to check if a specific block was clicked
          // The click event will bubble up from the individual block elements
          const clickedElement = e.target;
          console.log('Clicked element:', clickedElement);
          
          // Find the closest disc element (either the clicked element or its parent)
          let discElement = clickedElement;
          while (discElement && !discElement.classList.contains('disc')) {
            discElement = discElement.parentElement;
          }
          console.log('Found disc element:', discElement);
          
          if (discElement && discElement.classList.contains('disc')) {
            // Find the index of this block within the pole
            const blocks = poleDiv.querySelectorAll('.disc');
            const domIndex = Array.from(blocks).indexOf(discElement);
            console.log('DOM index:', domIndex);
            
            if (domIndex !== -1) {
              // DOM index directly corresponds to game data index
              // since blocks are rendered in the same order as the poles array
              const gameDataIndex = domIndex;
              console.log('Calling handlePickaxeBlockRemoval with pole', idx, 'block', gameDataIndex);
              
              handlePickaxeBlockRemoval(idx, gameDataIndex).catch(console.error);
              return;
            }
          }
          
          console.log('No specific block was clicked in pickaxe mode');
          // If no specific block was clicked, don't do anything in pickaxe mode
          return;
        }
        
        // If stack is disabled and we're not in pickaxe mode, don't allow normal placement
        if (isDisabled && !pickaxeMode) {
          return;
        }
        
        // Play drop sound IMMEDIATELY on click for iOS compatibility
        // This happens before any game logic, in direct response to user interaction
        // But only if we're not in the middle of a swap animation
        if (soundManager && !swapAnimating) {
          const nextPiece = nextQueue[0];
          if (nextPiece) {
            soundManager.playDropSoundEnhanced(nextPiece.w);
          }
        }
        
        placeOnPole(idx);
      });
      
          // Add touch event handling for better mobile experience
      let touchStartTime = 0;
      let touchStartY = 0;
      
      poleDiv.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        touchStartY = e.touches[0].clientY;
        // Prevent default to avoid double-tap zoom on mobile, but only if cancelable
        if (e.cancelable) {
          e.preventDefault();
        }
        
        // Prime audio context on first touch to ensure instant playback

      }, { passive: false });
      
      poleDiv.addEventListener('touchend', (e) => {
        const touchEndTime = Date.now();
        const touchEndY = e.changedTouches[0].clientY;
        const touchDuration = touchEndTime - touchStartTime;
        const touchDistance = Math.abs(touchEndY - touchStartY);
        
        // Only trigger placement if it's a quick tap (not a swipe) and close to start position
        if (touchDuration < 300 && touchDistance < 20) {
          // Ensure audio is unlocked on first touch
          if (soundManager && !soundManager.audioUnlocked) {
            soundManager.unlockAudio();
          }
          
          // Check if pickaxe mode is active
          if (pickaxeMode) {
            // In pickaxe mode, we need to check if a specific block was touched
            // The touch event will bubble up from the individual block elements
            const touchedElement = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            
            // Check if the touched element is a block (disc) within this pole or is contained within a disc
            if (touchedElement && poleDiv.contains(touchedElement)) {
              // Find the closest disc element (either the touched element or its parent)
              let discElement = touchedElement;
              while (discElement && !discElement.classList.contains('disc')) {
                discElement = discElement.parentElement;
              }
              
              if (discElement && discElement.classList.contains('disc')) {
                // Find the index of this block within the pole
                const blocks = poleDiv.querySelectorAll('.disc');
                const blockIndex = Array.from(blocks).indexOf(discElement);
                
                if (blockIndex !== -1) {
                  // DOM index directly corresponds to game data index
                  const gameDataIndex = blockIndex;
                  
                  handlePickaxeBlockRemoval(idx, gameDataIndex).catch(console.error);
                  return;
                }
              }
            }
            
            // If no specific block was touched, don't do anything in pickaxe mode
            return;
          }
          
          // If stack is disabled and we're not in pickaxe mode, don't allow normal placement
          if (isDisabled && !pickaxeMode) {
            return;
          }
          
          // Play drop sound IMMEDIATELY on touch for iOS compatibility
          // But only if we're not in the middle of a swap animation
          if (soundManager && !swapAnimating) {
            const nextPiece = nextQueue[0];
            if (nextPiece) {
              soundManager.playDropSoundEnhanced(nextPiece.w);
            }
          }
          
          placeOnPole(idx);
        }
      }, { passive: true });
      
      // Clear hover state when touch moves (prevents stuck highlights)
      poleDiv.addEventListener('touchmove', (e) => {
        // If touch moves significantly, don't trigger placement
        const currentY = e.touches[0].clientY;
        if (Math.abs(currentY - touchStartY) > 20) {
          // Touch moved too much, this won't be a valid tap
        }
      }, { passive: true });
      
      // Handle touch cancellation
      poleDiv.addEventListener('touchcancel', () => {
        // Touch was cancelled, do nothing
      }, { passive: true });
    }
    
    gameDiv.appendChild(poleDiv);
    
    // Apply default animation speed to the new pole
    poleDiv.style.setProperty('--animation-speed', '1');
  });
  
  // Final safety check: verify we only have 4 pole elements
  const renderedPoles = gameDiv.querySelectorAll('.pole');
  if (renderedPoles.length !== 4) {
    console.warn(`Warning: Rendered ${renderedPoles.length} pole elements instead of 4! Attempting to fix...`);
    
    // Try to fix by re-rendering once more
    if (window.renderRetryCount === undefined) {
      window.renderRetryCount = 1;
    } else if (window.renderRetryCount < 2) {
      window.renderRetryCount++;
    } else {
      // Too many retries, reset and start fresh
      console.error(`Too many render retries (${window.renderRetryCount}), resetting game state`);
      window.renderRetryCount = 0;
      poles = [[],[],[],[]];
      gameDiv.innerHTML = '';
      window.isRendering = false;
      setTimeout(() => render(), 100);
      return;
    }
    
    gameDiv.innerHTML = '';
    // Clear rendering flag before early return
    window.isRendering = false;
    // Force a single re-render with small delay
    setTimeout(() => render(), 50);
    return;
  }
  
  // Reset retry count on successful render
  window.renderRetryCount = 0;
  

  
  // update score display in game info
  updateScoreDisplay();
  
  // update gold display in game info
  updateGoldDisplay();
  
  // Update all powerup button states when gold changes
  updateAllPowerupButtonsIfGoldChanged();
  

  
  updateDebugPane();
  
  // Clear rendering flag
  window.isRendering = false;
  
  renderNext();
}

function renderNext(){
  nextContainer.innerHTML = '';
  nextQueue.forEach((p, idx) => {
    const d = document.createElement('div');
    // Highlight the current piece based on mode:
    // - Normal mode: highlight first block (idx === 0)
    // - Pickaxe mode: no highlighting
    // - Swap mode: highlight the selected block
    let shouldHighlight = false;
    if (pickaxeMode) {
      shouldHighlight = false; // No highlighting in pickaxe mode
    } else if (swapMode) {
      shouldHighlight = idx === swapSelectedIndex; // Highlight selected block in swap mode
    } else {
      shouldHighlight = idx === 0; // Normal mode - highlight first block
    }
    
    d.className = 'next-disc' + (shouldHighlight ? ' current' : '');
    if (p.bomb) {
      d.innerHTML = labelForPiece(p);
    } else {
      d.textContent = labelForPiece(p);
    }
    d.style.background = p.bomb ? '#000' : colorFor(p.w);
    d.style.color = p.bomb ? '#fff' : getTextColorFor(p.w);
    
    // Add dynamic gold glow effect for white blocks (16384+)
    if (!p.bomb && p.w >= 16384) {
      d.classList.add('white-block-glow');
      
      // Calculate glow intensity based on block value
      const log2Value = Math.log2(p.w);
      const baseLog2 = Math.log2(16384); // 14
      const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
      
      // Set CSS custom properties for dynamic glow
      d.style.setProperty('--glow-intensity', intensityMultiplier.toString());
      d.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
      d.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
      d.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
      d.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
      d.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
    }
    
    // Add trash overlay for trash mode on the first block
    if (idx === 0 && trashMode) {
      const trashOverlay = document.createElement('div');
      trashOverlay.className = 'trash-x-overlay';
      trashOverlay.innerHTML = '🗑️';
      trashOverlay.addEventListener('click', handleTrashConfirmation);
      d.appendChild(trashOverlay);
    }
    
    nextContainer.appendChild(d);
    
    // Apply default animation speed to the new next disc
    d.style.setProperty('--animation-speed', '1');
  });
}

function placeOnPole(idx){
  logQueueState('placeOnPole-start');
  
  if (placing) { 
    return; // Simply ignore clicks during placement instead of queueing
  }
  
  if (swapAnimating) {
    return; // Ignore clicks during swap animation
  }
  
  // Validate queue state before proceeding
  validateQueueState();
  
  // Add bounds checking for nextQueue
  if (nextQueue.length === 0) {
    console.warn('Attempted to place block with empty queue');
    return;
  }
  
  const pole = poles[idx];
  
  // Check if custom block mode is active
  let nextPiece;
  let wasCustomBlock = false;
  if (customBlockMode && customBlockSize) {
    nextPiece = { w: customBlockSize, bomb: customBlockBomb };
    wasCustomBlock = true;
    // Custom block mode works when a block is selected, regardless of debug pane visibility
  } else if (swapMode) {
    // In swap mode, place the selected block
    nextPiece = nextQueue[swapSelectedIndex];
  } else {
    nextPiece = nextQueue[0];
  }
  
  // Safety check: ensure this stack can actually accept the piece
  if (!canPlaceOnPole(nextPiece, pole)) {
    return;
  }
  
  // Note: Drop sound is now played immediately in the click/touch handler for iOS compatibility
  
  // Note: Drop sound is now played immediately in the click/touch handler for iOS compatibility
  
  placing = true;
  lastPlacementTime = Date.now();

  // Disable hover effects on all poles during placement
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = 'none';
    poleDiv.classList.add('no-hover');
  });

  // append an animated disc to the pole DOM, without modifying the data model yet
  const poleDiv = gameDiv.children[idx];
  const animDisc = document.createElement('div');
  animDisc.className = 'disc animate';
  if (nextPiece.bomb) {
    animDisc.innerHTML = labelForPiece(nextPiece);
  } else {
    animDisc.textContent = labelForPiece(nextPiece);
  }
  animDisc.style.background = nextPiece.bomb ? '#000' : colorFor(nextPiece.w);
  animDisc.style.color = nextPiece.bomb ? '#fff' : getTextColorFor(nextPiece.w);
  
  // Add dynamic gold glow effect for white blocks (16384+)
  if (!nextPiece.bomb && nextPiece.w >= 16384) {
    animDisc.classList.add('white-block-glow');
    
    // Calculate glow intensity based on block value
    const log2Value = Math.log2(nextPiece.w);
    const baseLog2 = Math.log2(16384); // 14
    const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
    
    // Set CSS custom properties for dynamic glow
    animDisc.style.setProperty('--glow-intensity', intensityMultiplier.toString());
    animDisc.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
    animDisc.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
    animDisc.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
    animDisc.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
    animDisc.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
  }
  
  // Apply default animation speed to the animated disc
  animDisc.style.setProperty('--animation-speed', '1');
  
  // Apply current stack height to the animated disc
  animDisc.style.setProperty('--stack-height', document.documentElement.style.getPropertyValue('--stack-height'));
  
  // Let CSS handle the mobile-specific drop animations
  // The CSS media queries will automatically apply the correct animation
  
  poleDiv.appendChild(animDisc);



  // after drop animation, commit, then animate merge cascade step-by-step
  const handlePlacement = async () => {
    // Add safety timeout to prevent hanging
    const safetyTimeout = setTimeout(() => {
      if (placing) {
        console.error('Placement safety timeout - forcing completion');
        placing = false;
        
        // Re-enable hover effects and pointer events
        const allPoles = Array.from(gameDiv.children);
        allPoles.forEach(poleDiv => {
          poleDiv.style.pointerEvents = '';
          poleDiv.classList.remove('no-hover');
        });
        
        render();
        checkGameOver();
      }
    }, 5000); // 5 second safety timeout (more aggressive)
    
    try {
      poles[idx].push(nextPiece);
      
      // Check if this is a purchased bomb that needs payment
      if (nextPiece.bomb && bombSelected) {
        // Play bomb light sound effect when bomb is placed
        if (soundManager && soundManager.canPlayAudio()) {
          soundManager.playBombLightSound();
        }
        
        // Decrease owned bomb count
        bombOwned--;
        updatePowerupOwnershipBadges();
        
        // Update button cost display
        if (bombCostEl) {
          bombCostEl.textContent = formatNumber(bombConversionCost);
        }
        
        // Update powerup button states to reflect new owned count
        updateBombConversionButtonState();
        
        // Update all button states to reflect new costs and ensure proper state
        updateBombConversionButtonState();
        updatePickaxeButtonState();
        updateTrashButtonState();
        

        
        // Save game state after bomb payment
        saveGameState();
      }
      
      // RESET BOMB SELECTION AFTER PLACEMENT LOGIC IS COMPLETE
      if (bombSelected && nextPiece.bomb) {
        bombSelected = false;
        // Update button state to remove undo mode and re-enable other powerups
        updateBombConversionButtonState();
        updatePickaxeButtonState();
        updateTrashButtonState();
      }
      
      // scoring: add only the dropped piece's weight
      score += nextPiece.w;
      updateScoreDisplay();
      
      // Check for theme unlocks
      if (score >= 5000 && !themeManager.isThemeUnlocked('alternate')) {
        if (themeManager.unlockTheme('alternate')) {
          
          // Play theme unlock sound
          if (soundManager && soundManager.canPlayAudio()) {
            soundManager.playSound('themeUnlock', 'other').catch(error => {
              // Theme unlock sound error logged silently
            });
          }
          
          // Add green glow to settings button to indicate new theme available
          const settingsBtn = document.getElementById('settingsBtn');
          if (settingsBtn) {
            settingsBtn.classList.add('settings-glow');
          }
          
          // Update theme selectors to show the new unlock status
          if (typeof updateThemeSelectors === 'function') {
            // Add a small delay to ensure DOM elements are ready
            setTimeout(() => {
              updateThemeSelectors();
            }, 100);
          }
        }
      }
      

      
      // Save game state after placing a block
      saveGameState();
      
      // Add pulse animation to the score display
      const scoreDisplay = document.querySelector('.score-value');
      if (scoreDisplay) {
        scoreDisplay.classList.add('pulse');
        setTimeout(() => {
          scoreDisplay.classList.remove('pulse');
        }, 300);
      }
      
      // Increment blocks dropped counter (only for regular pieces, not custom debug pieces)
      if (!wasCustomBlock) {
        blocksDropped++;
        totalBlocksDropped++;
      }
      
      // Capture swap mode values before they get reset
      const wasInSwapMode = swapMode;
      const selectedIndex = swapSelectedIndex;
      
      // Handle swap mode consumption
      if (swapMode && !wasCustomBlock) {
        // Decrease owned swap count
        swapOwned--;
        updatePowerupOwnershipBadges();
        
        // Track total swaps used
        totalSwapsUsed++;
        
        // Exit swap mode
        swapMode = false;
        swapSelectedIndex = 0;
        
        // Update button states
        updateAllPowerupButtonStates();
        
        // Save game state after using swap
        saveGameState();
      }
      
      // Only advance the queue if we used a regular piece, not a custom one
      if (!wasCustomBlock) {
        // animate next queue: consume current, shift others, append new
        // Pass the selected index if we were in swap mode
        const blockIndexToRemove = wasInSwapMode ? selectedIndex : 0;
        await animateNextQueueAdvance(false, blockIndexToRemove); // false = queue not yet modified
      }
      
      render();
      try {
        await animateMergeCascade(idx);
        
        // Only set placing to false after merge cascade completes
        placing = false;
        
        // Re-enable hover effects and pointer events after placing is false
        const allPoles = Array.from(gameDiv.children);
        allPoles.forEach(poleDiv => {
          poleDiv.style.pointerEvents = '';
          poleDiv.classList.remove('no-hover');
        });
      } catch (error) {
        console.error('Merge cascade error:', error);
        // Force reset placing flag on error to prevent game freeze
        placing = false;
        
        // Re-enable hover effects and pointer events after placing is false
        const allPoles = Array.from(gameDiv.children);
        allPoles.forEach(poleDiv => {
          poleDiv.style.pointerEvents = '';
          poleDiv.classList.remove('no-hover');
        });
      }
      render();
      checkGameOver();
      
      logQueueState('placeOnPole-end');
      

      
    } finally {
      clearTimeout(safetyTimeout);
    }
  };

  // Wait for animation to complete
  animDisc.addEventListener('animationend', handlePlacement, { once: true });
}

function waitForAnimation(element){
  return new Promise(resolve => {
    const startTime = Date.now();
    
    // CRITICAL FIX: Check if animation is already running BEFORE setting up listeners
    const computedStyle = window.getComputedStyle(element);
    const animationName = computedStyle.animationName;
    const animationDuration = parseFloat(computedStyle.animationDuration) || 0;
    const animationDelay = parseFloat(computedStyle.animationDelay) || 0;
    const totalAnimationTime = (animationDuration + animationDelay) * 1000; // Convert to ms
    
    if (animationName === 'none') {
      resolve();
      return;
    }
    
    // Check if animation has already completed by looking at animation state
    // This prevents the race condition where animation finishes before we start listening
    if (totalAnimationTime <= 100) {
      setTimeout(resolve, totalAnimationTime + 10); // Wait for animation to complete + small buffer
      return;
    }
    
    // Add multiple event listeners to catch different animation end events
    const handleAnimationEnd = (event) => {
      resolve();
    };
    
    // Add more comprehensive event listeners
    element.addEventListener('animationend', handleAnimationEnd, { once: true });
    element.addEventListener('webkitAnimationEnd', handleAnimationEnd, { once: true });
    element.addEventListener('mozAnimationEnd', handleAnimationEnd, { once: true });
    element.addEventListener('MSAnimationEnd', handleAnimationEnd, { once: true });
    
    // Fallback timeout to prevent hanging - use actual animation duration + buffer
    const timeoutDuration = Math.max(1500, totalAnimationTime + 500); // At least 1.5s, or animation time + 500ms buffer
    
    // Add a more robust fallback that checks animation state periodically
    const checkAnimationState = () => {
      const currentStyle = window.getComputedStyle(element);
      const currentAnimationName = currentStyle.animationName;
      
      if (currentAnimationName === 'none') {
        resolve();
        return;
      }
      
      // Check if we're past the expected animation time
      const elapsed = Date.now() - startTime;
      if (elapsed >= totalAnimationTime + 100) { // Add 100ms buffer
        resolve();
        return;
      }
      
      // Continue checking
      setTimeout(checkAnimationState, 50); // Check every 50ms
    };
    
    // Start the periodic check
    setTimeout(checkAnimationState, 50);
    
    // Traditional timeout fallback as backup
    setTimeout(() => {
      resolve();
    }, timeoutDuration);
  });
}

// Function to check if any animations are currently running
function areAnyAnimationsRunning() {
  // Check all poles for running animations
  const allPoles = Array.from(gameDiv.children);
  for (const pole of allPoles) {
    const discs = pole.querySelectorAll('.disc');
    for (const disc of discs) {
      const computedStyle = window.getComputedStyle(disc);
      const animationName = computedStyle.animationName;
      if (animationName !== 'none') {

        return true;
      }
    }
  }
  
  // Check next queue for running animations
  const nextItems = nextContainer.querySelectorAll('.next-disc');
  for (const item of nextItems) {
    const computedStyle = window.getComputedStyle(item);
    const animationName = computedStyle.animationName;
    if (animationName !== 'none') {
      
      return true;
    }
  }
  
  return false;
}

async function animateMergeCascade(index){
  // Reset merge count for new cascade
  soundManager.setCurrentMergeCount(0);
  
  // Global timeout to prevent infinite hanging
  const globalTimeout = setTimeout(() => {
    console.error('Merge cascade global timeout - forcing completion');
    throw new Error('Merge cascade timeout');
  }, 5000); // 5 second global timeout
  
  try {
    let iterationCount = 0;
    const maxIterations = 20; // Prevent infinite loops
    let mergeCount = 0; // Track number of merges in this cascade for gold calculation
    
    while (true){
      iterationCount++;
      if (iterationCount > maxIterations) {
        console.error('Merge cascade exceeded max iterations, forcing completion');
        break;
      }
      
      const poleArr = poles[index];
      // find top-first adjacent equal pair
      let pairIndex = -1;
      for (let i = poleArr.length - 1; i > 0; i--) {
        if (poleArr[i] && poleArr[i - 1] && poleArr[i].w === poleArr[i - 1].w) { pairIndex = i; break; }
      }
      if (pairIndex === -1) {
        break;
      }

    // animate both discs merging out with enhanced visual effects
    const poleDiv = gameDiv.children[index];
    const discs = poleDiv.querySelectorAll('.disc');
    const topEl = discs[pairIndex];
    const belowEl = discs[pairIndex - 1];
    if (!topEl || !belowEl) break;
    
    try {
      // Add glow effect to both discs before merging
      topEl.classList.add('merging');
      belowEl.classList.add('merging');
      
      // Stagger the merge-out animations slightly for better visual flow
      topEl.classList.add('merge-out');
      await new Promise(resolve => setTimeout(resolve, 25)); // Reduced delay for snappier effect
      belowEl.classList.add('merge-out');
      
      // Small delay to ensure CSS classes are applied and animations start
      await new Promise(resolve => setTimeout(resolve, 10));
      
      // Wait for both animations to complete with error handling
      await Promise.all([
        waitForAnimation(topEl).catch(err => console.error('Top animation error:', err)),
        waitForAnimation(belowEl).catch(err => console.error('Bottom animation error:', err))
      ]);
      
      // Remove glow effects
      topEl.classList.remove('merging');
      belowEl.classList.remove('merging');
    } catch (error) {
      console.error('Merge animation error:', error);
      // Clean up classes in case of error
      topEl.classList.remove('merging', 'merge-out');
      belowEl.classList.remove('merging', 'merge-out');
    }

    // commit merge to data model
    const a = poleArr[pairIndex];
    const b = poleArr[pairIndex - 1];
    const newW = a.w * 2; // weights are equal here
    const isBombMerge = a.bomb || b.bomb;
    poleArr.splice(pairIndex - 1, 2, { w: newW, bomb: isBombMerge });
    
    // Increment merge count for cascade sound effects
    mergeCount++;
    
    // Set the merge count for cascade sound effects
    soundManager.setCurrentMergeCount(mergeCount);
    
    // Play merge sound effect for the newly created block
    soundManager.playMergeSoundEnhanced(newW);
    
    // Earn gold for this merge (increases by 1 for each merge in the cascade, multiplied by current stage)
    const baseGoldEarned = mergeCount;
    // Stage 1: 1x multiplier, Stage 2+: 10x multiplier
    const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
    const goldEarned = baseGoldEarned * stageMultiplier;
    gold += goldEarned;
    goldEarnedThisGame += goldEarned; // Track gold earned in current game
    lifetimeGoldEarned += goldEarned; // Track lifetime gold earned
    updateGoldDisplay(true);
    
    // Update shop button affordability if shop is open
    if (shopModal && !shopModal.classList.contains('hidden')) {
      updateShopDisplay();
    }
    
    // Update statistics modal if it's open
    if (statsModal && !statsModal.classList.contains('hidden')) {
      updateStatsModal();
    }
    
    // Show gold earned animation
    showGoldEarned(goldEarned);
    
    // Play coin sound effect for earning gold
    soundManager.playCoinSound();
    
    // Update bomb conversion button state
    updateBombButtonIfGoldChanged();
    // Update trash button state
    updateTrashButtonIfGoldChanged();
    // Update pickaxe button state
    updatePickaxeButtonIfGoldChanged();
    
    // Save game state after merge and gold earning
    saveGameState();

    if (isBombMerge){
      // Bomb merge - clear the entire stack
      totalBombsExploded++; // Track total bombs exploded
      await animateClearPoleWithFallingBlock(index, pairIndex - 1, newW);
      // after animation, pole is cleared; continue which will break
      continue;
    }
    
      // Check if this merge unlocks a new stack (stage progression)
  if (newW === currentTargetBlockSize * 2){
    // Check if this merge unlocks a new block size for future drops BEFORE stage progression
    checkForNewBlockSize(newW);
    // Stage progression: keep the merged block, clear the rest of the stack
    await animateStageProgression(index, pairIndex - 1, newW);
    // Check if we should add a new stack
    checkForNewStack();
    // after animation, pole has only the merged block; continue which will break
    continue;
  }

    // Check if this merge unlocks a new block size for future drops
    checkForNewBlockSize(newW);
    
    // re-render and pop-in the new merged disc with enhanced effects
    render();
    const poleDivAfter = gameDiv.children[index];
    const discsAfter = poleDivAfter.querySelectorAll('.disc');
    const mergedEl = discsAfter[pairIndex - 1];
    if (mergedEl){
      try {
        // Add glow effect for the new merged block
        mergedEl.classList.add('merging');
        mergedEl.classList.add('merge-in');
        
        // Small delay to ensure CSS class is applied and animation starts
        await new Promise(resolve => setTimeout(resolve, 10));
        
        await waitForAnimation(mergedEl);
        mergedEl.classList.remove('merge-in');
        mergedEl.classList.remove('merging');
      } catch (error) {
        console.error('Merge-in animation error:', error);
        // Clean up classes in case of error
        mergedEl.classList.remove('merging', 'merge-in');
      }
    }
    
    // Re-render to ensure DOM is up to date before next iteration
    // Note: This render call is now conditional to prevent excessive rendering
    if (gameDiv.children.length !== 4) {
      console.warn('Pole count mismatch detected, re-rendering...');
      render();
    }
  }
  
  // Re-enable hover effects and pointer events after the cascade is complete
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = '';
    poleDiv.classList.remove('no-hover');
  });
  
  } finally {
    clearTimeout(globalTimeout);
  }
}

function checkGameOver(){
  if (!hasAnyMove(nextQueue[0])){
    if (aiEnabled) toggleAI(false);
    showGameOver();
  }
}

function showGameOver(){
  // Play game over sound effect
  soundManager.playGameOverSound();
  
  // Show game over button overlay centered on screen with fade-in effect
  const gameOverButton = document.getElementById('gameOverButton');
  if (gameOverButton) {
    // Small delay to make the fade-in more noticeable
    setTimeout(() => {
      gameOverButton.classList.add('show');
    }, 200);
  }
  
  // Calculate and display the largest merge block
  const largestMergeBlock = document.getElementById('largestMergeBlock');
  if (largestMergeBlock && weights && weights.length > 0) {
    const highestBlock = Math.max(...weights);
    largestMergeBlock.setAttribute('data-value', highestBlock);
    
    // Apply themed colors using the colorFor function, just like regular game blocks
    largestMergeBlock.style.background = colorFor(highestBlock);
    largestMergeBlock.style.color = getTextColorFor(highestBlock);
    
    // Use the same number formatting as regular game blocks
    largestMergeBlock.textContent = highestBlock >= 100000 ? formatNumber(highestBlock) : String(highestBlock);
  }
  
  // Display gold earned in this game
  const goldEarnedDisplay = document.getElementById('goldEarnedDisplay');
  if (goldEarnedDisplay) {
    goldEarnedDisplay.innerHTML = `
      <div class="gold-emoji">💰</div>
      <div class="gold-text">${formatNumber(goldEarnedThisGame)}</div>
    `;
  }
  
  // Display final score
  const finalScoreDisplay = document.getElementById('finalScoreDisplay');
  if (finalScoreDisplay) {
    finalScoreDisplay.innerHTML = `
      <div class="score-star">⭐</div>
      <div class="score-text">${formatScore(score)}</div>
      <div id="newHighScoreMessage" class="new-high-score-badge hidden">NEW RECORD</div>
    `;
  }
  
  // Add glowing effect to the ➕ button to guide user to start new game
  const addBtn = document.getElementById('addBtn');
  if (addBtn) {
    addBtn.classList.add('game-over-glow');
  }
  
  // Reset bomb selection state when game over is reached
  bombSelected = false;
  trashMode = false; // Reset trash mode
  
  // Check if this is a new high score
  const previousHighScore = window.highScore || 0;
  const isNewHighScore = score > previousHighScore;
  if (isNewHighScore) {
    window.highScore = score;
    
    // Update statistics modal if it's open
    if (statsModal && !statsModal.classList.contains('hidden')) {
      updateStatsModal();
    }
  }
  
  // Show "New High Score!" message if we achieved a new personal best this game
  if (hasShownPersonalBest && window.totalGames > 0) {
    const newHighScoreMessage = document.getElementById('newHighScoreMessage');
    if (newHighScoreMessage) {
      newHighScoreMessage.classList.remove('hidden');
    }
  } else {
    // Hide the message if no new personal best was achieved
    const newHighScoreMessage = document.getElementById('newHighScoreMessage');
    if (newHighScoreMessage) {
      newHighScoreMessage.classList.add('hidden');
    }
  }
  
  // Note: Pole interactions are no longer disabled to allow players to examine the final state
  
  // Increment total games counter when game ends
  window.totalGames++;
  
  // Save final game state when game over is reached
  saveGameState();
}



function resetGame(isFreshGame = true){
  // Hide game over button overlay
  const gameOverButton = document.getElementById('gameOverButton');
  if (gameOverButton) {
    gameOverButton.classList.remove('show');
  }
  
  // Clear the largest merge block display
  const largestMergeBlock = document.getElementById('largestMergeBlock');
  if (largestMergeBlock) {
    largestMergeBlock.textContent = '';
    largestMergeBlock.removeAttribute('data-value');
    // Reset inline styles to default
    largestMergeBlock.style.background = '';
    largestMergeBlock.style.color = '';
  }
  
  // Clear the gold earned display
  const goldEarnedDisplay = document.getElementById('goldEarnedDisplay');
  if (goldEarnedDisplay) {
    goldEarnedDisplay.innerHTML = `
      <div class="gold-emoji">💰</div>
      <div class="gold-text">0</div>
    `;
  }
  
  // Clear the final score display
  const finalScoreDisplay = document.getElementById('finalScoreDisplay');
  if (finalScoreDisplay) {
    finalScoreDisplay.innerHTML = `
      <div class="score-star">⭐</div>
      <div class="score-text">0</div>
      <div id="newHighScoreBadge" class="new-high-score-badge hidden">NEW RECORD</div>
    `;
  }
  
      // Remove glowing effect from the ➕ button
  const addBtn = document.getElementById('addBtn');
  if (addBtn) {
    addBtn.classList.remove('game-over-glow');
  }
  
  // Remove glowing effect from the settings button
  const settingsBtn = document.getElementById('settingsBtn');
  if (settingsBtn) {
    settingsBtn.classList.remove('settings-glow');
  }
  
  poles = [[],[],[],[]];
  score = 0;
  gold = 0; // Reset gold counter
  goldEarnedThisGame = 0; // Reset gold earned this game counter
  hasShownPersonalBest = false; // Reset personal best flag for new game
  blocksDropped = 0; // Reset blocks dropped counter
  currentTargetBlockSize = STARTING_BLOCK_SIZE; // Reset target block size
  currentStackCapacity = MAX_HEIGHT; // Reset stack capacity
  currentStage = 1; // Reset stage counter
  
  // Only reset button costs if this is a fresh game (not a UI reset)
  if (isFreshGame) {
    // Reset bomb conversion button state
    bombConversionCost = 100;
    bombConversionPresses = 0;
    lastGoldAmount = 0; // Reset tracked gold amount to force button state update
    bombSelected = false; // Reset bomb selection state
    trashMode = false; // Reset trash mode
    previousBombCost = 100; // Reset previous bomb cost
    
    // Reset trash button state
    trashButtonCost = 25;
    trashButtonPresses = 0;
    
      // Reset pickaxe button state
  pickaxeButtonCost = 1000;
  pickaxeButtonPresses = 0;
  pickaxeMode = false;
  
  // Reset swap button state
  swapButtonCost = 50;
  swapButtonPresses = 0;
  swapAnimating = false;
    
    // Reset owned quantities
    bombOwned = 0;
    trashOwned = 0;
    pickaxeOwned = 0;
    swapOwned = 0;
    
    // Reset purchase tracking
    bombEverPurchased = false;
    trashEverPurchased = false;
    pickaxeEverPurchased = false;
    swapEverPurchased = false;
    
    // Reset discovery tracking for new game
    bombDiscoveredThisGame = false;
    trashDiscoveredThisGame = false;
    pickaxeDiscoveredThisGame = false;
    swapDiscoveredThisGame = false;

    
    // Update powerup ownership badges
    updatePowerupOwnershipBadges();
    
    // Update powerup button visibility (hide all since they're reset)
    updatePowerupButtonVisibility();
    


    
    // Keep pickaxe enabled state for new game
    // window.pickaxeEnabled remains true
  }
  
  // Update cost displays after reset (only if costs were actually reset)
  if (isFreshGame) {
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostEl) {
      trashCostEl.textContent = formatNumber(trashButtonCost);
    }
    if (pickaxeCostEl) {
      pickaxeCostEl.textContent = formatNumber(pickaxeButtonCost);
    }
  }
  
  // Update button states after reset
  if (isFreshGame) {
    updateAllPowerupButtonStates();
    
    // Keep pickaxe button visible for new game
    // if (pickaxeButton) {
    //   pickaxeButton.classList.add('hidden');
    // }
    

    
    // Button sizing is now handled automatically by CSS
  }
  
  // Reset weights and probabilities to initial state
  weights = [1, 2];
  
  // Reset decay factor to default for fresh games
  if (isFreshGame) {
    currentActiveDecayFactor = PROBABILITY_DECAY_FACTOR;
  }
  
  // Let updateProbabilityDistribution calculate the correct initial probabilities
  updateProbabilityDistribution();
  
  nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
  placing = false;
  
  // Re-enable hover effects and pointer events on all poles
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = '';
    poleDiv.classList.remove('no-hover');
  });
  
  // Reset custom block mode
  customBlockMode = false;
  

  
  updateStackHeight();
  updateScoreDisplay();
  updateGoldDisplay();
  render();
  
  // Button sizing is now handled automatically by CSS
  
  // Clear saved game after reset
  clearGameSave();
}

// ------------------
// AI logic: simplified to focus on core priorities:
// 1. MERGING - If a merge can be made, do it immediately
// 2. CLEAN STACKS - Place blocks on next size up (16 on 32, 8 on 16, etc.)
// 3. NEXT CLOSEST - Place on closest larger size when optimal isn't available
// 4. BOMB STRATEGY - Clean up messy stacks, avoid disrupting valuable ones
// 5. MINIMAL DISRUPTION - Only disrupt when necessary, prefer empty poles
// ------------------
function topOf(pole){
  return pole.length === 0 ? null : pole[pole.length - 1];
}

function canPlaceOnPole(pieceOrWeight, pole){
  // If trash mode is active, no blocks can be placed on any stack
  if (trashMode) {
    return false;
  }
  
  const weight = typeof pieceOrWeight === 'number' ? pieceOrWeight : pieceOrWeight.w;
  const top = topOf(pole);
  return pole.length < currentStackCapacity || (top && top.w === weight);
}

function hasAnyMove(pieceOrWeight){
  return poles.some(p => canPlaceOnPole(pieceOrWeight, p));
}

async function animateNextQueueAdvance(queueAlreadyModified = false, blockIndexToRemove = 0){
  logQueueState('queueAdvance-start');
  
  // Validate queue state before proceeding
  if (nextQueue.length < 3) {
    console.error('Queue has insufficient elements:', nextQueue.length);
    // Rebuild queue if corrupted
    nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
    renderNext();
    return;
  }
  
  // add consume animation to the block being removed
  const items = nextContainer.querySelectorAll('.next-disc');
  const current = items[0];
  const second = items[1];
  const third = items[2];
  
  // Animate the block being consumed
  if (blockIndexToRemove === 0 && current) {
    current.classList.add('consume-out');
  } else if (blockIndexToRemove === 1 && second) {
    second.classList.add('consume-out');
  } else if (blockIndexToRemove === 2 && third) {
    third.classList.add('consume-out');
  }
  
  // Shift remaining blocks left
  if (blockIndexToRemove === 0) {
    // First block removed, shift second and third left
    if (second) second.classList.add('shift-left');
    if (third) third.classList.add('shift-left');
  } else if (blockIndexToRemove === 1) {
    // Second block removed, shift third left
    if (third) third.classList.add('shift-left');
  }
  // If third block removed, no shifting needed

  // wait for ALL animations to complete before proceeding
  // Small delay to ensure CSS classes are applied and animations start
  await new Promise(resolve => setTimeout(resolve, 10));
  
  const animations = [];
  // Only wait for animations on blocks that are actually animating
  if (blockIndexToRemove === 0 && current) animations.push(waitForAnimation(current));
  if (blockIndexToRemove === 1 && second) animations.push(waitForAnimation(second));
  if (blockIndexToRemove === 2 && third) animations.push(waitForAnimation(third));
  
  // Also wait for shift animations
  if (blockIndexToRemove === 0) {
    if (second) animations.push(waitForAnimation(second));
    if (third) animations.push(waitForAnimation(third));
  } else if (blockIndexToRemove === 1) {
    if (third) animations.push(waitForAnimation(third));
  }
  
  // Wait for all animations to complete
  await Promise.all(animations);

  // Only update queue data if it hasn't already been modified
  if (!queueAlreadyModified) {
    // Reset bomb selection state when the queue advances (bomb was placed)
    bombSelected = false;
    // Reset trash mode when the queue advances
    trashMode = false;
    
    // Validate before modifying
    if (nextQueue.length > 0) {
      // Remove the specified block (0 for normal mode, 1 or 2 for swap mode)
      nextQueue.splice(blockIndexToRemove, 1);
      nextQueue.push(getRandomPiece());
    }
  }
  
  renderNext();
  
  // Update button states since queue changed
  updateBombButtonIfGoldChanged();
  updateTrashButtonIfGoldChanged();
  updatePickaxeButtonIfGoldChanged();
  updateSwapButtonState();
  
  logQueueState('queueAdvance-end');
}

async function animateSwapBlocks(){
  logQueueState('swapAnimation-start');
  
  // Set swap animating state to prevent block placement
  swapAnimating = true;
  
  // Validate queue state before proceeding
  if (nextQueue.length < 2) {
    console.error('Queue has insufficient elements for swap:', nextQueue.length);
    swapAnimating = false; // Reset state on error
    return;
  }
  
  // Get the first two blocks in the queue
  const items = nextContainer.querySelectorAll('.next-disc');
  const first = items[0];
  const second = items[1];
  
  if (!first || !second) {
    console.error('Could not find blocks to animate for swap');
    swapAnimating = false; // Reset state on error
    return;
  }
  
  // Add swap animation classes
  first.classList.add('swap-animation-1');
  second.classList.add('swap-animation-2');
  
  // Small delay to ensure CSS classes are applied and animations start
  await new Promise(resolve => setTimeout(resolve, 10));
  
  // Wait for both animations to complete
  const animations = [];
  animations.push(waitForAnimation(first));
  animations.push(waitForAnimation(second));
  
  await Promise.all(animations);
  
  // Remove animation classes
  first.classList.remove('swap-animation-1');
  second.classList.remove('swap-animation-2');
  
  // Reset transforms
  first.style.transform = '';
  second.style.transform = '';
  
  // Clear swap animating state to allow block placement again
  swapAnimating = false;
  
  logQueueState('swapAnimation-end');
}

function getElementPageRect(el){
  const r = el.getBoundingClientRect();
  return { left: r.left + window.scrollX, top: r.top + window.scrollY, width: r.width, height: r.height };
}



async function animateStageProgression(index, mergedIndex, weight){
  // Render so the merged block exists in the DOM
  render();
  const poleDiv = gameDiv.children[index];
  const discs = poleDiv.querySelectorAll('.disc');
  const mergedEl = discs[mergedIndex];
  if(!mergedEl){
    poles[index] = [];
    render();
    return;
  }

        // Let the new block behave like a normal merge result first
      mergedEl.classList.add('merge-in');
      
      // Small delay to ensure CSS class is applied and animation starts
      await new Promise(resolve => setTimeout(resolve, 10));
      
      await waitForAnimation(mergedEl);
      mergedEl.classList.remove('merge-in');

  // Now treat the target block like a bomb - make it explode and clear the entire stack
  const allDiscs = Array.from(poleDiv.querySelectorAll('.disc'));
  

    // Start the explosion from the merged block (target location) and propagate outward in both directions
    const targetIndex = mergedIndex; // The target block location
    
    // First, apply the bomb explosion effect to the target block itself
    const targetDisc = allDiscs[targetIndex];
    if (targetDisc) {
      targetDisc.classList.add('bomb-explosion');
      // Play stage up sound effect for the stage progression
      soundManager.playStageProgressionSound();
    }
    
    // Then apply the shockwave effect to other blocks with decreasing intensity
    for (let i = 0; i < allDiscs.length; i++) {
      if (i === targetIndex) continue; // Skip the target block, it already has explosion effect
      
      const disc = allDiscs[i];
      // Calculate distance from target location for wave propagation
      const distanceFromTarget = Math.abs(i - targetIndex);
      // Add a small delay to create the wave effect, starting from target location
      const delay = distanceFromTarget * 40; // 40ms delay per block distance for the ripple effect (faster)
      
      setTimeout(() => {
        disc.classList.add('bomb-ripple');
        // No more individual sound effects - just visual ripple effect
      }, delay);
    }
    
    // Wait for the entire explosion animation to complete
    const totalAnimationTime = Math.max(...Array.from({length: allDiscs.length}, (_, i) => 
      Math.abs(i - targetIndex) * 40 + 350
    )); // Max delay + 350ms animation duration (faster)
    await new Promise(resolve => setTimeout(resolve, totalAnimationTime));
    
    // Clean up the explosion and ripple classes
    allDiscs.forEach(d => {
      d.classList.remove('bomb-explosion');
      d.classList.remove('bomb-ripple');
    });

  // Clear the entire pole
  poles[index] = [];
  
  // Now create the new target block
  const newBlock = { w: weight, bomb: false };
  poles[index].push(newBlock);
  
  // Re-render to show the cleared stack with the new target block
  render();
}

async function animateClearPoleWithFallingBlock(index, mergedIndex, weight){
  // Render so the merged block exists in the DOM
  render();
  const poleDiv = gameDiv.children[index];
  const discs = poleDiv.querySelectorAll('.disc');
  const mergedEl = discs[mergedIndex];
  if(!mergedEl){
    poles[index] = [];
    render();
    return;
  }

  // Bombs no longer give gold rewards when clearing stacks



  // Let the new block behave like a normal merge result first
  mergedEl.classList.add('merge-in');
  
  // Small delay to ensure CSS class is applied and animation starts
  await new Promise(resolve => setTimeout(resolve, 10));
  
  await waitForAnimation(mergedEl);
  mergedEl.classList.remove('merge-in');

  // Create a shockwave ripple effect that propagates through the stack
  const allDiscs = Array.from(poleDiv.querySelectorAll('.disc'));
  
  // Start the explosion from the merged block (bomb location) and propagate outward in both directions
  const bombIndex = mergedIndex; // The bomb merge location
    
    // Track total bombs exploded
    totalBombsExploded++;
    
    // First, apply the bomb explosion effect to the bomb block itself
    const bombDisc = allDiscs[bombIndex];
    if (bombDisc) {
      bombDisc.classList.add('bomb-explosion');
      // Play bomb sound effect for the initial bomb explosion
      soundManager.playBombSound();
    }
    
    // Then apply the shockwave effect to other blocks with decreasing intensity
    for (let i = 0; i < allDiscs.length; i++) {
      if (i === bombIndex) continue; // Skip the bomb block, it already has explosion effect
      
      const disc = allDiscs[i];
      // Calculate distance from bomb location for wave propagation
      const distanceFromBomb = Math.abs(i - bombIndex);
      // Add a small delay to create the wave effect, starting from bomb location
      const delay = distanceFromBomb * 40; // 40ms delay per block distance for the ripple effect (faster)
      
      setTimeout(() => {
        disc.classList.add('bomb-ripple');
        // No more individual sound effects - just visual ripple effect
      }, delay);
    }
    
    // Wait for the entire explosion animation to complete
    const totalAnimationTime = Math.max(...Array.from({length: allDiscs.length}, (_, i) => 
      Math.abs(i - bombIndex) * 40 + 350
    )); // Max delay + 350ms animation duration (faster)
    await new Promise(resolve => setTimeout(resolve, totalAnimationTime));
    
    // Clean up the explosion and ripple classes
    allDiscs.forEach(d => {
      d.classList.remove('bomb-explosion');
      d.classList.remove('bomb-ripple');
    });

  // Clear pole and re-render
  poles[index] = [];
  render();
}

function choosePoleFor(pieceOrWeight){
  let avail = poles.map((p,i)=> ({p,i})).filter(x=> canPlaceOnPole(pieceOrWeight, x.p));
  if(avail.length === 0) {
    return null;
  }
  
  const piece = typeof pieceOrWeight === 'number' ? { w: pieceOrWeight, bomb: false } : pieceOrWeight;
  const isBomb = piece.bomb;
  
  // Helper function to check if a stack is "messy" (order disrupted)
  function isStackMessy(pole) {
    if (pole.length < 2) return false;
    for (let i = pole.length - 1; i > 0; i--) {
      if (pole[i].w >= pole[i-1].w) return true; // Order is disrupted
    }
    return false;
  }
  
  // Helper function to get stack height
  function getStackHeight(pole) {
    return pole.length;
  }
  
  // Helper function to get total point value of a stack
  function getStackValue(pole) {
    return pole.reduce((sum, disc) => sum + disc.w, 0);
  }
  
  // Helper function to check if placing this piece would create a merge
  function wouldCreateMerge(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w === piece.w;
  }
  
  // Helper function to check if placing this piece would be on a block exactly 1 size above
  function wouldBeOnExactSize(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w === piece.w * 2;
  }
  
  // Helper function to check if placing this piece would be on a larger block (but not exact size)
  function wouldBeOnLargerBlock(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w > piece.w;
  }
  
  // Check for bomb in queue (special case 1.5)
  const hasBombInQueue = nextQueue.some(p => p.bomb);
  const isBombMatch = hasBombInQueue && nextQueue.some(p => p.bomb && p.w === piece.w);
  
  if (!isBomb) {
    // NORMAL BLOCKS LOGIC
    
    // Priority 1: Merges (100% override)
    const mergeOptions = avail.filter(x => wouldCreateMerge(x.p, piece));
    if (mergeOptions.length > 0) {
      return mergeOptions[0].i;
    }
    
    // Priority 1.5: Avoid placing normal blocks on stacks with bombs anywhere in them
    // This prevents cutting off bombs from being able to merge and clear the stack
    const bombAvoidanceOptions = avail.filter(x => {
      if (x.p.length === 0) return true; // Empty stack is fine
      
      // Check if there's a bomb anywhere in the stack
      const hasBombInStack = x.p.some(disc => disc.bomb);
      
      if (hasBombInStack) {
        // If there's a bomb in the stack, only allow placement if:
        // 1. The block is smaller than the bomb it would be placed on, OR
        // 2. We're placing on an empty stack (which shouldn't happen here, but safety check)
        const top = x.p[x.p.length - 1];
        if (top.bomb) {
          // Placing on a bomb - only allow if block is smaller
          return piece.w < top.w;
        } else {
          // Placing above a bomb - this would cut off the bomb, so never allow larger blocks
          return piece.w < top.w;
        }
      }
      
      return true; // No bomb in stack, so placement is fine
    });
    
    // If we have no valid options after bomb avoidance, fall back to all available
    if (bombAvoidanceOptions.length === 0) {
      // This should rarely happen, but if it does, we'll use the original avail list
      console.warn('AI: No bomb-avoidance options available, using fallback');
    } else {
      // Use the filtered options for the rest of the logic
      avail = bombAvoidanceOptions;
    }
    
    // Priority 2: Special case - bomb match in queue
    if (isBombMatch) {
      const messyStacks = avail.filter(x => isStackMessy(x.p));
      if (messyStacks.length > 0) {
        return messyStacks[0].i;
      }
    }
    
    // Priority 3: Place on block exactly 1 size above
    const exactSizeOptions = avail.filter(x => wouldBeOnExactSize(x.p, piece));
    if (exactSizeOptions.length > 0) {
      // Prefer stacks with less height if multiple options
      exactSizeOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
      return exactSizeOptions[0].i;
    }
    
    // Priority 4: Place on larger block (but not exact size)
    const largerBlockOptions = avail.filter(x => wouldBeOnLargerBlock(x.p, piece));
    if (largerBlockOptions.length > 0) {
      // Prefer messy stacks, then by height
      const messyOptions = largerBlockOptions.filter(x => isStackMessy(x.p));
      const cleanOptions = largerBlockOptions.filter(x => !isStackMessy(x.p));
      
      if (messyOptions.length > 0) {
        // Choose messiest stack among messy options
        messyOptions.sort((a, b) => {
          // Count how many order violations each stack has
          const getViolations = (pole) => {
            let violations = 0;
            for (let i = pole.length - 1; i > 0; i--) {
              if (pole[i].w >= pole[i-1].w) violations++;
            }
            return violations;
          };
          return getViolations(b.p) - getViolations(a.p); // More violations = messier
        });
        return messyOptions[0].i;
      } else {
        // All stacks are clean, choose by height
        cleanOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
        return cleanOptions[0].i;
      }
    }
    
    // Priority 5: Place on smaller block or empty stack
    const remainingOptions = avail.filter(x => !wouldBeOnLargerBlock(x.p, piece));
    if (remainingOptions.length > 0) {
      // Prefer messy stacks, then by height
      const messyOptions = remainingOptions.filter(x => isStackMessy(x.p));
      const cleanOptions = remainingOptions.filter(x => !isStackMessy(x.p));
      
      if (messyOptions.length > 0) {
        // Choose messiest stack among messy options
        messyOptions.sort((a, b) => {
          const getViolations = (pole) => {
            let violations = 0;
            for (let i = pole.length - 1; i > 0; i--) {
              if (pole[i].w >= pole[i-1].w) violations++;
            }
            return violations;
          };
          return getViolations(b.p) - getViolations(a.p);
        });
        return messyOptions[0].i;
      } else {
        // All stacks are clean, choose by height
        cleanOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
        return cleanOptions[0].i;
      }
    }
    
  } else {
    // BOMB LOGIC
    
    // Priority 1: Tallest, messiest stack
    const messyStacks = avail.filter(x => isStackMessy(x.p));
    if (messyStacks.length > 0) {
      // Sort by height first, then by messiness
      messyStacks.sort((a, b) => {
        const heightDiff = getStackHeight(b.p) - getStackHeight(a.p);
        if (Math.abs(heightDiff) > 0) return heightDiff;
        
        // If heights are equal, sort by messiness
        const getViolations = (pole) => {
          let violations = 0;
          for (let i = pole.length - 1; i > 0; i--) {
            if (pole[i].w >= pole[i-1].w) violations++;
          }
          return violations;
        };
        return getViolations(b.p) - getViolations(a.p);
      });
      return messyStacks[0].i;
    }
    
    // Priority 2: Must place on clean stack - choose lowest total value
    const cleanStacks = avail.filter(x => !isStackMessy(x.p));
    if (cleanStacks.length > 0) {
      cleanStacks.sort((a, b) => getStackValue(a.p) - getStackValue(b.p));
      return cleanStacks[0].i;
    }
  }
  
  // Fallback: return first available pole
  return avail[0].i;
}

function aiStep(){
  if(placing) {
    return;
  }
  
  // Safety check: if placing has been true for too long, reset it
  if (placing && Date.now() - lastPlacementTime > 10000) { // 10 second timeout
    console.warn('AI: Placement timeout detected, resetting placing flag');
    placing = false;
    
    // Re-enable hover effects and pointer events on all poles
    const allPoles = Array.from(gameDiv.children);
    allPoles.forEach(poleDiv => {
      poleDiv.style.pointerEvents = '';
      poleDiv.classList.remove('no-hover');
    });
  }
  
  // if game over, nothing to do
  const pick = choosePoleFor(nextQueue[0]);
  if(pick === null) { 
    checkGameOver(); 
    return; 
  }
  
  placeOnPole(pick);
}





// Initial render will happen after game state loading

// Initialize stack height
updateStackHeight();

// Initialize displays with proper formatting
updateScoreDisplay();
updateGoldDisplay();

// Set up auto-save system
setupAutoSave();

// Safety check: ensure we start with exactly 4 poles
// Only run after a short delay to ensure DOM is ready
setTimeout(() => {
  if (gameDiv && gameDiv.children) {
    ensureCorrectPoleCount();
  }
}, 100);

// Initialize debug pane - Block grid interface
document.addEventListener('DOMContentLoaded', () => {
  // Set initial selection to "No Block" option
  const noBlockOption = document.querySelector('.block-item[data-value="none"]');
  if (noBlockOption) {
    noBlockOption.classList.add('selected');
    customBlockSize = null;
    customBlockMode = false;
  }
  

  
  // Initial render is handled after game state loading
});

if (bombToggle && bombStatus) {
  bombToggle.checked = false;
  bombStatus.textContent = 'No';
  customBlockBomb = false;
}



// Initialize all powerup button states
updateAllPowerupButtonStates();

// Initialize powerup button visibility
updatePowerupButtonVisibility();

// Handle window resize for mobile responsiveness
window.addEventListener('resize', () => {
  updateStackHeight();
});

// GitHub Pages redirect fix - if we're on the wrong page, redirect to the game
(function() {
  // Check if we're on the right page by looking for game elements
  if (!document.getElementById('game')) {
    // We're probably on the README page, redirect to the game
    window.location.href = window.location.href;
  }
})();

// Global safety check to ensure we always have exactly 4 poles
function ensureCorrectPoleCount() {
  // Add cooldown to prevent too frequent checks
  if (window.lastSafetyCheck && Date.now() - window.lastSafetyCheck < 5000) {
    return; // Wait at least 5 seconds between safety checks
  }
  
  // Only run safety checks if the game is properly initialized
  if (!gameDiv || !gameDiv.children) {
    return; // Game not ready yet
  }
  
  // Check if we're currently in the middle of a render operation
  if (window.isRendering) {
    return; // Skip check during render to avoid interference
  }
  
  // Check if the game is still initializing
  if (typeof poles === 'undefined' || poles.length === 0) {
    return; // Game not fully initialized yet
  }
  
  // Check if the game is still in the initial loading phase
  if (window.gameInitializing) {
    return; // Game is still initializing, skip safety checks
  }
  
  if (poles.length !== 4) {
    console.warn(`Warning: Global pole count check found ${poles.length} poles instead of 4! Resetting to 4 poles.`);
    poles = [[],[],[],[]];
    // Force a re-render to fix the display
    render();
    return;
  }
  
  // Only check DOM if we have a valid gameDiv and it's not empty
  if (gameDiv.children.length === 0) {
    // DOM is empty, this might be during initial load - don't trigger re-render
    return;
  }
  
  // Only trigger re-render if we're significantly off (not just 1 element difference)
  // This prevents unnecessary re-renders for minor DOM inconsistencies
  if (gameDiv.children.length < 3 || gameDiv.children.length > 5) {
    console.warn(`Warning: DOM contains ${gameDiv.children.length} pole elements instead of 4! Re-rendering...`);
    render();
  }
  
  // Update last safety check timestamp
  window.lastSafetyCheck = Date.now();
}

// Run safety check every 15 seconds (less frequent to reduce interference)
// Start after a delay to ensure game is fully initialized
setTimeout(() => {
  setInterval(ensureCorrectPoleCount, 15000);
}, 2000);

// Additional safety check for the placing flag to prevent game freezes
setTimeout(() => {
  setInterval(() => {
    if (placing && Date.now() - lastPlacementTime > 10000) {
      console.warn('Placing flag stuck for more than 10 seconds, forcing reset');
      placing = false;
      
      // Re-enable hover effects and pointer events
      const allPoles = Array.from(gameDiv.children);
      allPoles.forEach(poleDiv => {
        poleDiv.style.pointerEvents = '';
        poleDiv.classList.remove('no-hover');
      });
    }
  }, 5000); // Check every 5 seconds
}, 5000);

function testProbabilityDistribution() {

  
  // Simulate 1000 random selections to test distribution
  const results = {};
  const iterations = 1000;
  
  for (let i = 0; i < iterations; i++) {
    const weight = getRandomWeight();
    results[weight] = (results[weight] || 0) + 1;
  }
  
  // Create the results table HTML
  let tableHTML = `
    <table class="prob-test-table">
      <thead>
        <tr>
          <th>Block</th>
          <th>Expected</th>
          <th>Actual</th>
          <th>Difference</th>
        </tr>
      </thead>
      <tbody>
  `;
  
  let totalExpected = 0;
  let totalActual = 0;
  
  for (const weight of weights) {
    const count = results[weight] || 0;
    const actualProb = count / iterations;
    const expectedProb = probabilities[weights.indexOf(weight)];
    const difference = Math.abs(actualProb - expectedProb);
    
    totalExpected += expectedProb;
    totalActual += actualProb;
    
    tableHTML += `
      <tr>
        <td class="block-value">${weight}</td>
        <td class="expected">${(expectedProb * 100).toFixed(2)}%</td>
        <td class="actual">${(actualProb * 100).toFixed(2)}%</td>
        <td class="difference">${(difference * 100).toFixed(2)}%</td>
      </tr>
    `;
    

  }
  
  tableHTML += `
      </tbody>
    </table>
    
    <div class="prob-test-summary">
      <div class="total">Total Probability: ${(totalExpected * 100).toFixed(2)}% (Expected) vs ${(totalActual * 100).toFixed(2)}% (Actual)</div>
    </div>
  `;
  
  // Populate the modal content
  const contentDiv = document.getElementById('probTestContent');
  if (contentDiv) {
    contentDiv.innerHTML = tableHTML;
  }
  
  // Show the modal
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.remove('hidden');
  }
  

}

// Modal functionality
function showProbabilityTestModal() {
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.remove('hidden');
  }
}

function hideProbabilityTestModal() {
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.add('hidden');
  }
}

function logProbabilityState() {
  // Probability state logging removed
}

// Test probabilities button
const testProbBtn = document.getElementById('testProbBtn');
testProbBtn.addEventListener('click', testProbabilityDistribution);





// Cascade test button
const cascadeTestBtn = document.getElementById('cascadeTestBtn');
if (cascadeTestBtn) {
  cascadeTestBtn.addEventListener('click', () => {
  // Clear the first column (pole 0)
  poles[0] = [];
  
  // Create a perfect cascade stack from 512 to 1
  // This will create the largest possible cascade when blocks are dropped
  const cascadeValues = [512, 256, 128, 64, 32, 16, 8, 4, 2, 1];
  
  cascadeValues.forEach(value => {
    poles[0].push({ w: value, bomb: false });
  });
  
  // Re-render the game to show the new stack
  render();
  
  // Automatically place a 1 block at the top to start the cascade
  // We need to temporarily set placing to false to allow the placement
  const originalPlacing = placing;
  placing = false;
  
  // Place the 1 block on top of the stack
  const nextPiece = { w: 1, bomb: false };
  poles[0].push(nextPiece);
  
  // Play drop sound effect
  soundManager.playDropSound(nextPiece.w);
  
  // Re-render to show the new block
  render();
  
  // Trigger the merge cascade automatically
  animateMergeCascade(0).then(() => {
    // Cascade test completed successfully
  }).catch(error => {
    console.error('❌ Cascade test error:', error);
  });
  
  // Save game state after cascade test setup
  saveGameState();
  });
}

// Probability test modal close button
const probTestClose = document.getElementById('probTestClose');
if (probTestClose) {
  probTestClose.addEventListener('click', hideProbabilityTestModal);
}

// Close probability test modal when clicking outside
const probTestModal = document.getElementById('probTestModal');
if (probTestModal) {
  probTestModal.addEventListener('click', (e) => {
    if (e.target === probTestModal) {
      hideProbabilityTestModal();
    }
  });
}



// Add keyboard support for probability test modal
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (probTestModal && !probTestModal.classList.contains('hidden')) {
      hideProbabilityTestModal();
    }
  }
});

// Initialize the game after all functions are defined

try {
  // Initialize safe viewport calculation for mobile devices
  const initialSafeViewport = calculateSafeViewport();
  
  // Set up initial probability distribution for the starting block sizes (1 and 2)
  updateProbabilityDistribution();

  // Initialize next queue after probability distribution is set up
  nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
  
  // localStorage is our primary storage method
  
  // Set game initializing flag
  window.gameInitializing = true;
  
  // Reset the prevent save flag (in case it was set from a previous clear operation)
  preventGameStateSave = false;
  
  // Now try to load saved game state
  const gameLoaded = loadGameState();
  
  // If no game loaded, ensure unlock status is reset to defaults
  // (but only if we're not in a clear operation)
  if (!gameLoaded && themeManager && !window.preventThemeUnlockLoad) {
    themeManager.themeUnlockRequirements = {
      'jellyfish': { unlocked: true, requirement: 'Default theme' },
      'alternate': { unlocked: false, requirement: 'Score 5000+ points' },
      'miner': { unlocked: false, requirement: '?' }
    };
    themeManager.saveUnlockStatus();
  }
  
  // Force a render after loading (or if loading failed)
  render();
  renderNext();
  
  // Update shop display after loading game state
  updateShopDisplay();
  

  
  // Update powerup button visibility based on purchase history
  updatePowerupButtonVisibility();
  
  // Button sizing is now handled automatically by CSS
  
  // Game is now fully initialized
  window.gameInitializing = false;
  
  // Initialize theme after game is fully rendered
  if (themeManager) {
    themeManager.initializeTheme();
  }
  
  // Update theme selectors to show unlock status
  if (typeof updateThemeSelectors === 'function') {
    updateThemeSelectors();
  }
  
  // Update debug block colors after theme initialization
  if (typeof updateDebugBlockColors === 'function') {
    updateDebugBlockColors();
  }
  
  // Check for first-time users and show welcome modal
  setTimeout(() => {
    try {
      console.log('🔍 Debug: lastSeenUpdateTimestamp =', lastSeenUpdateTimestamp);
      // If this is a first-time user, show the welcome modal
      if (lastSeenUpdateTimestamp === 0) {
        console.log('👋 Showing welcome modal for first-time user');
        showWelcomeModal();
      } else {
        console.log('👋 Returning user detected, no welcome modal needed');
      }
    } catch (error) {
      console.error('❌ Failed to check for first-time user:', error);
    }
  }, 1000); // Delay to ensure UI is fully rendered
  
  // Initialize help button glow for new players
  if (helpBtn) {
    if (!hasHelpButtonBeenClicked()) {
      helpBtn.classList.add('help-glow');
    }
  }
  
  // Force scroll to top to prevent phantom scroll issues
  window.scrollTo(0, 0);
  if (window.visualViewport) {
    window.visualViewport.scrollTop = 0;
  }
  
  // Add window load event listener to ensure scroll stays at top
  window.addEventListener('load', () => {
    setTimeout(() => {
      window.scrollTo(0, 0);
      if (window.visualViewport) {
        window.visualViewport.scrollTop = 0;
      }
    }, 100); // Small delay to ensure everything is fully loaded
  });
  
  // Add persistent scroll reset to catch browser restoration
  let scrollResetAttempts = 0;
  const maxScrollResetAttempts = 10;
  
  const persistentScrollReset = () => {
    if (scrollResetAttempts >= maxScrollResetAttempts) return;
    
    const currentScrollY = window.scrollY || 0;
    const currentVisualScrollTop = window.visualViewport ? window.visualViewport.scrollTop : 0;
    
    if (currentScrollY > 0 || currentVisualScrollTop > 0) {
      window.scrollTo(0, 0);
      if (window.visualViewport) {
        window.visualViewport.scrollTop = 0;
      }
      scrollResetAttempts++;
      
      // Try again after a short delay
      setTimeout(persistentScrollReset, 200);
    }
  };
  
  // Start persistent scroll reset after a delay
  setTimeout(persistentScrollReset, 500);
  

  
} catch (error) {
  console.error('❌ Error during game initialization:', error);
  console.error('Error stack:', error.stack);
}

</script>



</body></html>
</body></html>