<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Stack Merge</title>
<link rel="icon" type="image/png" href="favicon.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Quantico:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
  :root{ 
    --bg:#0f172a; 
    --panel:#1e293b; 
    --text:#f8fafc; 
    --font-family: 'Quantico', monospace;
  }
  body { 
    margin:0; 
    font-family: var(--font-family); 
    background:var(--bg); 
    color:var(--text); 
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    height: 100vh; /* Lock page height to exactly viewport height */
    overflow: hidden; /* Prevent any scrolling */
  }
  .topbar { width:100%; max-width:1200px; display:flex; flex-direction:column; align-items:center; gap:24px; padding:24px 16px 8px; box-sizing:border-box; }
  h1 { margin:0; font-size:36px; font-weight:700; text-align:center; font-family: var(--font-family); }
  
  /* Title section styling */
  .title-section { 
    display: flex; 
    flex-direction: row; 
    align-items: center; 
    width: 100%;
    position: relative;
    margin-top: 24px;
    margin-bottom: 24px;
  }
  
  /* Left section - positioned to the left of center */
  .title-section .left-section {
    position: absolute;
    right: calc(50% + 180px);
    display: flex;
    align-items: center;
    gap: 16px;
  }
  
  /* Center section - absolutely centered title */
  .title-section .center-section {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
  }
  
  /* Right section - positioned to the right of center */
  .title-section .right-section {
    position: absolute;
    left: calc(50% + 180px);
    display: flex;
    align-items: center;
    gap: 16px;
  }
  
  /* Title button styling */
  .title-btn {
    background: var(--panel);
    color: var(--text);
    border: 1px solid #475569;
    width: 48px;
    height: 48px;
    border-radius: 10px;
    font-weight: 700;
    font-size: 24px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    font-family: var(--font-family);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  
  .title-btn:hover {
    background: #334155;
    border-color: #64748b;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(0,0,0,0.25);
  }
  
  .title-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
  }
  
  /* Glowing ➕ button after game over */
  .title-btn.game-over-glow {
    box-shadow: 0 0 8px rgba(14, 165, 233, 0.5), 0 0 12px rgba(14, 165, 233, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    animation: breatheGlow 2s ease-in-out infinite;
  }
  
  /* Sound button states */
  .title-btn#soundBtn {
    transition: all 0.2s ease;
  }
  
  .title-btn#soundBtn:hover {
    transform: scale(1.05);
  }
  
  /* Merge sound button states */
  .title-btn#mergeSoundBtn {
    transition: all 0.2s ease;
  }
  
  .title-btn#mergeSoundBtn:hover {
    transform: scale(1.05);
  }
  
  /* Pop sound button special styling */
  .title-btn#mergeSoundBtn[title*="pop"] {
    background: linear-gradient(135deg, var(--panel) 0%, #374151 100%);
  }
  
  /* Disabled musical sound button styling */
  .title-btn#mergeSoundBtn[title*="musical"] {
    opacity: 0.5;
    filter: grayscale(0.8);
    background: linear-gradient(135deg, var(--panel) 0%, #4a5568 100%);
  }
  
  .title-btn#mergeSoundBtn[title*="musical"]:hover {
    opacity: 0.7;
    filter: grayscale(0.6);
  }
  
  @keyframes breatheGlow {
    0%, 100% { 
      box-shadow: 0 0 8px rgba(14, 165, 233, 0.5), 0 0 12px rgba(14, 165, 233, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    }
    50% { 
      box-shadow: 0 0 12px rgba(14, 165, 233, 0.7), 0 0 16px rgba(14, 165, 233, 0.5), 0 3px 0 rgba(0,0,0,0.25);
    }
  }
  
  /* Mobile responsive sizing for title buttons */
  @media (max-width: 768px) {
    .title-btn {
      width: 38px;
      height: 38px;
      border-radius: 8px;
      font-size: 20px;
    }
    
    .title-section {
      gap: 16px;
    }
  }
  
  /* Mobile responsive spacing for title sections */
  @media (max-width: 768px) {
    .title-section .left-section {
      right: calc(50% + 110px);
      gap: 8px; /* Reduced gap between buttons on mobile */
    }
    
    .title-section .right-section {
      left: calc(50% + 110px);
      gap: 8px; /* Reduced gap between buttons on mobile */
    }
  }
  
  /* Extra small mobile devices - adjust title section spacing */
  @media (max-width: 480px) {
    .title-section {
      gap: 12px;
    }
    
    .title-btn {
      width: 36px;
      height: 36px;
      border-radius: 7px;
      font-size: 18px;
    }
    
    .title-section .left-section {
      gap: 8px; /* Slightly larger gap for better touch targets */
    }
    
    .title-section .right-section {
      gap: 8px; /* Slightly larger gap for better touch targets */
    }
  }
  
  /* Disable hover effects on mobile/touch devices */
  @media (hover: none) and (pointer: coarse) {
    .title-btn:hover {
      background: var(--panel);
      border-color: #475569;
      transform: none;
      box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    }
    
    .title-btn#soundBtn:hover {
      transform: none;
    }
    
    .title-btn#mergeSoundBtn:hover {
      transform: none;
    }
    
    .title-btn#mergeSoundBtn[title*="musical"]:hover {
      opacity: 0.5;
      filter: grayscale(0.8);
    }
  }
  

  
  /* Controls section styling */
  .controls { display:flex; align-items:center; gap:18px; }

  .game-info { display: flex; justify-content: center; gap: 48px; margin-top: 40px; /* Increased spacing between title and game info */ }
  .score-display { display:flex; flex-direction:column; align-items:center; gap:12px; }
  .score-label { font-size:18px; opacity:0.9; font-family: var(--font-family); }
  .next { display:flex; flex-direction:column; align-items:center; gap:12px; }
  .next .label { font-size:18px; opacity:0.9; font-family: var(--font-family); }
  .next-row { display:flex; align-items:center; gap:12px; }
  .next-disc { width:108px; height:45px; border-radius:9px; display:flex; align-items:center; justify-content:center; font-weight:600; font-size:24px; box-shadow:0 3px 0 rgba(0,0,0,0.25); transition: transform calc(0.18s * var(--animation-speed, 1)) ease; font-family: var(--font-family); transform-origin: center center; }
  .next-disc.current { outline:3px solid #fff; outline-offset:3px; }
  .next-disc.consume-out { animation: nextConsume calc(0.18s * var(--animation-speed, 1)) ease forwards; }
  @keyframes nextConsume {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0.85); opacity: 0; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .next-disc.consume-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.85); opacity: 0; }
  .next-disc.shift-left { transform: translateX(-120px); }
  
  /* Instant animations when speed is 0 (Blazing) */
  .next-disc.shift-left[style*="--animation-speed: 0"] { transform: translateX(-120px); }


  
  /* Score value styling to match other modules */
  .score-value { 
    background: var(--panel); 
    color: var(--text); 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 24px; 
    min-width: 70px; 
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
  }
  
  /* Score star emoji styling as a badge in top left corner */
  .score-star {
    position: absolute;
    top: -12px;
    left: -12px;
    font-size: 28px;
    opacity: 1;
    z-index: 1;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }
  
  .score-text {
    position: relative;
    z-index: 2;
    font-size: 28px;
    font-weight: 600;
    line-height: 1;
    font-family: var(--font-family);
  }

  /* Gold display styling to match score display */
  .gold-display { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 12px; 
  }
  .gold-label { 
    font-size: 18px; 
    opacity: 0.9; 
    font-family: var(--font-family);
  }
  .gold-value { 
    background: #FCD34D; 
    color: #000; 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 24px; 
    min-width: 70px; 
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
  }
  
  /* Gold emoji styling as a badge in top left corner */
  .gold-emoji {
    position: absolute;
    top: -12px;
    left: -12px;
    font-size: 28px;
    opacity: 1;
    z-index: 1;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }
  
  .gold-text {
    position: relative;
    z-index: 2;
    font-size: 28px !important;
    font-weight: 600;
    line-height: 1;
    font-family: var(--font-family);
  }
  
  /* Stage multiplier badge styling centered on lower edge of gold counter */
  .stage-multiplier-badge {
    position: absolute;
    bottom: -16px;
    left: 50%;
    transform: translateX(-50%);
    background: #dc2626;
    color: white;
    font-size: 12px;
    font-weight: 700;
    padding: 4px 6px;
    border-radius: 8px;
    border: 2px solid var(--bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 1;
    font-family: var(--font-family);
    min-width: 20px;
    text-align: center;
    line-height: 1;
    box-sizing: border-box;
    white-space: nowrap;
  }
  
  /* Stage multiplier badge pulse animation */
  .stage-multiplier-badge.pulse {
    animation: stageBadgePulse 0.6s ease-out;
  }
  
  @keyframes stageBadgePulse {
    0% { transform: translateX(-50%) scale(1); }
    50% { transform: translateX(-50%) scale(1.2); }
    100% { transform: translateX(-50%) scale(1); }
  }
  
  /* Score count pulse animation */
  .score-value.pulse {
    animation: scorePulse 0.3s ease-out;
  }
  
  @keyframes scorePulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  
  /* Gold earned animation */
  .gold-earned {
    position: fixed;
    color: #FCD34D;
    font-weight: 700;
    font-size: 20px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
    z-index: 1000;
    pointer-events: none;
    animation: goldEarned 1.2s ease-out forwards;
  }
  
  @keyframes goldEarned {
    0% {
      opacity: 0;
      transform: translateY(0) scale(0.8);
    }
    15% {
      opacity: 1;
      transform: translateY(-15px) scale(1.2);
    }
    70% {
      opacity: 1;
      transform: translateY(-45px) scale(1.1);
    }
    100% {
      opacity: 0;
      transform: translateY(-65px) scale(1);
    }
  }
  
  /* Gold count pulse animation */
  .gold-value.pulse {
    animation: goldPulse 0.3s ease-out;
  }
  
  @keyframes goldPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }

  /* Bomb conversion button pulse animation */
  .bomb-conversion-btn.pulse {
    animation: bombBtnPulse 0.3s ease-out;
  }
  
  @keyframes bombBtnPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  
  /* Trash button pulse animation */
  .trash-btn.pulse {
    animation: trashBtnPulse 0.3s ease-out;
  }
  
  @keyframes trashBtnPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }

  /* AI button styling to match score-value and interface */
  .ai-btn {
    background: var(--panel);
    color: var(--text);
    border: 1px solid #475569;
    padding: 12px 24px;
    border-radius: 9px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    font-family: var(--font-family);
  }
  .ai-btn:hover {
    background: #334155;
    border-color: #64748b;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(0,0,0,0.25);
  }
  .ai-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
  }
  


  .hidden { display:none !important; }

  /* Help modal */
  .modal-backdrop { 
    position:fixed; 
    inset:0; 
    background:rgba(0,0,0,0.6); 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    z-index:1000; 
    /* Ensure backdrop respects safe areas */
    padding: env(safe-area-inset-top, 0px) env(safe-area-inset-left, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-right, 0px);
    box-sizing: border-box;
  }
  .modal { 
    background:var(--panel); 
    color:var(--text); 
    width:min(720px, 92vw); 
    border-radius:16px; 
    padding:24px 28px; 
    box-shadow:0 15px 45px rgba(0,0,0,0.4); 
    font-family: var(--font-family); 
    /* Ensure modal respects safe areas */
    max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 80px);
  }
  .modal h2 { margin:0 0 12px; font-size:24px; font-family: var(--font-family); }
  .modal p, .modal li { font-size:16px; line-height:1.5; font-family: var(--font-family); }
  .modal ul { margin:12px 0 0 24px; padding:0; }
  .modal .actions { display:flex; justify-content:flex-end; margin-top:18px; }
  
  /* Mobile responsive sizing for help modal stage progression elements */
  @media (max-width: 768px) {
    /* Ensure modal is properly positioned on mobile with safe areas */
    .help-modal {
      max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 80px);
      margin: 0;
      padding: 20px;
      /* Ensure content is properly spaced from edges */
      box-sizing: border-box;
    }
    
    /* Ensure modal title has proper spacing */
    .help-modal h2 {
      margin-top: 0;
      padding-top: 0;
    }
    
    /* Ensure close button has proper spacing */
    .help-modal .actions {
      margin-bottom: 0;
      padding-bottom: 0;
    }
    
    /* Make target blocks smaller in help modal */
    .help-modal .next-stage-block {
      width: 70px !important;
      height: 32px !important;
      font-size: 16px !important;
    }
    
    /* Make gold displays smaller in help modal */
    .help-modal .gold-value {
      padding: 6px 12px !important;
      font-size: 16px !important;
      min-width: 60px !important;
    }
    
    /* Make gold emojis smaller in help modal */
    .help-modal .gold-emoji {
      font-size: 18px !important;
      top: -6px !important;
      left: -6px !important;
    }
    
    /* Make gold text smaller in help modal */
    .help-modal .gold-text {
      font-size: 16px !important;
    }
    
    /* Make stage multiplier badges smaller in help modal */
    .help-modal .stage-multiplier-badge {
      font-size: 10px !important;
      padding: 2px 4px !important;
      bottom: -10px !important;
      min-width: 16px !important;
    }
    
    /* Reduce gaps in help modal stage progression */
    .help-modal .merge-example[style*="gap: 40px"] {
      gap: 16px !important;
    }
    
    .help-modal [style*="gap: 40px"] {
      gap: 16px !important;
    }
    
    /* Make the stage progression examples more compact on mobile */
    .help-modal [style*="max-width: 600px"] {
      max-width: 90vw !important;
    }
  }

  /* Enhanced Help Modal Styles */
  .help-modal { 
    width: min(900px, 95vw); 
    max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 80px); 
    overflow-y: auto; 
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    /* Ensure modal fits within safe area */
    margin: 0;
    position: relative;
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) */
  .help-modal::-webkit-scrollbar {
    display: none;
  }
  
  .help-grid { 
    display: flex; 
    flex-direction: column; 
    gap: 24px; 
    margin: 24px 0; 
  }
  
  .help-section { 
    background: #334155; 
    border-radius: 12px; 
    padding: 20px; 
    border: 1px solid #475569; 
  }
  
  .help-section-header { 
    display: flex; 
    align-items: center; 
    gap: 12px; 
    margin-bottom: 16px; 
  }
  
  .help-icon { 
    font-size: 24px; 
    opacity: 0.9; 
  }
  
  .help-section h3 { 
    margin: 0; 
    font-size: 18px; 
    font-weight: 600; 
    color: #f8fafc; 
  }
  
  .help-content p { 
    margin: 8px 0; 
    font-size: 14px; 
    line-height: 1.4; 
  }
  
  .help-content p:first-child { 
    margin-top: 0; 
  }
  
  .merge-example { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    gap: 20px; 
    margin: 16px 0; 
    padding: 20px; 
    background: #1e293b; 
    border-radius: 8px; 
    flex-wrap: wrap; 
  }
  
  .merge-before, .merge-after { 
    text-align: center; 
  }
  
  .merge-label { 
    display: block; 
    font-size: 12px; 
    color: #94a3b8; 
    margin-bottom: 8px; 
    font-weight: 500; 
  }
  
  .merge-blocks { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 8px; 
  }
  
  .merge-block { 
    width: 108px; 
    height: 42px; 
    border-radius: 9px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    font-weight: 700; 
    font-size: 24px; 
    box-shadow: 0 3px 0 rgba(0,0,0,0.25); 
    font-family: var(--font-family);
  }
  
  .merge-block.block-1 { 
    background: #cfef08; 
    color: #000; 
  }
  
  .merge-block.block-2 { 
    background: #10B981; 
    color: #fff; 
  }
  
  .merge-block.block-4 { 
    background: #2563EB; 
    color: #fff; 
  }
  
  .merge-block.block-8 { 
    background: #7C3AED; 
    color: #fff; 
  }
  
  .merge-block.block-16 { 
    background: #581C87; 
    color: #fff; 
  }
  
  .merge-block.block-32 { 
    background: #D946EF; 
    color: #fff; 
  }
  
  .merge-block.block-64 { 
    background: #EC4899; 
    color: #fff; 
  }
  
  .merge-block.block-128 { 
    background: #e86758; 
    color: #fff; 
  }
  
  .merge-block.block-256 { 
    background: #F59E0B; 
    color: #fff; 
  }
  
  .merge-block.block-512 { 
    background: #ea580c; 
    color: #fff; 
  }
  
  .merge-block.bomb-block {
    width: 108px;
    height: 42px;
    border-radius: 9px;
    background: #000;
    color: white;
    position: relative;
    overflow: hidden;
  }
  
  .merge-block.bomb-block .bomb-content {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  .merge-block.bomb-block .bomb-emoji {
    position: absolute;
    top: -3px;
    left: -21px;
    font-size: 42px;
    opacity: 1;
    z-index: 1;
  }
  
  .merge-block.bomb-block .bomb-text {
    position: relative;
    z-index: 2;
    font-size: 24px;
    font-weight: 700;
    font-family: var(--font-family);
  }
  
  .merge-block.explosion {
    background: #F59E0B;
    color: white;
    font-size: 32px;
    width: 108px;
    height: 42px;
    border-radius: 9px;
  }
  
  .merge-arrow { 
    font-size: 20px; 
    color: #94a3b8; 
    font-weight: 600; 
  }
  
  .help-footer { 
    text-align: center; 
    margin: 24px 0 16px; 
    padding: 16px; 
    background: #334155; 
    border-radius: 8px; 
    border: 1px solid #475569; 
  }
  
  .help-footer p { 
    margin: 0; 
    font-size: 16px; 
    color: #f8fafc; 
  }

  .game-container {
    display: flex;
    align-items: flex-start;
    margin-top: 32px;
    padding-bottom: 28px;
    justify-content: center;
    position: relative;
  }
  
  .game { 
    display: flex; 
    gap: 24px; 
    justify-content: center; 
    flex-wrap: wrap;
    position: relative;
  }
  

  
  .bottom-actions { 
    display: flex; 
    justify-content: center; 
    align-items: center;
    gap: 18px;
    margin-top: 18px; 
  }
  
  /* Powerup Shop - Grid Layout */
  .powerup-shop {
    position: absolute;
    left: calc(100% + 20px);
    top: 0;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  
  .shop-grid {
    display: flex;
    flex-direction: column;
    gap: 16px;
    align-items: flex-start;
  }
  
  .powerup-btn {
    background: var(--panel);
    color: var(--text);
    border: 2px solid #DC2626;
    min-width: 80px;
    min-height: 80px;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(220, 38, 38, 0.25);
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: flex-start;
    font-family: var(--font-family);
    pointer-events: auto;
    gap: 8px;
    position: relative;
    padding: 0 12px;
  }
  
  .powerup-btn:hover {
    border: 3px solid #0ea5e9;
    background: #334155;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(220, 38, 38, 0.3);
  }
  
  .powerup-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(220, 38, 38, 0.25);
  }
  
  .powerup-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 2px 0 rgba(220, 38, 38, 0.2);
  }
  
  .powerup-btn.affordable {
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1);
  }
  
  .powerup-btn.affordable:hover {
    border: 3px solid #0ea5e9;
    background: #334155;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(14, 165, 233, 0.3);
  }
  
  /* Undo mode styling - when a bomb is selected and can be undone */
  .powerup-btn.undo-mode {
    border: 2px solid #10B981;
    background: #065F46;
    box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25);
    animation: undoModePulse 2s ease-in-out infinite;
  }
  
  .powerup-btn.undo-mode:hover {
    border: 3px solid #34D399;
    background: #047857;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(16, 185, 129, 0.3);
  }
  
  .powerup-btn.undo-mode .powerup-emoji {
    content: "↩️";
  }
  
  @keyframes undoModePulse {
    0%, 100% { 
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25);
    }
    50% { 
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.4);
    }
  }
  
  .powerup-emoji {
    font-size: 32px;
    line-height: 1;
  }
  
  .powerup-cost {
    display: flex;
    align-items: center;
    gap: 2px;
    font-family: var(--font-family);
    font-size: 16px;
    white-space: nowrap;
    padding-right: 8px;
  }
  
  .cost-emoji {
    font-size: 18px;
  }
  
  .cost-amount {
    color: #FCD34D;
    font-weight: 700;
    font-size: 18px;
    white-space: nowrap;
  }
  
  /* Pulse animation for powerup buttons */
  .powerup-btn.pulse {
    animation: powerupBtnPulse 0.3s ease-out;
  }
  
  @keyframes powerupBtnPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }
  
  /* Mobile Powerup Shop - Flexible and Responsive */
  .mobile-powerup-shop {
    display: none;
    order: 4;
    margin-top: 16px;
    margin-bottom: 0;
    width: 100%;
    padding: 0 20px;
    box-sizing: border-box;
  }
  
  .mobile-shop-grid {
    display: flex;
    gap: 12px;
    justify-content: center;
    align-items: center;
  }
  
  /* Mobile button sizing - Flexible based on available space */
  .mobile-powerup-shop .powerup-btn {
    min-width: clamp(50px, 15vw, 70px);
    height: clamp(45px, 12vw, 65px);
    min-height: 45px;
    padding: 0 clamp(6px, 2vw, 10px);
  }
  
  .mobile-powerup-shop .powerup-emoji {
    font-size: clamp(20px, 5vw, 28px);
  }
  
  .mobile-powerup-shop .powerup-cost {
    font-size: clamp(12px, 3.5vw, 16px);
    white-space: nowrap;
  }
  
  .mobile-powerup-shop .cost-emoji {
    font-size: clamp(13px, 3.5vw, 18px);
  }
  
  .mobile-powerup-shop .cost-amount {
    font-size: clamp(12px, 3.5vw, 18px);
    white-space: nowrap;
  }
  

  


  
  /* Next block display styling in debug panel */

  .pole { position:relative; width:140px; height:var(--stack-height, 525px); background:var(--panel); border-radius:15px; display:flex; flex-direction:column-reverse; align-items:center; padding:16px; box-sizing:border-box; cursor:pointer; transition: all 0.2s ease; z-index: 0; }
  .pole:hover { border: 3px solid #0ea5e9; }
  .pole.full { opacity:0.6; cursor: not-allowed; }
  .pole.full:hover { opacity: 0.6; border: none; }
  .pole.no-hover:hover { border: none !important; opacity: 1 !important; }
  .pole.no-hover { pointer-events: none; }
  /* Touch device optimizations */
  @media (hover: none) and (pointer: coarse) {
    /* On touch devices, completely disable hover effects since they're not useful */
    .pole:hover {
      border: none !important;
      opacity: 1 !important;
    }
    
    /* Reduce transition duration on touch devices for snappier feedback */
    .pole {
      transition: all 0.1s ease;
    }
  }
  .disc { width:108px; height:42px; border-radius:9px; display:flex; align-items:center; justify-content:center; color:white; font-weight:700; font-size:24px; margin-top:9px; box-shadow:0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family); transform-origin: center center; position: relative; z-index: 1; }
  
  /* Bomb block styling */
  .bomb-content {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  .bomb-emoji {
    position: absolute;
    top: -3px;
    left: -21px;
    font-size: 42px;
    opacity: 1;
    z-index: 1;
  }
  
  .bomb-text {
    position: relative;
    z-index: 2;
    font-size: 24px;
    font-weight: 700;
    font-family: var(--font-family);
  }
  
  /* remove extra gap at the very top of a full pole (topmost disc has no margin) */
  .pole .disc:last-child { margin-top: 0; }

  .disc.animate { 
    animation: drop calc(0.15s * var(--animation-speed, 1)) ease-out;
  }
  @keyframes drop {
    from { transform: translateY(-60px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.animate[style*="--animation-speed: 0"] { animation: none; transform: translateY(0); opacity: 1; }

  /* Enhanced merge animations */
  .disc.merge-out { 
    animation: mergeOut calc(0.15s * var(--animation-speed, 1)) cubic-bezier(0.4, 0, 0.2, 1) forwards;
    filter: brightness(1.1) saturate(1.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.merge-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.7); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes mergeOut {
    0% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
    }
    25% { 
      transform: scale(1.1); 
      opacity: 1; 
      filter: brightness(1.2) saturate(1.3);
    }
    50% { 
      transform: scale(1.15); 
      opacity: 0.9; 
      filter: brightness(1.3) saturate(1.4);
    }
    75% { 
      transform: scale(1.05); 
      opacity: 0.6; 
      filter: brightness(1.1) saturate(1.2);
    }
    100% { 
      transform: scale(0.7); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
    }
  }

  /* Bomb explosion effect - for the bomb block itself */
  .disc.bomb-explosion {
    animation: bombExplosion calc(0.5s * var(--animation-speed, 1)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    filter: brightness(1.5) saturate(1.8);
    box-shadow: 0 0 20px rgba(220, 38, 38, 0.6), 0 0 40px rgba(220, 38, 38, 0.4);
    z-index: 15;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.bomb-explosion[style*="--animation-speed: 0"] { animation: none; transform: scale(0.8); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes bombExplosion {
    0% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
    15% { 
      transform: scale(1.6); 
      opacity: 1; 
      filter: brightness(2.0) saturate(2.2);
      box-shadow: 0 0 30px rgba(220, 38, 38, 0.8), 0 0 60px rgba(220, 38, 38, 0.5);
    }
    35% { 
      transform: scale(1.3); 
      opacity: 0.7; 
      filter: brightness(1.6) saturate(1.8);
      box-shadow: 0 0 25px rgba(220, 38, 38, 0.6), 0 0 50px rgba(220, 38, 38, 0.4);
    }
    70% { 
      transform: scale(0.9); 
      opacity: 0.3; 
      filter: brightness(1.2) saturate(1.3);
      box-shadow: 0 0 15px rgba(220, 38, 38, 0.3), 0 0 30px rgba(220, 38, 38, 0.2);
    }
    100% { 
      transform: scale(0.8); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
      box-shadow: 0 0 60px rgba(220, 38, 38, 0);
    }
  }

  /* Stage progression explosion effect - for blocks being cleared during stage advancement */
  .disc.stage-explosion {
    animation: bombRipple calc(0.5s * var(--animation-speed, 1)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    filter: brightness(1.3) saturate(1.4);
    box-shadow: 0 0 15px rgba(220, 38, 38, 0.4), 0 0 30px rgba(220, 38, 38, 0.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.stage-explosion[style*="--animation-speed: 0"] { animation: none; transform: scale(0.8); opacity: 0; filter: brightness(0.8) saturate(0.9); }

  /* Bomb shockwave ripple effect - for blocks affected by the explosion */
  .disc.bomb-ripple {
    animation: bombRipple calc(0.5s * var(--animation-speed, 1)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    filter: brightness(1.3) saturate(1.4);
    box-shadow: 0 0 15px rgba(220, 38, 38, 0.4), 0 0 30px rgba(220, 38, 38, 0.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.bomb-ripple[style*="--animation-speed: 0"] { animation: none; transform: scale(0.8); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes bombRipple {
    0% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
    20% { 
      transform: scale(1.2); 
      opacity: 1; 
      filter: brightness(1.4) saturate(1.6);
      box-shadow: 0 0 20px rgba(220, 38, 38, 0.5), 0 0 40px rgba(220, 38, 38, 0.3);
    }
    40% { 
      transform: scale(1.1); 
      opacity: 0.8; 
      filter: brightness(1.3) saturate(1.4);
      box-shadow: 0 0 15px rgba(220, 38, 38, 0.4), 0 0 30px rgba(220, 38, 38, 0.25);
    }
    70% { 
      transform: scale(0.9); 
      opacity: 0.4; 
      filter: brightness(1.1) saturate(1.2);
      box-shadow: 0 0 10px rgba(220, 38, 38, 0.2), 0 0 20px rgba(220, 38, 38, 0.15);
    }
    100% { 
      transform: scale(0.8); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
  }

  .disc.merge-in { 
    animation: mergeIn calc(0.2s * var(--animation-speed, 1)) cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    filter: brightness(1.05) saturate(1.1);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.merge-in[style*="--animation-speed: 0"] { animation: none; transform: scale(1); opacity: 1; filter: brightness(1) saturate(1); }
  @keyframes mergeIn {
    0% { 
      transform: scale(0.6); 
      opacity: 0; 
      filter: brightness(0.7) saturate(0.8);
    }
    30% { 
      transform: scale(0.85); 
      opacity: 0.7; 
      filter: brightness(0.9) saturate(1);
    }
    60% { 
      transform: scale(1.05); 
      opacity: 0.9; 
      filter: brightness(1.05) saturate(1.1);
    }
    80% { 
      transform: scale(0.98); 
      opacity: 1; 
      filter: brightness(1.02) saturate(1.05);
    }
    100% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
    }
  }

  /* Merge glow effect for visual appeal */
  .disc.merging {
    box-shadow: 0 0 15px rgba(14, 165, 233, 0.4), 0 0 25px rgba(14, 165, 233, 0.2);
    transition: box-shadow 0.1s ease;
    z-index: 5;
  }
  
  /* Enhanced disc transitions for smoother animations */
  .disc {
    transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform, opacity, filter;
  }
  


  /* special clear animation for high-value blocks */
  .disc.clear-out { animation: clearOut calc(0.26s * var(--animation-speed, 1)) ease forwards; }
  @keyframes clearOut {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0.85); opacity: 0; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.clear-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.85); opacity: 0; }

  /* removed falling/fade styles for simplified clear */



  .controls { margin-top:8px; font-size:13px; color:#ccc; }

  /* Debug pane styling */
  .debug-pane { 
    position: fixed; 
    top: 0; 
    right: 0; 
    height: 100vh; 
    background: var(--panel); 
    color: var(--text); 
    border-left: 3px solid #475569; 
    padding: 20px; 
    z-index: 1002; 
    width: 320px;
    box-shadow: -5px 0 25px rgba(0,0,0,0.4);
    font-family: var(--font-family);
    overflow-y: auto;
    overflow-x: hidden;
    box-sizing: border-box;
    transform: translateX(100%);
    transition: transform 0.3s ease-out;
    display: flex;
    flex-direction: column;
  }
  
  .debug-pane.show {
    transform: translateX(0);
  }
  
  /* Debug pane backdrop overlay */
  .debug-pane::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.3);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease-out;
    z-index: -1;
  }
  
  .debug-pane.show::before {
    opacity: 1;
  }
  

  .debug-pane h3 { margin: 0 0 16px; font-size: 20px; text-align: center; font-family: var(--font-family); }
  .debug-pane .section { margin-bottom: 18px; }
  
  .debug-pane .section:not(.bottom-buttons) {
    flex: 1;
  }
  .debug-pane .section-title { font-weight: 600; margin-bottom: 8px; font-size: 15px; font-family: var(--font-family); }
  .debug-pane .controls { display: flex; flex-direction: column; gap: 12px; }
  .debug-pane .control-row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
  .debug-pane .control-row label { font-size: 14px; min-width: 70px; font-family: var(--font-family); flex-shrink: 0; }
  .debug-pane .control-row input[type="range"] { flex: 1; min-width: 0; accent-color: #0ea5e9; }
  .debug-pane .control-row .value-display { 
    background: var(--bg); 
    padding: 6px 12px; 
    border-radius: 6px; 
    font-size: 13px; 
    min-width: 45px; 
    text-align: center; 
    font-family: var(--font-family);
    flex-shrink: 0;
  }
  .debug-pane .button { 
    background: #334155; 
    color: var(--text); 
    border: 1px solid #475569; 
    padding: 10px 16px; 
    border-radius: 6px; 
    cursor: pointer; 
    font-weight: 600; 
    font-size: 14px;
    transition: background 0.2s;
    font-family: var(--font-family);
    box-sizing: border-box;
  }
  
  .debug-pane .button-row {
    display: flex;
    gap: 8px;
  }
  
  .debug-pane .button-row .button {
    flex: 1;
    min-width: 0;
  }
  
  .debug-pane .bottom-buttons {
    margin-top: auto;
    padding-top: 16px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
  }
  
  /* Block grid styling */
  .block-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
    margin: 12px 0;
  }
  
  .block-item {
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
    user-select: none;
  }
  
  .block-item:hover {
    transform: scale(1.05);
    box-shadow: 0 3px 0 rgba(0,0,0,0.3);
  }
  
  .block-item.selected {
    outline: 3px solid #fff;
    outline-offset: 2px;
    transform: scale(1.1);
    box-shadow: 0 4px 0 rgba(0,0,0,0.4);
  }
  
  .block-item[data-value="1"] { background: #cfef08; color: #000; }
  .block-item[data-value="2"] { background: #10B981; color: #fff; }
  .block-item[data-value="4"] { background: #2563EB; color: #fff; }
  .block-item[data-value="8"] { background: #7C3AED; color: #fff; }
  .block-item[data-value="16"] { background: #581C87; color: #fff; }
  .block-item[data-value="32"] { background: #D946EF; color: #fff; }
  .block-item[data-value="64"] { background: #EC4899; color: #fff; }
  .block-item[data-value="128"] { background: #e86758; color: #fff; }
  .block-item[data-value="256"] { background: #F59E0B; color: #fff; }
  .block-item[data-value="512"] { background: #ea580c; color: #fff; }
  .block-item[data-value="1024"] { background: #dc2626; color: #fff; }
  .block-item[data-value="2048"] { background: #9d174d; color: #fff; }
  .block-item[data-value="4096"] { background: #7c2d6d; color: #fff; }
  .block-item[data-value="8192"] { background: #64748b; color: #fff; }
  .block-item[data-value="16384"] { background: #fff; color: #000; }
  
  /* Dynamic gold glow effect for white blocks (16384+) in the game */
  .disc.white-block-glow {
    --glow-intensity: 1;
    --glow-spread: 8px;
    --glow-opacity: 0.6;
    --border-width: 2px;
    --border-opacity: 0.8;
    --inset-opacity: 0.1;
    
    box-shadow: 
      0 0 calc(var(--glow-spread) * 1) rgba(245, 215, 110, var(--glow-opacity)),
      0 0 calc(var(--glow-spread) * 2) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.67)),
      0 0 calc(var(--glow-spread) * 3) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.33)),
      0 0 calc(var(--glow-spread) * 4) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.17)),
      inset 0 0 calc(var(--glow-spread) * 1) rgba(245, 215, 110, var(--inset-opacity));
    border: var(--border-width) solid rgba(245, 215, 110, var(--border-opacity));
  }
  
  .block-item.no-block {
    background: #64748b;
    color: #fff;
    border: 2px solid #94a3b8;
    font-weight: 600;
  }
  
  .block-item.no-block:hover {
    background: #475569;
    border-color: #cbd5e1;
  }
  
  .block-item.no-block.selected {
    background: #475569;
    border-color: #e2e8f0;
    outline: 3px solid #e2e8f0;
  }
  
  .selected-block-info {
    text-align: center;
    font-size: 13px;
    color: rgba(255, 255, 255, 0.9);
    margin-top: 8px;
    padding: 8px;
    background: var(--bg);
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }
  .debug-pane .button:hover { background: #475569; }
  .debug-pane .button:active { background: #334155; }
  .debug-pane .button.primary { background: #0ea5e9; border-color: #0284c7; }
  .debug-pane .button.primary:hover { background: #0284c7; }
  .debug-pane .button.active { background: #0ea5e9; border-color: #0284c7; }
  .debug-pane .close-btn { 
    position: absolute; 
    top: 8px; 
    right: 12px; 
    background: none; 
    border: none; 
    color: #94a3b8; 
    font-size: 20px; 
    cursor: pointer; 
    padding: 6px; 
    border-radius: 6px;
    font-family: var(--font-family);
  }
  .debug-pane .close-btn:hover { background: #475569; color: var(--text); }
  .debug-pane .status { 
    background: var(--bg); 
    padding: 8px; 
    border-radius: 6px; 
    font-size: 13px; 
    text-align: center;
    border: 1px solid #475569;
    font-family: var(--font-family);
  }
  .debug-pane .status.active { border-color: #10B981; background: rgba(16, 185, 129, 0.1); }
  .debug-pane .status.inactive { border-color: #6B7280; background: rgba(107, 114, 128, 0.1); }
  
  /* Hide debug button by default - will be shown via JavaScript */
  #debugBtn {
    display: none;
  }

  /* Game Over Button Overlay */
  .game-over-button-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: rgba(30, 41, 59, 0.95); /* Semi-transparent panel background */
    backdrop-filter: blur(8px); /* Add subtle blur effect */
    border: 2px solid rgba(255, 255, 255, 0.8); /* Semi-transparent white border */
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1); /* Smooth easing curve for fade-in */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    min-width: 200px;
  }

  .game-over-button-overlay.hiding {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* Fast transition for fade-out */
  }

  .game-over-button-overlay.show {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
  }

  .game-over-text {
    font-size: 24px;
    font-weight: 700;
    color: #ef4444;
    font-family: var(--font-family);
    text-align: center;
    margin: 0;
  }

  .new-game-btn {
    background: #10B981;
    color: white;
    border: none;
    padding: 16px 32px;
    border-radius: 12px;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .new-game-btn:hover {
    background: #059669;
    transform: translateY(-2px);
    box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
  }

  .new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }



  /* New Game Modal Styling */
  .new-game-modal {
    max-width: 300px;
    text-align: center;
    /* Add similar outline to Game Over window but with green/blue theme */
    border: 2px solid rgba(16, 185, 129, 0.8); /* Semi-transparent green border */
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3); /* Green-tinted shadow */
    background: rgba(30, 41, 59, 0.95); /* Semi-transparent panel background like Game Over */
    backdrop-filter: blur(8px); /* Add subtle blur effect like Game Over */
    /* Add smooth transition for hover effects */
    transition: all 0.3s ease;
  }

  /* Add hover effect to make the outline more prominent */
  .new-game-modal:hover {
    border-color: rgba(16, 185, 129, 1); /* Solid green on hover */
    box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4); /* Enhanced shadow on hover */
  }

  .new-game-modal h2 {
    margin-bottom: 24px;
    color: var(--text);
  }

  .new-game-buttons {
    display: flex;
    gap: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .confirm-new-game-btn {
    background: #10B981;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .confirm-new-game-btn:hover {
    background: #059669;
    transform: translateY(-2px);
    box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
  }

  .confirm-new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

  .cancel-new-game-btn {
    background: #DC2626;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .cancel-new-game-btn:hover {
    background: #b91c1c;
    transform: translateY(-2px);
    box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
  }

  .cancel-new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

/* Debug stats table styling */
.debug-stats-table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 8px;
  font-size: 12px;
  table-layout: fixed;
}

.debug-stats-table td {
  padding: 2px 4px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.debug-stats-table td:first-child {
  font-weight: 500;
  color: rgba(255, 255, 255, 0.7);
  width: 45%;
}

.debug-stats-table td:last-child {
  text-align: right;
  font-weight: 600;
  color: var(--text);
  width: 55%;
}

/* Mobile Responsive Design */
@media (max-width: 768px) {
  /* Adjust topbar for mobile */
  .topbar {
    padding: 16px 12px 8px;
    gap: 16px;
  }
  
  h1 {
    font-size: 28px;
  }
  
  /* Adjust game info layout for mobile */
  .game-info {
    flex-direction: row;
    justify-content: center;
    gap: 32px;
    margin-top: 20px; /* Increased from 20px to give more spacing on mobile */
    flex-wrap: wrap;
  }
  
  .score-display, .gold-display {
    gap: 8px;
  }
  
  /* Adjust stage multiplier badge for mobile */
  .stage-multiplier-badge {
    font-size: 10px;
    padding: 3px 5px;
    min-width: 18px;
    bottom: -14px;
    left: 50%;
    transform: translateX(-50%);
  }
  
  .next {
    order: 2;
    width: 100%;
    margin-top: 16px;
  }
  
  .score-label, .next .label, .gold-label {
    font-size: 16px;
  }
  
  .score-value, .gold-value {
    font-size: 20px;
    padding: 8px 16px;
    min-width: 60px;
  }
  
  .next-disc {
    width: 80px;
    height: 35px;
    font-size: 18px;
  }
  
  /* Adjust bomb blocks in next queue for mobile */
  .next-disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .next-disc .bomb-text {
    font-size: 18px;
  }
  
  /* Fix next blocks animation for mobile */
  .next-disc.shift-left {
    transform: translateX(-96px); /* Adjusted for mobile next-disc width + gap */
  }
  
  .next-disc.consume-out {
    animation-duration: calc(0.15s * var(--animation-speed, 1)); /* Slightly faster on mobile */
  }
  
  /* Fix drop animation for mobile - override default with higher specificity */
  .game .pole .disc.animate {
    animation: dropMobile calc(0.15s * var(--animation-speed, 1)) ease-out !important;
  }
  
  @keyframes dropMobile {
    from { transform: translateY(-50px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  /* Adjust game container for mobile */
  .game-container {
    margin-top: 20px;
    padding-bottom: 20px;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    display: flex;
  }
  
  .game {
    order: 1;
  }
  

  
  /* Show mobile powerup shop and hide desktop powerup shop on mobile */
  .powerup-shop {
    display: none;
  }
  
  .mobile-powerup-shop {
    display: block;
    order: 4;
    margin-top: 8px;
    margin-bottom: 0;
  }
  
  /* Adjust game grid for mobile */
  .game {
    gap: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  /* Make poles smaller for mobile */
  .pole {
    width: 100px;
    /* Height will be set by JavaScript via --stack-height variable */
    padding: 12px;
  }
  
  /* Adjust discs for smaller poles */
  .disc {
    width: 76px;
    height: 30px;
    font-size: 18px;
    margin-top: 6px;
  }
  
  /* Adjust bomb blocks for mobile to match disc sizing */
  .disc .bomb-emoji {
    font-size: 30px;
    top: -2px;
    left: -15px;
  }
  
  .disc .bomb-text {
    font-size: 18px;
  }
  
  /* Adjust bomb conversion button for mobile */
  .bomb-conversion-btn {
    width: 50px;
    height: 50px;
  }
  
  .bomb-conversion-btn .emoji {
    font-size: 24px;
  }
  
  .bomb-cost-text .emoji {
    font-size: 20px;
  }
  
  .bomb-cost-text .cost {
    font-size: 16px;
  }
  
  .trash-cost-text .emoji {
    font-size: 20px;
  }
  
  .trash-cost-text .cost {
    font-size: 16px;
  }
  
  /* Mobile button row styling */
  .mobile-button-row .mobile-bomb-container,
  .mobile-button-row .mobile-trash-container {
    display: flex;
    position: static;
    margin: 0;
    flex: 1;
    justify-content: center;
    align-items: center;
    gap: 12px;
  }
  

  
  /* Disable hover effects on mobile devices for bomb and trash buttons */
  @media (max-width: 768px) {
    /* Disable hover effects for all bomb and trash buttons on mobile */
    .bomb-conversion-btn:hover,
    .trash-btn:hover {
      /* Disable hover effects on mobile - no transform, border, background, or shadow changes */
      transform: none !important;
      border: 2px solid #DC2626 !important; /* Keep original border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(220, 38, 38, 0.25) !important; /* Keep original shadow */
    }
    
    .bomb-conversion-btn.affordable:hover {
      /* Disable hover effects for affordable state on mobile */
      transform: none !important;
      border: 2px solid rgba(255, 255, 255, 0.3) !important; /* Keep affordable border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1) !important; /* Keep affordable shadow */
    }
    
    .bomb-conversion-btn.undo-mode:hover {
      /* Disable hover effects for undo mode on mobile */
      transform: none !important;
      border: 2px solid #10B981 !important; /* Keep undo border */
      background: #065F46 !important; /* Keep undo background */
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25) !important; /* Keep undo shadow */
    }
    
    .trash-btn.affordable:hover {
      /* Disable hover effects for affordable state on mobile */
      transform: none !important;
      border: 2px solid rgba(255, 255, 255, 0.3) !important; /* Keep affordable border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1) !important; /* Keep affordable shadow */
    }
    
    /* Disable hover effects for mobile powerup buttons on mobile */
    .mobile-powerup-shop .powerup-btn:hover {
      /* Disable hover effects on mobile - no transform, border, background, or shadow changes */
      transform: none !important;
      border: 2px solid #DC2626 !important; /* Keep original border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(220, 38, 38, 0.25) !important; /* Keep original shadow */
    }
    
    .mobile-powerup-shop .powerup-btn.affordable:hover {
      /* Disable hover effects for affordable state on mobile */
      transform: none !important;
      border: 2px solid rgba(255, 255, 255, 0.3) !important; /* Keep affordable border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1) !important; /* Keep affordable shadow */
    }
    
    .mobile-powerup-shop .powerup-btn.undo-mode:hover {
      /* Disable hover effects for undo mode on mobile */
      transform: none !important;
      border: 2px solid #10B981 !important; /* Keep undo border */
      background: #065F46 !important; /* Keep undo background */
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25) !important; /* Keep undo shadow */
    }
  }
  
  /* Responsive adjustments for very small mobile screens */

  
  /* Pulse animation for mobile buttons */

  
  /* Adjust bottom actions for mobile */
  .bottom-actions {
    margin-top: 16px;
    gap: 12px;
    order: 5;
  }
  
  .ai-btn {
    padding: 10px 20px;
    font-size: 14px;
  }
  
  /* Adjust help modal for mobile */
  .help-modal {
    width: 95vw;
    padding: 20px;
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) on mobile */
  .help-modal::-webkit-scrollbar {
    display: none;
  }
  
  .help-grid {
    gap: 16px;
  }
  
  /* Adjust powerup buttons section for mobile */
  .help-modal .help-content [style*="gap: 80px"] {
    gap: 40px !important;
  }
  
  /* Make powerup buttons more compact on mobile */
  .help-modal .powerup-btn {
    min-width: 50px !important;
    min-height: 50px !important;
    padding: 0 6px !important;
  }
  
  .help-modal .powerup-emoji {
    font-size: 20px !important;
  }
  
  .help-modal .cost-emoji,
  .help-modal .cost-amount {
    font-size: 14px !important;
  }
  
  /* Adjust help section padding for mobile */
  .help-modal .help-section {
    padding: 16px !important;
  }
  
  /* Adjust help section header spacing for mobile */
  .help-modal .help-section-header {
    margin-bottom: 12px !important;
  }
  
  .help-modal .help-section-header h3 {
    font-size: 18px !important;
  }
  
  /* Make merge examples more compact on mobile */
  .help-modal .merge-example {
    gap: 30px !important;
  }
  
  .help-modal .merge-example[style*="gap: 80px"] {
    gap: 30px !important;
  }
  
  .help-modal .merge-block {
    width: 70px !important;
    height: 28px !important;
    font-size: 18px !important;
  }
  
  .help-modal .merge-block.bomb-block {
    width: 76px !important;
    height: 30px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-emoji {
    font-size: 30px !important;
    top: -2px !important;
    left: -15px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-text {
    font-size: 18px !important;
  }
  
  .help-modal .merge-arrow {
    font-size: 18px !important;
  }
  
  .help-modal .merge-example [style*="gap: 12px"] {
    gap: 10px !important;
  }
  
  .help-modal .merge-example [style*="margin-left: 20px"] {
    margin-left: 16px !important;
  }
  
  /* Adjust debug pane for mobile */
  .debug-pane {
    width: 95vw;
    right: 0;
  }
}

/* Extra small mobile devices */
@media (max-width: 480px) {
  .topbar {
    padding: 12px 8px 6px;
  }
  
  h1 {
    font-size: 24px;
  }
  
  /* Extra help modal adjustments for very small screens */
  .help-modal {
    width: 98vw;
    padding: 16px;
  }
  
  .help-modal .help-content [style*="gap: 80px"] {
    gap: 24px !important;
  }
  
  .help-modal .powerup-btn {
    min-width: 45px !important;
    min-height: 45px !important;
    padding: 0 4px !important;
  }
  
  .help-modal .powerup-emoji {
    font-size: 18px !important;
  }
  
  .help-modal .cost-emoji,
  .help-modal .cost-amount {
    font-size: 12px !important;
  }
  
  .help-modal .help-section {
    padding: 12px !important;
  }
  
  .help-modal .help-section-header h3 {
    font-size: 16px !important;
  }
  
  /* Make merge examples more compact on mobile */
  .help-modal .merge-example {
    gap: 20px !important;
  }
  
  .help-modal .merge-example[style*="gap: 80px"] {
    gap: 20px !important;
  }
  
  .help-modal .merge-block {
    width: 60px !important;
    height: 24px !important;
    font-size: 16px !important;
  }
  
  .help-modal .merge-block.bomb-block {
    width: 60px !important;
    height: 24px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-emoji {
    font-size: 24px !important;
    top: -2px !important;
    left: -12px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-text {
    font-size: 16px !important;
  }
  
  .help-modal .merge-arrow {
    font-size: 16px !important;
  }
  
  .help-modal .merge-example [style*="gap: 12px"] {
    gap: 8px !important;
  }
  
  .help-modal .merge-example [style*="margin-left: 20px"] {
    margin-left: 12px !important;
  }
  
  .game-info {
    gap: 16px;
    margin-top: 16px;
    flex-direction: row;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  .next {
    order: 2;
    width: 100%;
    margin-top: 12px;
  }
  
  .pole {
    width: 80px;
    /* Height will be set by JavaScript via --stack-height variable */
    padding: 8px;
  }
  
  .disc {
    width: 64px;
    height: 26px;
    font-size: 16px;
    margin-top: 4px;
  }
  
  /* Adjust bomb blocks for extra small mobile */
  .disc .bomb-emoji {
    font-size: 22px;
    top: -1px;
    left: -11px;
  }
  
  .disc .bomb-text {
    font-size: 16px;
  }
  
  .next-disc {
    width: 70px;
    height: 30px;
    font-size: 16px;
  }
  
  /* Adjust bomb blocks in next queue for extra small mobile */
  .next-disc .bomb-emoji {
    font-size: 26px;
    top: -1px;
    left: -13px;
  }
  
  .next-disc .bomb-text {
    font-size: 16px;
  }
  
  /* Fix next blocks animation for extra small mobile */
  .next-disc.shift-left {
    transform: translateX(-84px); /* Adjusted for extra small mobile next-disc width + gap */
  }
  
  .next-disc.consume-out {
    animation-duration: calc(0.15s * var(--animation-speed, 1)); /* Slightly faster on mobile */
  }
  
  /* Extra small mobile uses same drop animation approach */
  
  /* Fix drop animation for extra small mobile - override default with higher specificity */
  .game .pole .disc.animate {
    animation: dropMobileSmall calc(0.15s * var(--animation-speed, 1)) ease-out !important;
  }
  
  @keyframes dropMobileSmall {
    from { transform: translateY(-40px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  .game {
    gap: 12px;
  }
  
  .bomb-conversion-btn {
    width: 45px;
    height: 45px;
  }
  
  .bomb-conversion-btn .emoji {
    font-size: 20px;
  }
  
  /* Adjust stage multiplier badge for extra small mobile */
  .stage-multiplier-badge {
    font-size: 9px;
    padding: 2px 4px;
    min-width: 16px;
    bottom: -12px;
    left: 50%;
    transform: translateX(-50%);
  }
  

  

  

}

/* Landscape mobile orientation */
@media (max-width: 768px) and (orientation: landscape) {
  .game-container {
    flex-direction: row;
    align-items: flex-start;
    gap: 12px;
  }
  

  

  
  .pole {
    height: 250px;
  }
  
  /* Adjust bomb blocks for landscape mobile */
  .disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .disc .bomb-text {
    font-size: 20px;
  }
  
  /* Adjust bomb blocks in next queue for landscape mobile */
  .next-disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .next-disc .bomb-text {
    font-size: 20px;
  }
}



/* Probability test results modal */
.prob-test-modal { 
  position: fixed; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%); 
  background: var(--panel); 
  color: var(--text); 
  width: min(600px, 90vw); 
  border-radius: 16px; 
  padding: 24px; 
  box-shadow: 0 15px 45px rgba(0,0,0,0.4); 
  font-family: var(--font-family);
  z-index: 1001;
  max-height: 80vh;
  overflow-y: auto;
}

.prob-test-modal h3 { 
  margin: 0 0 20px; 
  font-size: 20px; 
  text-align: center; 
  color: #0ea5e9;
  font-family: var(--font-family);
}

.prob-test-results {
  background: var(--bg);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
  border: 1px solid #475569;
}

.prob-test-table {
  width: 100%;
  border-collapse: collapse;
  margin: 12px 0;
  font-size: 14px;
}

.prob-test-table th,
.prob-test-table td {
  padding: 8px 12px;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.prob-test-table th {
  background: #334155;
  font-weight: 600;
  color: #f8fafc;
}

.prob-test-table td {
  font-family: 'Courier New', monospace;
  font-size: 13px;
}

.prob-test-table .block-value {
  font-weight: 600;
  color: #0ea5e9;
}

.prob-test-table .expected {
  color: #10B981;
}

.prob-test-table .actual {
  color: #F59E0B;
}

.prob-test-table .difference {
  color: #EF4444;
}

.prob-test-summary {
  text-align: center;
  margin-top: 16px;
  padding: 12px;
  background: #334155;
  border-radius: 6px;
  border: 1px solid #475569;
}

.prob-test-summary .total {
  font-size: 16px;
  font-weight: 600;
  color: #10B981;
}

.prob-test-close {
  background: #334155;
  color: var(--text);
  border: 1px solid #475569;
  padding: 10px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: background 0.2s;
  font-family: var(--font-family);
  width: 100%;
  margin-top: 16px;
}

.prob-test-close:hover {
  background: #475569;
}

.prob-test-close:active {
  background: #334155;
}



/* Hide next blocks section when game is over */
.next.game-over-hidden {
  opacity: 0.3;
  pointer-events: none;
}

/* Show new game button in place of next blocks */
.new-game-container {
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  margin-top: 16px;
}

.new-game-container.show {
  display: flex;
}

.new-game-container .label {
  font-size: 18px;
  opacity: 0.9;
  font-family: var(--font-family);
}

.new-game-container .new-game-btn {
  padding: 12px 24px;
  font-size: 16px;
}

/* Sound Control Modal Styles */
.sound-control-modal { 
  background: var(--panel); 
  color: var(--text); 
  width: min(500px, 90vw); 
  border-radius: 16px; 
  padding: 28px; 
  box-shadow: 0 15px 45px rgba(0,0,0,0.4); 
  font-family: var(--font-family);
  z-index: 1001;
  max-height: 80vh;
  overflow-y: auto;
}

.sound-control-modal h2 { 
  margin: 0 0 24px; 
  font-size: 24px; 
  text-align: center; 
  color: #0ea5e9;
  font-family: var(--font-family);
}

.sound-control-container {
  background: var(--bg);
  border-radius: 8px;
  border: 1px solid #475569;
  padding: 20px;
  margin-bottom: 20px;
}

.sound-control-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
  gap: 16px;
}

.sound-control-row:last-child {
  margin-bottom: 0;
}

.sound-control-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 16px;
  min-width: 120px;
}

.sound-control-emoji {
  font-size: 20px;
}

.sound-control-slider {
  flex: 1;
  min-width: 0;
  accent-color: #0ea5e9;
}

.sound-control-value {
  background: var(--panel);
  color: var(--text);
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 14px;
  min-width: 40px;
  text-align: center;
  font-family: var(--font-family);
  border: 1px solid #475569;
  flex-shrink: 0;
}

.sound-control-mute {
  background: #334155;
  color: var(--text);
  border: 1px solid #475569;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.2s ease;
  font-family: var(--font-family);
  min-width: 80px;
}

.sound-control-mute:hover {
  background: #475569;
  border-color: #64748b;
}

.sound-control-mute:active {
  background: #334155;
}

.sound-control-mute.muted {
  background: #dc2626;
  border-color: #ef4444;
}

.sound-control-mute.muted:hover {
  background: #b91c1c;
  border-color: #dc2626;
}

.sound-control-close {
  background: #334155;
  color: var(--text);
  border: 1px solid #475569;
  padding: 12px 24px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 16px;
  transition: all 0.2s ease;
  font-family: var(--font-family);
  width: 100%;
  margin-top: 24px;
}

.sound-control-close:hover {
  background: #475569;
}

.sound-control-close:active {
  background: #334155;
}

/* Mobile responsive design for sound control modal */
@media (max-width: 768px) {
  .sound-control-modal {
    width: 95vw;
    padding: 24px;
    margin: 20px;
  }
  
  .sound-control-modal h2 {
    font-size: 22px;
    margin-bottom: 20px;
  }
  
  .sound-control-container {
    padding: 16px;
    margin-bottom: 16px;
  }
  
  .sound-control-row {
    flex-direction: column;
    align-items: stretch;
    gap: 12px;
    margin-bottom: 20px;
  }
  
  .sound-control-label {
    min-width: auto;
    justify-content: center;
  }
  
  .sound-control-slider {
    width: 100%;
  }
  
  .sound-control-value {
    align-self: center;
  }
  
  .sound-control-mute {
    align-self: center;
    min-width: 100px;
  }
}

/* Extra small mobile devices */
@media (max-width: 480px) {
  .sound-control-modal {
    padding: 20px;
    margin: 16px;
  }
  
  .sound-control-modal h2 {
    font-size: 20px;
    margin-bottom: 18px;
  }
  
  .sound-control-container {
    padding: 14px;
    margin-bottom: 14px;
  }
  
  .sound-control-row {
    gap: 10px;
    margin-bottom: 18px;
  }
  
  .sound-control-label {
    font-size: 15px;
  }
  
  .sound-control-emoji {
    font-size: 18px;
  }
}
</style>
</head>
<body>
  <!-- Probability test results modal (hidden by default) -->
  <div id="probTestModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="probTestTitle">
    <div class="modal prob-test-modal">
      <h3 id="probTestTitle">Probability Distribution Test Results</h3>
      
      <div class="prob-test-results">
        <div id="probTestContent">
          <!-- Test results will be populated here -->
        </div>
      </div>
      
      <button id="probTestClose" class="prob-test-close">Close</button>
    </div>
  </div>

  <div class="topbar">
    <div class="title-section">
      <div class="left-section">
        <button id="addBtn" class="title-btn" title="New Game">➕</button>
        <button id="helpBtn" class="title-btn" title="How to play">❔</button>
      </div>
      <div class="center-section">
        <h1>Stack Merge</h1>
      </div>
      <div class="right-section">
        <button id="soundBtn" class="title-btn" title="Sound Controls">🔊</button>
        <button id="mergeSoundBtn" class="title-btn" title="Switch to musical merge sounds">🎵</button>
      </div>
    </div>
  </div>

  <div class="game-info">
    <div class="score-display">
      <div class="score-label">Score</div>
      <div class="score-value" id="scoreDisplay">0</div>
    </div>
    
    <div class="next">
      <div class="label">Next Blocks</div>
      <div class="next-row" id="nextContainer" aria-live="polite"></div>
    </div>
    

    
    <div class="gold-display">
      <div class="gold-label">Gold</div>
      <div class="gold-value" id="goldDisplay">0</div>
    </div>
  </div>
  


  <!-- Game Over Button Overlay -->
  <div id="gameOverButton" class="game-over-button-overlay">
    <div class="game-over-text">Game Over</div>
  </div>

  <!-- New Game Confirmation Modal -->
  <div id="newGameModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="newGameTitle">
    <div class="modal new-game-modal">
      <h2 id="newGameTitle">New Game?</h2>
      <div class="new-game-buttons">
        <button id="confirmNewGameBtn" class="confirm-new-game-btn">Yes</button>
        <button id="cancelNewGameBtn" class="cancel-new-game-btn">No</button>
      </div>
    </div>
  </div>

  <!-- Sound Control Modal -->
  <div id="soundControlModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="soundControlTitle">
    <div class="modal sound-control-modal">
      <h2 id="soundControlTitle">Sound Controls</h2>
      
      <div class="sound-control-container">
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🔊</span>
            <span>Master Mute</span>
          </div>
          <button id="masterMuteBtn" class="sound-control-mute">Mute</button>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">📦</span>
            <span>Drops</span>
          </div>
          <input type="range" id="dropVolumeSlider" class="sound-control-slider" min="0" max="5" value="3" step="1">
          <div class="sound-control-value" id="dropVolumeValue">3</div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🔗</span>
            <span>Merges</span>
          </div>
          <input type="range" id="mergeVolumeSlider" class="sound-control-slider" min="0" max="5" value="3" step="1">
          <div class="sound-control-value" id="mergeVolumeValue">3</div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">💰</span>
            <span>Gold Coins</span>
          </div>
          <input type="range" id="coinVolumeSlider" class="sound-control-slider" min="0" max="5" value="3" step="1">
          <div class="sound-control-value" id="coinVolumeValue">3</div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">💥</span>
            <span>Bombs</span>
          </div>
          <input type="range" id="bombVolumeSlider" class="sound-control-slider" min="0" max="5" value="3" step="1">
          <div class="sound-control-value" id="bombVolumeValue">3</div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🚀</span>
            <span>Other</span>
          </div>
          <input type="range" id="otherVolumeSlider" class="sound-control-slider" min="0" max="5" value="3" step="1">
          <div class="sound-control-value" id="otherVolumeValue">3</div>
        </div>
      </div>
      
      <button id="soundControlClose" class="sound-control-close">Close</button>
      
      <div style="margin-top: 16px; text-align: center; display: none;">
        <button id="testAllSoundsBtn" class="sound-control-mute" style="background: #0ea5e9; border-color: #0284c7; min-width: 120px;">
          Test All Sounds
        </button>
        <button id="debugVolumeBtn" class="sound-control-mute" style="background: #dc2626; border-color: #b91c1c; min-width: 120px; margin-top: 8px;">
          Debug Volumes
        </button>
      </div>
    </div>
  </div>

  <div class="game-container">
    <div class="game" id="game" role="application" aria-label="Stacks"></div>
    
    <!-- Powerup Shop - Grid Layout -->
    <div class="powerup-shop">
      <div class="shop-grid">
        <button id="bombConversionBtn" class="powerup-btn bomb-btn" title="Convert next block to bomb (press again to undo)">
          <span class="powerup-emoji">💣</span>
          <div class="powerup-cost">
            <span class="cost-emoji">💰</span>
            <span class="cost-amount" id="bombCost">25</span>
          </div>
        </button>
        
        <button id="trashButton" class="powerup-btn" title="Remove next block from queue">
          <span class="powerup-emoji">🗑️</span>
          <div class="powerup-cost">
            <span class="cost-emoji">💰</span>
            <span class="cost-amount" id="trashCost">25</span>
          </div>
        </button>
      </div>
    </div>
    
    <!-- Mobile Powerup Shop -->
    <div class="mobile-powerup-shop">
      <div class="mobile-shop-grid">
        <button id="bombConversionBtnMobile" class="powerup-btn bomb-btn" title="Convert next block to bomb (press again to undo)">
          <span class="powerup-emoji">💣</span>
          <div class="powerup-cost">
            <span class="cost-emoji">💰</span>
            <span class="cost-amount" id="bombCostMobile">25</span>
          </div>
        </button>
        
        <button id="trashButtonMobile" class="powerup-btn" title="Remove next block from queue">
          <span class="powerup-emoji">🗑️</span>
          <div class="powerup-cost">
            <span class="cost-emoji">💰</span>
            <span class="cost-amount" id="trashCostMobile">25</span>
          </div>
        </button>
      </div>
    </div>
  </div>
  
  <div class="bottom-actions">
    <button id="debugBtn" class="ai-btn" title="Debug controls">⚙️</button>
  </div>


  <!-- Help modal (hidden by default) -->
  <div id="helpModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modal help-modal">
      <h2 id="helpTitle">How to Play</h2>
      
      <div class="help-grid">
        <!-- Basic Controls Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🎮</span>
            <h3>Basic Gameplay</h3>
          </div>
          <div class="help-content">
            <p>Drop the incoming blocks onto stacks to gain score.</p>
            <p>Avoid filling up stacks by merging blocks to create more space.</p>
            <p>Survive as long as possible for a high score!</p>
            <p><strong>Basic Controls:</strong></p>
            <p>Click/Tap one of the four stacks to drop the next block from the queue.</p>
            <p>Click/Tap the bomb button to convert the next block to a bomb.</p>
            <p>Click/Tap the trash can button to remove the next block from the queue.</p>
            <p>Open the Sound Control menu to adjust the volume of the game.</p>
          </div>
        </div>

        <!-- Merging Section -->
        <!-- Basic Merging Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🔗</span>
            <h3>Merging Blocks</h3>
          </div>
          <div class="help-content">
            <p>When two blocks with the same value are stacked, they merge into one bigger block.</p>
            <div class="merge-example" style="display: flex; gap: 80px; justify-content: center;">
              <div style="display: flex; align-items: center; gap: 12px;">
                <div class="merge-before">
                  <div class="merge-blocks">
                    <div class="merge-block block-1">1</div>
                    <div class="merge-block block-1">1</div>
                  </div>
                </div>
                <div class="merge-arrow">→</div>
                <div class="merge-after">
                  <div class="merge-blocks">
                    <div class="merge-block block-2">2</div>
                  </div>
                </div>
              </div>
              
              <div style="display: flex; align-items: center; gap: 12px;">
                <div class="merge-before">
                  <div class="merge-blocks">
                    <div class="merge-block block-2">2</div>
                    <div class="merge-block block-2">2</div>
                  </div>
                </div>
                <div class="merge-arrow">→</div>
                <div class="merge-after">
                  <div class="merge-blocks">
                    <div class="merge-block block-4">4</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Bombs Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">💣</span>
            <h3>Bombs</h3>
          </div>
          <div class="help-content">
            <p>When a bomb block merges with a block of the same value, it explodes and destroys the entire stack!</p>
            <p>Bombs will appear in the queue naturally, but you can also buy them with gold.</p>
            <div class="merge-example">
              <div class="merge-before">
                <div class="merge-blocks">
                  <div class="merge-block block-2">2</div>
                  <div class="merge-block bomb-block">
                    <div class="bomb-content">
                      <div class="bomb-emoji">💣</div>
                      <div class="bomb-text">2</div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="merge-arrow">→</div>
              <div class="merge-after">
                <div class="merge-blocks">
                  <div class="merge-block bomb-block">
                    <div class="bomb-content">
                      <div class="bomb-emoji">💣</div>
                      <div class="bomb-text">4</div>
                    </div>
                  </div>
                </div>
              </div>
              <div style="display: flex; align-items: center; margin-left: 20px;">
                <span style="font-size: 24px; font-weight: bold; color: #f8fafc;">=</span>
                <span style="font-size: 18px; font-weight: bold; color: #ef4444; margin-left: 24px;">Stack Destroyed</span>
              </div>
            </div>
            

            <div style="display: flex; justify-content: center; margin: 16px 0;">
              <div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                <button class="powerup-btn bomb-btn" style="pointer-events: none; min-width: 60px; min-height: 60px; padding: 0 8px;">
                  <span class="powerup-emoji" style="font-size: 24px;">💣</span>
                  <div class="powerup-cost">
                    <span class="cost-emoji">💰</span>
                    <span class="cost-amount">25</span>
                  </div>
                </button>
                <span style="color: #f8fafc; font-size: 14px; text-align: center;">Converts next block to bomb</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Trash Can Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🗑️</span>
            <h3>Trash Can</h3>
          </div>
          <div class="help-content">
            <p>The trash can power-up allows you to remove the next block from the queue.</p>
            <div style="display: flex; justify-content: center; margin: 16px 0;">
              <div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                <button class="powerup-btn" style="pointer-events: none; min-width: 60px; min-height: 60px; padding: 0 8px;">
                  <span class="powerup-emoji" style="font-size: 24px;">🗑️</span>
                  <div class="powerup-cost">
                    <span class="cost-emoji">💰</span>
                    <span class="cost-amount">25</span>
                  </div>
                </button>
                <span style="color: #f8fafc; font-size: 14px; text-align: center;">Removes next block</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Gold Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">💰</span>
            <h3>Gold</h3>
          </div>
          <div class="help-content">
            <p><strong>Earn gold by merging blocks!</strong></p>
            <p>Each additional merge in a cascade earns additional gold.</p>
            <p>Use gold to buy power-ups, but use them strategically as power-ups double in cost each time they are used.</p>
          </div>
        </div>

        <!-- Stage System Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🚀</span>
            <h3>Stage Progression</h3>
          </div>
          <div class="help-content">
            <p>Merge two 512 blocks to create a 1024 block and gain a gold multiplier of 10x.</p>
            <p>Merging two 1024 blocks will increase the multiplier to 100x.</p>
            <p>Each additional block size up will increase your multiplier by 10x.</p>
            <div class="merge-example" style="justify-content: center; gap: 40px; padding: 20px;">
              <div style="display: flex; flex-direction: column; gap: 20px; align-items: center; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div style="margin: 0; justify-self: end;">
                    <div style="display: flex; align-items: center; justify-content: center;">
                      <div class="next-stage-block" data-value="1024" style="width: 100px; height: 42px; font-size: 22px; border-radius: 9px; display: flex; align-items: center; justify-content: center; font-weight: 600; background: #dc2626; color: white; box-shadow: 0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family);">1024</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div class="gold-display" style="margin: 0; justify-self: start;">
                    <div class="gold-value" style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 8px 16px; border-radius: 9px; font-weight: 600; font-size: 18px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div class="gold-emoji" style="position: absolute; top: -10px; left: -10px; font-size: 24px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div class="gold-text" style="position: relative; z-index: 2; font-size: 18px; font-weight: 600; line-height: 1; color: #000;">1.5k</div>
                      <div class="stage-multiplier-badge" style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 11px; font-weight: 700; padding: 3px 5px; border-radius: 8px; border: 2px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 20px; text-align: center;">10x</div>
                    </div>
                  </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div style="margin: 0; justify-self: end;">
                    <div style="display: flex; align-items: center; justify-content: center;">
                      <div class="next-stage-block" data-value="2048" style="width: 100px; height: 42px; font-size: 22px; border-radius: 9px; display: flex; align-items: center; justify-content: center; font-weight: 600; background: #9d174d; color: white; box-shadow: 0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family);">2048</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div class="gold-display" style="margin: 0; justify-self: start;">
                    <div class="gold-value" style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 8px 16px; border-radius: 9px; font-weight: 600; font-size: 18px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div class="gold-emoji" style="position: absolute; top: -10px; left: -10px; font-size: 24px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div class="gold-text" style="position: relative; z-index: 2; font-size: 18px; font-weight: 600; line-height: 1; color: #000;">15.5k</div>
                      <div class="stage-multiplier-badge" style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 11px; font-weight: 700; padding: 3px 5px; border-radius: 8px; border: 2px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 20px; text-align: center;">100x</div>
                    </div>
                  </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div style="margin: 0; justify-self: end;">
                    <div style="display: flex; align-items: center; justify-content: center;">
                      <div class="next-stage-block" data-value="4096" style="width: 100px; height: 42px; font-size: 22px; border-radius: 9px; display: flex; align-items: center; justify-content: center; font-weight: 600; background: #7c2d6d; color: white; box-shadow: 0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family);">4096</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div class="gold-display" style="margin: 0; justify-self: start;">
                    <div class="gold-value" style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 8px 16px; border-radius: 9px; font-weight: 600; font-size: 18px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div class="gold-emoji" style="position: absolute; top: -10px; left: -10px; font-size: 24px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div class="gold-text" style="position: relative; z-index: 2; font-size: 18px; font-weight: 600; line-height: 1; color: #000;">555.5k</div>
                      <div class="stage-multiplier-badge" style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 11px; font-weight: 700; padding: 3px 5px; border-radius: 8px; border: 2px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 20px; text-align: center;">1000x</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Sound Controls Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🔊</span>
            <h3>Sound Controls</h3>
          </div>
          <div class="help-content">
            <p>Customize your audio experience with the sound control menu.</p>
            <p><strong>Volume Slider:</strong> Adjust the overall volume from 0% (muted) to 100% (full volume).</p>
            <p><strong>Mute Toggle:</strong> Quickly mute or unmute all game sounds with a single click.</p>
            <p><strong>Sound Effects:</strong> The game includes various sound effects for merging blocks, collecting gold, using power-ups, and more.</p>
            <p>Access the sound controls by clicking the speaker icon in the top bar.</p>
          </div>
        </div>


      </div>



      <div class="actions">
        <button id="helpClose" class="ai-btn">Close</button>
      </div>
    </div>
  </div>

  <!-- Debug pane (hidden by default) -->
  <div id="debugPane" class="debug-pane">
    <button class="close-btn" id="debugClose" title="Close debug pane">×</button>
    <h3>Debug Controls</h3>
    
    <div class="section">
      <div class="section-title">Game Speed</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugSpeedSlider">Speed:</label>
          <input type="range" id="debugSpeedSlider" min="0" max="4" value="2" step="1">
          <div class="value-display" id="debugSpeedLabel">Medium</div>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Probability Curve</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugDecaySlider">Decay Factor:</label>
          <input type="range" id="debugDecaySlider" min="0.1" max="0.9" value="0.6" step="0.05">
          <div class="value-display" id="debugDecayLabel">0.60</div>
        </div>
        <div class="control-row">
          <button id="debugUpdateProbBtn" class="button">Update Probabilities</button>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Sound Settings</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugVolumeSlider">Volume:</label>
          <input type="range" id="debugVolumeSlider" min="0" max="100" value="30" step="5">
          <div class="value-display" id="debugVolumeLabel">30%</div>
        </div>
        <div class="control-row">
          <label for="debugMuteToggle">Mute:</label>
          <input type="checkbox" id="debugMuteToggle">
          <div class="value-display" id="debugMuteStatus">No</div>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Custom Block Dropper</div>
      <div class="controls">
        <div class="control-row">
          <label for="bombToggle">Bomb:</label>
          <input type="checkbox" id="bombToggle">
          <div class="value-display" id="bombStatus">No</div>
        </div>
        <div class="block-grid">
          <div class="block-item no-block" data-value="none">No Block</div>
          <div class="block-item" data-value="1">1</div>
          <div class="block-item" data-value="2">2</div>
          <div class="block-item" data-value="4">4</div>
          <div class="block-item" data-value="8">8</div>
          <div class="block-item" data-value="16">16</div>
          <div class="block-item" data-value="32">32</div>
          <div class="block-item" data-value="64">64</div>
          <div class="block-item" data-value="128">128</div>
          <div class="block-item" data-value="256">256</div>
          <div class="block-item" data-value="512">512</div>
          <div class="block-item" data-value="1024">1024</div>
          <div class="block-item" data-value="2048">2048</div>
          <div class="block-item" data-value="4096">4096</div>
          <div class="block-item" data-value="8192">8192</div>
          <div class="block-item" data-value="16384">16.4k</div>
        </div>
        <div class="selected-block-info">
          <button id="cascadeTestBtn" class="button primary">Cascade Test</button>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Game State</div>
      <div class="controls">
        <table class="debug-stats-table">
          <tr><td>Score:</td><td id="debugScore">0</td></tr>
          <tr><td>Gold:</td><td id="debugGold">0</td></tr>
          <tr><td>Stacks:</td><td id="debugStacks">4</td></tr>
          <tr><td>Capacity:</td><td id="debugCapacity">10</td></tr>
          <tr><td>Target:</td><td id="debugTarget">1024</td></tr>
          <tr><td>Max Block:</td><td id="debugMaxBlock">512</td></tr>
          <tr><td>Blocks Dropped:</td><td id="debugBlocksDropped">0</td></tr>
          <tr><td>Bomb Status:</td><td id="debugBombStatus">Disabled</td></tr>
          <tr><td>Stage:</td><td id="debugStage">1</td></tr>
        </table>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Current Probabilities</div>
      <div class="controls">
        <div id="debugProbabilities" style="font-size: 12px; font-family: monospace; max-height: 200px; overflow-y: auto; background: var(--bg); padding: 8px; border-radius: 4px; border: 1px solid #475569;">
          <!-- Probabilities will be populated here -->
        </div>
        <div class="control-row" style="margin-top: 12px;">
          <button id="testProbBtn" class="button">Test Probabilities</button>
        </div>
        
        <div class="control-row" style="margin-top: 8px;">
          <button id="testAudioContextBtn" class="button">Test Audio Context</button>
        </div>
      </div>
    </div>
    
    <div class="section bottom-buttons">
      <div class="controls">
        <div class="button-row">
          <button id="debugAiToggle" class="button primary">Auto Play: Off</button>
          <button id="grantScoreBtn" class="button primary">Grant 1000 Score</button>
<button id="grantGoldBtn" class="button primary">Grant 1000 Gold</button>
        </div>
      </div>
    </div>
  </div>

<script>
// Sound Manager for Stack Merge Game
class SoundManager {
  constructor() {
    this.audioContext = null;
    this.masterGain = null;
    this.isMuted = false;
    this.usePopMergeSounds = true; // true = pop sounds (default), false = musical sounds
    this.volume = 0.3; // Default volume (30%)
    this.initialized = false;
    
    // Individual sound type volumes (0-5 scale, converted to 0.0-1.0 internally)
    this.soundVolumes = {
      drop: 3,      // Drop sounds
      merge: 3,     // Merge sounds
      coin: 3,      // Gold coin sounds
      bomb: 3,      // Bomb explosion sounds
      other: 3      // Other sounds (stage up, etc.)
    };
    
    // Initialize audio context on first user interaction
    this.initAudioContext = this.initAudioContext.bind(this);
    this.addAudioInitListeners();
  }
  
  addAudioInitListeners() {
    // Add listeners for user interaction to initialize audio context
    const initEvents = ['click', 'touchstart', 'keydown', 'mousedown'];
    initEvents.forEach(event => {
      document.addEventListener(event, this.initAudioContext, { once: true, passive: true });
    });
    
    // Also add a listener that proactively checks audio context state on any interaction
    const checkAudioContext = () => {
      if (this.initialized && this.audioContext && this.audioContext.state === 'suspended') {
        console.log('🔄 Audio context suspended during interaction, attempting to resume...');
        this.audioContext.resume().catch(error => {
          console.warn('⚠️ Failed to resume audio context during interaction:', error);
        });
      }
    };
    
    // Add to the same events but without 'once' to check on every interaction
    initEvents.forEach(event => {
      document.addEventListener(event, checkAudioContext, { passive: true });
    });
  }
  
  initAudioContext() {
    if (this.initialized) return;
    
    try {
      // Create audio context
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create master gain node for volume control
      this.masterGain = this.audioContext.createGain();
      this.masterGain.connect(this.audioContext.destination);
      this.masterGain.gain.value = this.volume;
      
      this.initialized = true;
      console.log('🎵 Sound system initialized successfully');
      
      // Preload bomb audio for better performance
      this.preloadBombAudio();
      
      // Preload purchase audio for better performance
      this.preloadPurchaseAudio();
      
      // Preload stage up audio for better performance
      this.preloadStageUpAudio();
      
      // Preload coin audio for better performance
      this.preloadCoinAudio();
      
      // Remove init listeners since we're now initialized
      this.removeAudioInitListeners();
    } catch (error) {
      console.error('❌ Failed to initialize audio context:', error);
    }
  }
  
  removeAudioInitListeners() {
    const initEvents = ['click', 'touchstart', 'keydown', 'mousedown'];
    initEvents.forEach(event => {
      document.removeEventListener(event, this.initAudioContext);
    });
  }
  
  // Generate a satisfying, rich drop sound effect like placing a block
  playDropSound(blockValue = 1) {
    if (!this.initialized || this.isMuted) return;
    
    // Check individual sound type volume
    const actualVolume = this.getActualVolume('drop');
    if (actualVolume === 0) return; // Skip if this sound type is muted
    
    // Ensure audio context is running (some browsers suspend it)
    if (this.audioContext && this.audioContext.state === 'suspended') {
      this.audioContext.resume().catch(error => {
        console.warn('⚠️ Failed to resume audio context for drop sound:', error);
      });
    }
    
    try {
      // Create gain node for volume control
      const gainNode = this.audioContext.createGain();
      gainNode.connect(this.masterGain);
      
      // Apply individual sound type volume
      gainNode.gain.value = actualVolume;
      
      // Create an authentic IBM Model M mechanical keyboard sound
      const mainOsc = this.audioContext.createOscillator();
      const noiseSource = this.audioContext.createBufferSource();
      
      // Main oscillator - deep, resonant base (Model M signature)
      mainOsc.type = 'sine';
      const baseFreq = 75 + (Math.random() * 20 - 10); // 65-85Hz range for that deep thock
      mainOsc.frequency.setValueAtTime(baseFreq, this.audioContext.currentTime);
      
      // Add subtle frequency drift for mechanical realism
      mainOsc.frequency.exponentialRampToValueAtTime(baseFreq * 1.05, this.audioContext.currentTime + 0.08);
      
      // Create the characteristic Model M "thock" noise
      const noiseBuffer = this.audioContext.createBuffer(1, 1024, this.audioContext.sampleRate);
      const noiseData = noiseBuffer.getChannelData(0);
      
      // Fill buffer with rich, mechanical noise
      for (let i = 0; i < noiseData.length; i++) {
        // Create a mechanical, resonant envelope
        const envelope = Math.exp(-i * 0.008); // Slow decay for resonance
        noiseData[i] = (Math.random() * 2 - 1) * envelope * 0.8; // Rich mechanical noise
      }
      
      noiseSource.buffer = noiseBuffer;
      
      // Create filters for authentic Model M sound
      const lowPassFilter = this.audioContext.createBiquadFilter();
      lowPassFilter.type = 'lowpass';
      lowPassFilter.frequency.setValueAtTime(800, this.audioContext.currentTime); // Lower cutoff for warmth
      lowPassFilter.Q.setValueAtTime(0.5, this.audioContext.currentTime); // Natural resonance
      
      const highPassFilter = this.audioContext.createBiquadFilter();
      highPassFilter.type = 'highpass';
      highPassFilter.frequency.setValueAtTime(60, this.audioContext.currentTime); // Very low cutoff for deep bass
      highPassFilter.Q.setValueAtTime(0.5, this.audioContext.currentTime); // Natural resonance
      
      // Create gain nodes
      const toneGain = this.audioContext.createGain();
      const noiseGain = this.audioContext.createGain();
      
      // Connect the audio chain
      mainOsc.connect(toneGain);
      toneGain.connect(gainNode);
      
      noiseSource.connect(lowPassFilter);
      lowPassFilter.connect(highPassFilter);
      highPassFilter.connect(noiseGain);
      noiseGain.connect(gainNode);
      
      // Volume envelope: Model M signature attack and decay (scaled by volume)
      gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(actualVolume, this.audioContext.currentTime + 0.001); // Use actual volume
      gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.12); // Long, resonant decay
      
      // Separate gain control for tone vs noise (scaled by volume)
      toneGain.gain.linearRampToValueAtTime(actualVolume * 0.5, this.audioContext.currentTime + 0.001); // Scale tone by volume
      toneGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.12);
      
      noiseGain.gain.setValueAtTime(0, this.audioContext.currentTime);
      noiseGain.gain.linearRampToValueAtTime(actualVolume * 0.625, this.audioContext.currentTime + 0.001); // Scale noise by volume
      noiseGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.12);
      
      // Start sources
      mainOsc.start(this.audioContext.currentTime);
      noiseSource.start(this.audioContext.currentTime);
      
      // Stop after natural Model M duration
      mainOsc.stop(this.audioContext.currentTime + 0.12);
      noiseSource.stop(this.audioContext.currentTime + 0.12);
      
      // Clean up nodes after playback
      const cleanup = () => {
        mainOsc.disconnect();
        noiseSource.disconnect();
        lowPassFilter.disconnect();
        highPassFilter.disconnect();
        toneGain.disconnect();
        noiseGain.disconnect();
        gainNode.disconnect();
      };
      
      // Set timeout to ensure cleanup happens
      setTimeout(cleanup, 130);
      
      // Log successful sound playback (only in development)
      if (console && console.log) {
        console.log(`🔊 Rich, satisfying drop sound played successfully for block value ${blockValue}`);
      }
      
    } catch (error) {
      console.error('❌ Failed to play drop sound:', error);
    }
  }
  
  // Generate a peaceful, raindrop-like merge sound effect
  playMergeSound(blockValue = 1) {
    if (!this.initialized || this.isMuted) return;
    
    // Check individual sound type volume
    const actualVolume = this.getActualVolume('merge');
    if (actualVolume === 0) return; // Skip if this sound type is muted
    
    // Choose between musical and pop-like sounds based on user preference
    if (this.usePopMergeSounds) {
      console.log('💨 Playing pop merge sound');
      this.playPopMergeSound(blockValue, actualVolume);
    } else {
      console.log('🎵 Playing musical merge sound');
      this.playMusicalMergeSound(blockValue, actualVolume);
    }
  }
  
  // Generate a beautiful, physical bell sound like Christmas music
  playMusicalMergeSound(blockValue = 1, volume = 1.0) {
    if (!this.initialized || this.isMuted) return;
    
    // Ensure audio context is running (some browsers suspend it)
    if (this.audioContext && this.audioContext.state === 'suspended') {
      this.audioContext.resume().catch(error => {
        console.warn('⚠️ Failed to resume audio context for musical merge sound:', error);
      });
    }
    
    try {
      // Create gain node for volume control
      const gainNode = this.audioContext.createGain();
      gainNode.connect(this.masterGain);
      
      // Apply individual sound type volume
      gainNode.gain.value = volume;
      
      // Calculate frequency based on block value using a beautiful major scale
      // Map block values to create a Christmas bell-like progression
      const getFrequencyForBlock = (value) => {
        // Chromatic scale: moves up in half-steps (semitones) for smooth progression
        // Uses A4 (440Hz) as reference and moves up in 12-tone equal temperament
        const bellScale = {
          1: 440.00,   // A4 (reference pitch - bright start)
          2: 466.16,   // A#4/Bb4 (half-step up)
          4: 493.88,   // B4 (half-step up)
          8: 523.25,   // C5 (half-step up)
          16: 554.37,  // C#5/Db5 (half-step up)
          32: 587.33,  // D5 (half-step up)
          64: 622.25,  // D#5/Eb5 (half-step up)
          128: 659.25, // E5 (half-step up)
          256: 698.46, // F5 (half-step up)
          512: 739.99, // F#5/Gb5 (half-step up)
          1024: 783.99, // G5 (half-step up)
          2048: 830.61, // G#5/Ab5 (half-step up)
          4096: 880.00, // A5 (octave up - half-step progression)
          8192: 932.33, // A#5/Bb5 (half-step up)
          16384: 987.77, // B5 (half-step up)
          32768: 1046.50, // C6 (half-step up)
          65536: 1108.73, // C#6/Db6 (half-step up)
          131072: 1174.66, // D6 (half-step up)
          262144: 1244.51, // D#6/Eb6 (half-step up)
          524288: 1318.51, // E6 (half-step up)
          1048576: 1396.91, // F6 (half-step up)
          2097152: 1479.98, // F#6/Gb6 (half-step up)
          4194304: 1567.98, // G6 (half-step up)
          8388608: 1661.22, // G#6/Ab6 (half-step up)
          16777216: 1760.00, // A6 (octave up - half-step progression)
          33554432: 1864.66, // A#6/Bb6 (half-step up)
          67108864: 1975.53, // B6 (half-step up)
          134217728: 2093.00, // C7 (half-step up)
          268435456: 2217.46, // C#7/Db7 (half-step up)
          536870912: 2349.32, // D7 (half-step up)
          1073741824: 2489.02, // D#7/Eb7 (half-step up)
          2147483648: 2637.02, // E7 (half-step up)
          4294967296: 2793.83, // F7 (half-step up)
          8589934592: 2959.96, // F#7/Gb7 (half-step up)
          17179869184: 3135.96, // G7 (half-step up)
          34359738368: 3322.44, // G#7/Ab7 (half-step up)
          68719476736: 3520.00, // A7 (octave up - half-step progression)
          137438953472: 3729.31, // A#7/Bb7 (half-step up)
          274877906944: 3951.07, // B7 (half-step up)
          549755813888: 4186.00, // C8 (half-step up)
          1099511627776: 4434.92, // C#8/Db8 (half-step up)
          2199023255552: 4698.64, // D8 (half-step up)
          4398046511104: 4978.03, // D#8/Eb8 (half-step up)
          8796093022208: 5274.04, // E8 (half-step up)
          17592186044416: 5587.66, // F8 (half-step up)
          35184372088832: 5919.91, // F#8/Gb8 (half-step up)
          70368744177664: 6271.93, // G8 (half-step up)
          140737488355328: 6644.88, // G#8/Ab8 (half-step up)
          281474976710656: 7040.00, // A8 (octave up - half-step progression)
          562949953421312: 7458.62, // A#8/Bb8 (half-step up)
          1125899906842624: 7902.13, // B8 (half-step up)
          2251799813685248: 8372.00, // C9 (half-step up)
          4503599627370496: 8869.84, // C#9/Db9 (half-step up)
          9007199254740992: 9397.27, // D9 (half-step up)
          18014398509481984: 9956.06, // D#9/Eb9 (half-step up)
          36028797018963968: 10548.08, // E9 (half-step up)
          72057594037927936: 11175.32, // F9 (half-step up)
          144115188075855872: 11839.82, // F#9/Gb9 (half-step up)
          288230376151711744: 12543.85, // G9 (half-step up)
          576460752303423488: 13289.75, // G#9/Ab9 (half-step up)
          1152921504606846976: 14080.00, // A9 (octave up - half-step progression)
          2305843009213693952: 14917.24, // A#9/Bb9 (half-step up)
          4611686018427387904: 15804.27, // B9 (half-step up)
          9223372036854775808: 16744.00, // C10 (half-step up - final progression)
        };
        
        // Return the mapped frequency or fallback to a calculated frequency for very large values
        if (bellScale[value]) {
          return bellScale[value];
        } else {
          // For extremely large values beyond our scale, use chromatic octave calculation
          const octave = Math.floor(Math.log2(value) / 12); // 12 notes per chromatic scale
          const baseNote = value % 12;
          const baseFreq = bellScale[Math.pow(2, baseNote)] || 440.00;
          return baseFreq * Math.pow(2, octave);
        }
      };
      
      const frequency = getFrequencyForBlock(blockValue);
      
      // Create a crystal clear, pure bell sound
      const mainOsc = this.audioContext.createOscillator();
      const harmonicOsc1 = this.audioContext.createOscillator();
      
      // Main bell tone - pure sine wave for crystal clarity
      mainOsc.type = 'sine'; // Pure sine wave for clear, bell-like sound
      mainOsc.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
      
      // Single harmonic - octave above for clear resonance
      harmonicOsc1.type = 'sine';
      harmonicOsc1.frequency.setValueAtTime(frequency * 2, this.audioContext.currentTime);
      
      // Create separate gain nodes for different layers
      const mainGain = this.audioContext.createGain();
      const harmonicGain1 = this.audioContext.createGain();
      
      // Connect the audio chain
      mainOsc.connect(mainGain);
      mainGain.connect(gainNode);
      
      harmonicOsc1.connect(harmonicGain1);
      harmonicGain1.connect(gainNode);
      
      // Volume envelope: crystal clear bell with natural decay (scaled by volume)
      gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.001); // Use volume parameter
      gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1.0); // Natural bell decay
      
      // Separate gain control for clear bell balance (scaled by volume)
      mainGain.gain.setValueAtTime(0, this.audioContext.currentTime);
      mainGain.gain.linearRampToValueAtTime(volume * 0.9, this.audioContext.currentTime + 0.001); // Scale main tone by volume
      mainGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1.0);
      
      harmonicGain1.gain.setValueAtTime(0, this.audioContext.currentTime);
      harmonicGain1.gain.linearRampToValueAtTime(volume * 0.3, this.audioContext.currentTime + 0.001); // Scale harmonic by volume
      harmonicGain1.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1.0);
      
      // Start both oscillators
      mainOsc.start(this.audioContext.currentTime);
      harmonicOsc1.start(this.audioContext.currentTime);
      
      // Stop after clear bell resonance duration
      mainOsc.stop(this.audioContext.currentTime + 1.0);
      harmonicOsc1.stop(this.audioContext.currentTime + 1.0);
      
      // Clean up nodes after playback
      const cleanup = () => {
        mainOsc.disconnect();
        harmonicOsc1.disconnect();
        mainGain.disconnect();
        harmonicGain1.disconnect();
        gainNode.disconnect();
      };
      
      // Set timeout to ensure cleanup happens
      setTimeout(cleanup, 1050);
      
      // Log successful sound playback (only in development)
      if (console && console.log) {
        console.log(`🔔 Beautiful bell merge sound played successfully for block value ${blockValue} at ${Math.round(frequency)} Hz`);
      }
      
    } catch (error) {
      console.error('❌ Failed to play merge sound:', error);
    }
  }
  
  // Generate a satisfying pop merge sound effect with frequency variation based on block value
  playPopMergeSound(blockValue = 1, volume = 1.0) {
    if (!this.initialized || this.isMuted) return;
    
    // Ensure audio context is running (some browsers suspend it)
    if (this.audioContext && this.audioContext.state === 'suspended') {
      this.audioContext.resume().catch(error => {
        console.warn('⚠️ Failed to resume audio context for pop merge sound:', error);
      });
    }
    
    try {
      // Create gain node for volume control
      const gainNode = this.audioContext.createGain();
      gainNode.connect(this.masterGain);
      
      // Apply individual sound type volume
      gainNode.gain.value = volume;
      
      // Calculate frequency based on block value - higher blocks = higher pitch
      const getPopFrequency = (value) => {
        // Map block values to create a satisfying pitch progression
        // Start with lower frequencies for small blocks, higher for big blocks
        const baseFreq = 200; // Base frequency for value 1
        const freqMultiplier = Math.log2(value) * 0.3 + 1; // Logarithmic scaling
        return Math.min(baseFreq * freqMultiplier, 1200); // Cap at 1200Hz to avoid harshness
      };
      
      const frequency = getPopFrequency(blockValue);
      
      // Create a pop sound using a combination of oscillators and noise
      const mainOsc = this.audioContext.createOscillator();
      const noiseSource = this.audioContext.createBufferSource();
      
      // Main oscillator for the pop tone (more subtle)
      mainOsc.type = 'sine';
      mainOsc.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
      
      // Create a more percussive noise burst for the "pop" character
      const noiseBuffer = this.audioContext.createBuffer(1, 256, this.audioContext.sampleRate); // Shorter for more percussive
      const noiseData = noiseBuffer.getChannelData(0);
      
      // Fill buffer with more aggressive, percussive noise
      for (let i = 0; i < noiseData.length; i++) {
        // Create a sharp, percussive noise envelope
        const envelope = Math.exp(-i * 0.08); // Much faster decay for sharpness
        noiseData[i] = (Math.random() * 2 - 1) * envelope * 0.8; // Increased volume for more impact
      }
      
      noiseSource.buffer = noiseBuffer;
      
      // Create filters for more percussive pop character
      const lowPassFilter = this.audioContext.createBiquadFilter();
      lowPassFilter.type = 'lowpass';
      lowPassFilter.frequency.setValueAtTime(frequency * 3, this.audioContext.currentTime); // Higher cutoff for more high-end
      lowPassFilter.Q.setValueAtTime(0.5, this.audioContext.currentTime); // Lower Q for wider passband
      
      const highPassFilter = this.audioContext.createBiquadFilter();
      highPassFilter.type = 'highpass';
      highPassFilter.frequency.setValueAtTime(frequency * 0.3, this.audioContext.currentTime); // Lower cutoff for more bass
      highPassFilter.Q.setValueAtTime(0.3, this.audioContext.currentTime); // Lower Q for wider passband
      
      // Create separate gain nodes for tone vs noise
      const toneGain = this.audioContext.createGain();
      const noiseGain = this.audioContext.createGain();
      
      // Connect the audio chain with separate gain control
      mainOsc.connect(toneGain);
      toneGain.connect(gainNode);
      
      noiseSource.connect(lowPassFilter);
      lowPassFilter.connect(highPassFilter);
      highPassFilter.connect(noiseGain);
      noiseGain.connect(gainNode);
      
      // Volume envelope: very quick attack, fast decay for pop (scaled by volume)
      gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.001); // Use volume parameter
      gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.06); // Faster decay for more percussive
      
      // Separate gain control for tone vs noise (scaled by volume)
      toneGain.gain.setValueAtTime(0, this.audioContext.currentTime);
      toneGain.gain.linearRampToValueAtTime(volume * 0.15, this.audioContext.currentTime + 0.001); // Scale tone by volume
      toneGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.06);
      
      noiseGain.gain.setValueAtTime(0, this.audioContext.currentTime);
      noiseGain.gain.linearRampToValueAtTime(volume * 0.8, this.audioContext.currentTime + 0.001); // Scale noise by volume
      noiseGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.06);
      
      // Start both sources
      mainOsc.start(this.audioContext.currentTime);
      noiseSource.start(this.audioContext.currentTime);
      
      // Stop after shorter duration for more percussive pop
      mainOsc.stop(this.audioContext.currentTime + 0.06);
      noiseSource.stop(this.audioContext.currentTime + 0.06);
      
      // Clean up nodes after playback
      const cleanup = () => {
        mainOsc.disconnect();
        noiseSource.disconnect();
        lowPassFilter.disconnect();
        highPassFilter.disconnect();
        toneGain.disconnect();
        noiseGain.disconnect();
        gainNode.disconnect();
      };
      
      // Set timeout to ensure cleanup happens
      setTimeout(cleanup, 80);
      
      // Log successful sound playback (only in development)
      if (console && console.log) {
        console.log(`💨 Pop merge sound played successfully for block value ${blockValue} at ${Math.round(frequency)} Hz`);
      }
      
    } catch (error) {
      console.error('❌ Failed to play pop merge sound:', error);
    }
  }
  
  // Set master volume (0.0 to 1.0)
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(1, volume));
    if (this.masterGain) {
      this.masterGain.gain.value = this.volume;
    }
    this.saveSoundSettings();
  }
  
  // Toggle mute state
  toggleMute() {
    this.isMuted = !this.isMuted;
    if (this.masterGain) {
      this.masterGain.gain.value = this.isMuted ? 0 : this.volume;
    }
    this.saveSoundSettings();
    return this.isMuted;
  }
  
  // Get current mute state
  getMuteState() {
    return this.isMuted;
  }
  
  // Get current volume
  getVolume() {
    return this.volume;
  }
  
  // Proactively check and resume audio context if suspended
  ensureAudioContextActive() {
    // Quick synchronous check first
    if (!this.audioContext || this.audioContext.state !== 'suspended') {
      return Promise.resolve(true); // Already active or not initialized
    }
    
    // Only log and resume if actually suspended
    console.log('🔄 Audio context suspended, attempting to resume...');
    return this.audioContext.resume().then(() => {
      console.log('✅ Audio context resumed successfully');
      return true;
    }).catch(error => {
      console.warn('⚠️ Failed to resume audio context:', error);
      return false;
    });
  }
  
  // Synchronous check for audio context state (for performance-critical operations)
  isAudioContextActive() {
    return this.audioContext && this.audioContext.state === 'running';
  }
  
  // Batch check and resume audio context (for multiple sounds at once)
  batchEnsureAudioContextActive() {
    // Quick synchronous check first
    if (!this.audioContext || this.audioContext.state !== 'suspended') {
      return Promise.resolve(true); // Already active or not initialized
    }
    
    // Only resume once for the batch
    console.log('🔄 Audio context suspended during batch operation, resuming...');
    return this.audioContext.resume().then(() => {
      console.log('✅ Audio context resumed for batch operation');
      return true;
    }).catch(error => {
      console.warn('⚠️ Failed to resume audio context for batch operation:', error);
      return false;
    });
  }
  
  // Toggle between musical and pop merge sounds
  toggleMergeSoundType() {
    this.usePopMergeSounds = !this.usePopMergeSounds;
    console.log(`🔄 Switched to ${this.usePopMergeSounds ? 'pop' : 'musical'} merge sounds`);
    this.saveSoundSettings();
    return this.usePopMergeSounds;
  }
  
  // Get current merge sound type preference
  getMergeSoundType() {
    return this.usePopMergeSounds;
  }
  
  // Set individual sound type volume (0-5 scale)
  setSoundVolume(soundType, volume) {
    console.log(`🎚️ setSoundVolume called with: ${soundType} = ${volume}`);
    
    if (this.soundVolumes.hasOwnProperty(soundType)) {
      const oldVolume = this.soundVolumes[soundType];
      this.soundVolumes[soundType] = Math.max(0, Math.min(5, Math.round(volume)));
      console.log(`🔊 Set ${soundType} volume from ${oldVolume} to ${this.soundVolumes[soundType]}`);
      this.saveSoundSettings();
      
      // Log current state of all volumes
      console.log('📊 Current sound volumes:', this.soundVolumes);
    } else {
      console.warn(`⚠️ Unknown sound type: ${soundType}`);
    }
  }
  
  // Get individual sound type volume (0-5 scale)
  getSoundVolume(soundType) {
    // Check if the sound type exists and has a value (including 0)
    if (this.soundVolumes.hasOwnProperty(soundType)) {
      return this.soundVolumes[soundType];
    }
    // Only return default 3 if the sound type doesn't exist at all
    return 3;
  }
  
  // Get all sound volumes
  getAllSoundVolumes() {
    return { ...this.soundVolumes };
  }
  
  // Set all sound volumes at once
  setAllSoundVolumes(volumes) {
    console.log('🎚️ setAllSoundVolumes called with:', volumes);
    
    Object.keys(volumes).forEach(soundType => {
      if (this.soundVolumes.hasOwnProperty(soundType)) {
        const oldVolume = this.soundVolumes[soundType];
        const newVolume = Math.max(0, Math.min(5, Math.round(volumes[soundType])));
        this.soundVolumes[soundType] = newVolume;
        console.log(`🔊 ${soundType}: ${oldVolume} → ${newVolume} (input: ${volumes[soundType]})`);
      }
    });
    
    console.log('🔊 Final sound volumes after update:', this.soundVolumes);
  }
  
  // Convert volume scale (0-5) to actual volume (0.0-2.0 for drop/merge, 0.0-1.0 for others)
  getActualVolume(soundType) {
    console.log(`🔍 getActualVolume called for: ${soundType}`);
    
    // If the sound type has a specific volume, use it
    if (this.soundVolumes.hasOwnProperty(soundType)) {
      const volume = this.soundVolumes[soundType];
      let actualVolume;
      
      // Drop and merge sounds get enhanced volume range (0.0-2.0) for more impact
      if (soundType === 'drop' || soundType === 'merge') {
        actualVolume = volume === 0 ? 0 : (volume / 5) * 2.0; // 0 = mute, 1-5 = 0.4 to 2.0
      } else {
        actualVolume = volume === 0 ? 0 : volume / 5; // 0 = mute, 1-5 = 0.2 to 1.0
      }
      
      console.log(`✅ ${soundType} has specific volume: ${volume} → ${actualVolume} (${Math.round(actualVolume * 100)}%)`);
      return actualVolume;
    }
    
    // If no specific volume is set, fall back to "Other" volume
    const fallbackVolume = this.soundVolumes.other || 3;
    let fallbackActual;
    
    if (soundType === 'drop' || soundType === 'merge') {
      fallbackActual = fallbackVolume === 0 ? 0 : (fallbackVolume / 5) * 2.0;
    } else {
      fallbackActual = fallbackVolume === 0 ? 0 : fallbackVolume / 5;
    }
    
    console.log(`🔄 ${soundType} using fallback volume: ${fallbackVolume} → ${fallbackActual} (${Math.round(fallbackActual * 100)}%)`);
    return fallbackActual;
  }
  
  // Save sound settings to localStorage
  saveSoundSettings() {
    try {
      const settings = {
        isMuted: this.isMuted,
        volume: this.volume,
        usePopMergeSounds: this.usePopMergeSounds,
        soundVolumes: this.soundVolumes,
        timestamp: Date.now()
      };
      localStorage.setItem('stackMerge_soundSettings', JSON.stringify(settings));
      console.log('💾 Sound settings saved to localStorage');
    } catch (error) {
      console.error('❌ Failed to save sound settings:', error);
    }
  }
  
  // Load sound settings from localStorage
  loadSoundSettings() {
    try {
      const saved = localStorage.getItem('stackMerge_soundSettings');
      if (saved) {
        const settings = JSON.parse(saved);
        
        // Load settings with validation
        if (typeof settings.isMuted === 'boolean') this.isMuted = settings.isMuted;
        if (typeof settings.volume === 'number') this.volume = Math.max(0, Math.min(1, settings.volume));
        if (typeof settings.usePopMergeSounds === 'boolean') this.usePopMergeSounds = settings.usePopMergeSounds;
        
        // Load individual sound volumes
        if (settings.soundVolumes && typeof settings.soundVolumes === 'object') {
          Object.keys(settings.soundVolumes).forEach(soundType => {
            if (this.soundVolumes.hasOwnProperty(soundType)) {
              const vol = settings.soundVolumes[soundType];
              if (typeof vol === 'number' && vol >= 0 && vol <= 5) {
                this.soundVolumes[soundType] = Math.round(vol);
              }
            }
          });
        }
        
        console.log('📂 Sound settings loaded from localStorage:', settings);
        return true;
      }
    } catch (error) {
      console.error('❌ Failed to load sound settings:', error);
    }
    return false;
  }

  // Preload bomb audio for better performance
  bombAudio = null;
  
  // Preload coin audio files for better performance
  coinAudios = null;
  
  // Preload stage up audio for better performance
  stageUpAudio = null;
  
  // Preload purchase audio for better performance
  purchaseAudio = null;
  
  // Load and play the bomb explosion sound effect from audio file
  playBombSound() {
    if (!this.initialized || this.isMuted) return;
    
    // Check individual sound type volume
    const actualVolume = this.getActualVolume('bomb');
    if (actualVolume === 0) return; // Skip if this sound type is muted
    
    // Ensure audio context is running (some browsers suspend it)
    if (this.audioContext && this.audioContext.state === 'suspended') {
      this.audioContext.resume().catch(error => {
        console.warn('⚠️ Failed to resume audio context for bomb sound:', error);
      });
    }
    
    try {
      // Create audio element for the bomb sound if not already created
      if (!this.bombAudio) {
        this.bombAudio = new Audio('sounds/bomb.mp3');
        this.bombAudio.preload = 'auto'; // Preload the audio
      }
      
      // Apply individual sound type volume
      this.bombAudio.volume = actualVolume;
      
      // Reset audio to beginning and play
      this.bombAudio.currentTime = 0;
      this.bombAudio.play().catch(error => {
        console.error('❌ Failed to play bomb audio file:', error);
      });
      
      console.log('💥 Bomb explosion sound played successfully');
      
    } catch (error) {
      console.error('❌ Failed to play bomb sound:', error);
    }
  }
  
  // Load and play the purchase sound effect from audio file
  playPurchaseSound() {
    if (!this.initialized || this.isMuted) return;
    
    // Check individual sound type volume - use 'other' category as requested
    const actualVolume = this.getActualVolume('other');
    if (actualVolume === 0) return; // Skip if this sound type is muted
    
    // Ensure audio context is running (some browsers suspend it)
    if (this.audioContext && this.audioContext.state === 'suspended') {
      this.audioContext.resume().catch(error => {
        console.warn('⚠️ Failed to resume audio context for purchase sound:', error);
      });
    }
    
    try {
      // Create audio element for the purchase sound if not already created
      if (!this.purchaseAudio) {
        this.purchaseAudio = new Audio('sounds/purchase.wav');
        this.purchaseAudio.preload = 'auto'; // Preload the audio
      }
      
      // Apply individual sound type volume
      this.purchaseAudio.volume = actualVolume;
      
      // Reset audio to beginning and play
      this.purchaseAudio.currentTime = 0;
      this.purchaseAudio.play().catch(error => {
        console.error('❌ Failed to play purchase audio file:', error);
      });
      
      console.log('💰 Purchase sound played successfully');
      
    } catch (error) {
      console.error('❌ Failed to play purchase sound:', error);
    }
  }
  
  // Preload bomb audio for better performance
  preloadBombAudio() {
    try {
      this.bombAudio = new Audio('sounds/bomb.mp3');
      this.bombAudio.preload = 'auto';
      console.log('💥 Bomb audio preloaded successfully');
    } catch (error) {
      console.error('❌ Failed to preload bomb audio:', error);
    }
  }
  
  // Preload purchase audio for better performance
  preloadPurchaseAudio() {
    try {
      this.purchaseAudio = new Audio('sounds/purchase.wav');
      this.purchaseAudio.preload = 'auto';
      console.log('💰 Purchase audio preloaded successfully');
    } catch (error) {
      console.error('❌ Failed to preload purchase audio:', error);
    }
  }
  
  // Preload stage up audio for better performance
  preloadStageUpAudio() {
    try {
      this.stageUpAudio = new Audio('sounds/stage_up.mp3');
      this.stageUpAudio.preload = 'auto';
      console.log('🎯 Stage up audio preloaded successfully');
    } catch (error) {
      console.error('❌ Failed to preload stage up audio:', error);
    }
  }
  
  // Preload coin audio files for better performance
  preloadCoinAudio() {
    try {
      this.coinAudios = [];
      for (let i = 1; i <= 7; i++) {
        const coinAudio = new Audio(`sounds/coin${i}.wav`);
        coinAudio.preload = 'auto';
        
        // Force load the audio by setting source and triggering load
        coinAudio.load();
        
        // Add error handling for individual files
        coinAudio.addEventListener('error', (e) => {
          console.error(`❌ Failed to load coin${i}.wav:`, e);
        });
        
        this.coinAudios.push(coinAudio);
      }
      console.log('🪙 Coin audio files preloaded successfully (7 sounds)');
    } catch (error) {
      console.error('❌ Failed to preload coin audio:', error);
      // Set empty array so playCoinSound doesn't crash
      this.coinAudios = [];
    }
  }
  
  // Play a random coin sound effect when gold is earned
  playCoinSound() {
    if (!this.initialized || this.isMuted) return;
    
    // Check individual sound type volume
    const actualVolume = this.getActualVolume('coin');
    if (actualVolume === 0) return; // Skip if this sound type is muted
    
    // Ensure audio context is running (some browsers suspend it)
    if (this.audioContext && this.audioContext.state === 'suspended') {
      this.audioContext.resume().catch(error => {
        console.warn('⚠️ Failed to resume audio context:', error);
      });
    }
    
    try {
      // Pick a random coin sound (1-7 for 7 sounds)
      const randomIndex = Math.floor(Math.random() * 7) + 1;
      
      // Create a fresh audio element for this specific sound to allow overlapping playback
      const coinAudio = new Audio(`sounds/coin${randomIndex}.wav`);
      coinAudio.volume = actualVolume; // Apply individual sound type volume
      
      // Add error handling and retry logic
      coinAudio.addEventListener('error', (e) => {
        console.error(`❌ Audio error for coin${randomIndex}:`, e);
      });
      
      // Ensure audio is loaded before playing
      coinAudio.addEventListener('canplaythrough', () => {
        // Play the sound once it's ready
        coinAudio.play().then(() => {
          console.log(`🪙 Coin sound ${randomIndex} played successfully`);
        }).catch(error => {
          console.error(`❌ Failed to play coin audio ${randomIndex}:`, error);
          // Try alternative approach if direct play fails
          this.playCoinSoundFallback(randomIndex);
        });
      });
      
      // Set a timeout in case the audio doesn't load
      setTimeout(() => {
        if (coinAudio.readyState < 2) { // HAVE_CURRENT_DATA
          console.warn(`⚠️ Coin audio ${randomIndex} taking too long to load, trying fallback`);
          this.playCoinSoundFallback(randomIndex);
        }
      }, 100);
      
      // Try to play immediately as well
      coinAudio.play().catch(error => {
        console.log(`ℹ️ Immediate play failed for coin${randomIndex}, waiting for load...`);
      });
      
    } catch (error) {
      console.error('❌ Failed to create coin sound:', error);
      // Try fallback with a different random sound
      this.playCoinSoundFallback(Math.floor(Math.random() * 7) + 1);
    }
  }
  
  // Fallback method using preloaded audio if fresh creation fails
  playCoinSoundFallback(soundIndex) {
    if (!this.coinAudios || this.coinAudios.length === 0) return;
    
    // Check individual sound type volume
    const actualVolume = this.getActualVolume('coin');
    if (actualVolume === 0) return; // Skip if this sound type is muted
    
    // Validate sound index is within range (1-7)
    if (soundIndex < 1 || soundIndex > 7) {
      console.warn(`⚠️ Invalid coin sound index: ${soundIndex}, using random fallback`);
      soundIndex = Math.floor(Math.random() * 7) + 1;
    }
    
    try {
      const coinAudio = this.coinAudios[soundIndex - 1]; // Convert to 0-based index
      if (coinAudio) {
        // Apply individual sound type volume
        coinAudio.volume = actualVolume;
        coinAudio.currentTime = 0;
        coinAudio.play().catch(error => {
          console.error(`❌ Fallback also failed for coin sound ${soundIndex}:`, error);
        });
        console.log(`🪙 Coin sound ${soundIndex} played via fallback`);
      } else {
        console.warn(`⚠️ No preloaded audio found for coin sound ${soundIndex}`);
      }
    } catch (error) {
      console.error(`❌ Fallback method failed for coin sound ${soundIndex}:`, error);
    }
  }
  
  // Test method to verify all coin sounds are working (for debugging)
  testAllCoinSounds() {
    if (!this.initialized || this.isMuted) return;
    
    console.log('🧪 Testing all coin sounds...');
    for (let i = 1; i <= 7; i++) {
      setTimeout(() => {
        this.playCoinSound();
      }, i * 200); // Play each sound 200ms apart
    }
  }
  
  // Test method to verify stage up sound is working (for debugging)
  testStageUpSound() {
    if (!this.initialized || this.isMuted) return;
    
    console.log('🧪 Testing stage up sound...');
    this.playStageProgressionSound();
  }
  
  // Test method to verify audio context state (for debugging)
  testAudioContextState() {
    if (!this.audioContext) {
      console.log('❌ Audio context not initialized');
      return;
    }
    
    console.log('🔍 Audio context state:', this.audioContext.state);
    console.log('🔍 Audio context sample rate:', this.audioContext.sampleRate);
    console.log('🔍 Audio context current time:', this.audioContext.currentTime);
    
    if (this.audioContext.state === 'suspended') {
      console.log('⚠️ Audio context is suspended - attempting to resume...');
      this.audioContext.resume().then(() => {
        console.log('✅ Audio context resumed successfully');
      }).catch(error => {
        console.error('❌ Failed to resume audio context:', error);
      });
    }
  }
  
  // Verify coin sound loading status (for debugging)
  getCoinSoundStatus() {
    if (!this.coinAudios) return { loaded: false, count: 0, status: 'Not initialized' };
    
    const status = {
      loaded: true,
      count: this.coinAudios.length,
      expected: 7,
      readyStates: [],
      errors: []
    };
    
    this.coinAudios.forEach((audio, index) => {
      const soundNumber = index + 1;
      status.readyStates.push({
        sound: `coin${soundNumber}`,
        readyState: audio.readyState,
        error: audio.error
      });
      
      if (audio.error) {
        status.errors.push(`coin${soundNumber}: ${audio.error.message}`);
      }
    });
    
    return status;
  }

  // Load and play the stage up sound effect from audio file
  playStageProgressionSound() {
    if (!this.initialized || this.isMuted) return;
    
    // Check individual sound type volume
    const actualVolume = this.getActualVolume('other');
    if (actualVolume === 0) return; // Skip if this sound type is muted
    
    // Ensure audio context is running (some browsers suspend it)
    if (this.audioContext && this.audioContext.state === 'suspended') {
      this.audioContext.resume().catch(error => {
        console.warn('⚠️ Failed to resume audio context for stage progression sound:', error);
      });
    }
    
    try {
      // Create audio element for the stage up sound if not already created
      if (!this.stageUpAudio) {
        this.stageUpAudio = new Audio('sounds/stage_up.mp3');
        this.stageUpAudio.preload = 'auto'; // Preload the audio
      }
      
      // Apply individual sound type volume
      this.stageUpAudio.volume = actualVolume;
      
      // Reset audio to beginning and play
      this.stageUpAudio.currentTime = 0;
      this.stageUpAudio.play().catch(error => {
        console.error('❌ Failed to play stage up audio file:', error);
      });
      
      console.log('🎯 Stage up sound played successfully');
      
    } catch (error) {
      console.error('❌ Failed to play stage up sound:', error);
    }
  }
}

// Initialize sound manager
const soundManager = new SoundManager();

// Load saved sound settings
soundManager.loadSoundSettings();

// weights and probabilities - will be dynamically updated based on stage
let weights = [1, 2]; // Start with 1 and 2, unlock others as player progresses
let probabilities = [0.5, 0.5]; // Equal chance for 1 and 2 initially

// Cookie-based save system
const SAVE_COOKIE_NAME = 'stackMerge_save';
const SAVE_COOKIE_EXPIRY_DAYS = 30;
const MAX_COOKIE_SIZE = 3500; // Conservative limit to avoid issues

// Fallback to localStorage if cookies fail
let useLocalStorage = false;

// Save game state to cookies or localStorage
function saveGameState() {
  try {
    console.log('=== SAVING GAME STATE ===');
    console.log('Current game state:', {
      poles: poles,
      score: score,
      gold: gold,
      blocksDropped: blocksDropped,
      currentTargetBlockSize: currentTargetBlockSize,
      currentStage: currentStage,
      weights: weights,
      probabilities: probabilities,
      nextQueue: nextQueue,
      bombConversionCost: bombConversionCost,
      trashButtonCost: trashButtonCost,
      bombConversionPresses: bombConversionPresses,
      trashButtonPresses: trashButtonPresses,
      bombSelected: bombSelected,
      previousBombCost: previousBombCost,
      currentActiveDecayFactor: currentActiveDecayFactor
    });
    console.log('🔊 Sound settings being saved:', {
      usePopMergeSounds: soundManager.getMergeSoundType(),
      soundVolumes: soundManager.getAllSoundVolumes(),
      isMuted: soundManager.getMuteState()
    });
    console.log('💾 Saving button costs - Bomb:', bombConversionCost, 'Trash:', trashButtonCost);
    console.log('💾 Saving bomb state - Selected:', bombSelected, 'Previous Cost:', previousBombCost);
    
    const gameState = {
      poles: poles,
      score: score,
      gold: gold,
      blocksDropped: blocksDropped,
      currentTargetBlockSize: currentTargetBlockSize,
      currentStage: currentStage,
      weights: weights,
      probabilities: probabilities,
      nextQueue: nextQueue,
      bombConversionCost: bombConversionCost,
      trashButtonCost: trashButtonCost,
      bombConversionPresses: bombConversionPresses,
      trashButtonPresses: trashButtonPresses,
      bombSelected: bombSelected,
      previousBombCost: previousBombCost,
      usePopMergeSounds: soundManager.getMergeSoundType(),
      soundVolumes: soundManager.getAllSoundVolumes(),
      isMuted: soundManager.getMuteState(),
      currentActiveDecayFactor: currentActiveDecayFactor,
      timestamp: Date.now()
    };
    
    const saveData = JSON.stringify(gameState);
    console.log('Save data size:', saveData.length, 'characters');
    console.log('Save data preview:', saveData.substring(0, 200) + '...');
    
    if (useLocalStorage) {
      // Use localStorage fallback
      console.log('📱 Using localStorage fallback...');
      try {
        localStorage.setItem(SAVE_COOKIE_NAME, saveData);
        console.log('✅ Game state saved to localStorage');
      } catch (localStorageError) {
        console.error('❌ localStorage also failed:', localStorageError);
      }
      return;
    }
    
    const expiryDate = new Date();
    expiryDate.setDate(expiryDate.getDate() + SAVE_COOKIE_EXPIRY_DAYS);
    
    // Check if we need to split into multiple cookies
    if (saveData.length > MAX_COOKIE_SIZE) {
      console.log('📦 Save data is large, splitting into multiple cookies...');
      
      // Split the save data into chunks
      const chunks = [];
      for (let i = 0; i < saveData.length; i += MAX_COOKIE_SIZE) {
        chunks.push(saveData.substring(i, i + MAX_COOKIE_SIZE));
      }
      
      console.log(`Split into ${chunks.length} chunks of max ${MAX_COOKIE_SIZE} characters`);
      
      // Save chunk info in first cookie
      const chunkInfo = {
        totalChunks: chunks.length,
        timestamp: Date.now(),
        dataSize: saveData.length
      };
      
      const infoCookie = `${SAVE_COOKIE_NAME}_info=${encodeURIComponent(JSON.stringify(chunkInfo))}; expires=${expiryDate.toUTCString()}; path=/; SameSite=Lax`;
      document.cookie = infoCookie;
      console.log('Set chunk info cookie');
      
      // Save each chunk in separate cookies
      chunks.forEach((chunk, index) => {
        const chunkCookie = `${SAVE_COOKIE_NAME}_chunk_${index}=${encodeURIComponent(chunk)}; expires=${expiryDate.toUTCString()}; path=/; SameSite=Lax`;
        document.cookie = chunkCookie;
        console.log(`Set chunk ${index + 1}/${chunks.length}`);
      });
      
      console.log('✅ Large save data split into multiple cookies');
    } else {
      // Single cookie approach - try multiple cookie formats
      console.log('Setting single cookie:', SAVE_COOKIE_NAME);
      console.log('Cookie expiry:', expiryDate.toUTCString());
      
      // Try different cookie formats to see which one works
      const cookieFormats = [
        // Format 1: Basic cookie
        `${SAVE_COOKIE_NAME}=${encodeURIComponent(saveData)}; expires=${expiryDate.toUTCString()}; path=/`,
        // Format 2: With SameSite
        `${SAVE_COOKIE_NAME}=${encodeURIComponent(saveData)}; expires=${expiryDate.toUTCString()}; path=/; SameSite=Lax`,
        // Format 3: Without expires (session cookie)
        `${SAVE_COOKIE_NAME}=${encodeURIComponent(saveData)}; path=/`,
        // Format 4: Minimal format
        `${SAVE_COOKIE_NAME}=${encodeURIComponent(saveData)}`
      ];
      
      cookieFormats.forEach((format, index) => {
        console.log(`Trying cookie format ${index + 1}:`, format.substring(0, 100) + '...');
        document.cookie = format;
        
        // Check if this format worked
        setTimeout(() => {
          const testCookies = document.cookie.split(';');
          const testCookie = testCookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '='));
          if (testCookie) {
            console.log(`✅ Cookie format ${index + 1} worked!`);
          } else {
            console.log(`❌ Cookie format ${index + 1} failed`);
          }
        }, 50 * (index + 1));
      });
    }
    
    // Wait a moment for cookie to be set, then verify
    setTimeout(() => {
      const cookies = document.cookie.split(';');
      console.log('All cookies after setting:', cookies);
      
      // Check for both single cookie and chunked cookies
      const savedCookie = cookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '='));
      const infoCookie = cookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '_info='));
      
      if (savedCookie) {
        console.log('✅ Single cookie verified successfully');
        console.log('Cookie length:', savedCookie.length);
      } else if (infoCookie) {
        console.log('✅ Chunked cookies verified successfully');
        console.log('Info cookie found:', infoCookie);
        
        // Count chunk cookies
        const chunkCookies = cookies.filter(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '_chunk_'));
        console.log(`Found ${chunkCookies.length} chunk cookies`);
      } else {
        console.error('❌ Cookie verification failed - no save cookies found');
        console.log('Available cookies:', cookies.map(c => c.trim().split('=')[0]));
        
        // Try to read the cookie directly
        try {
          const testCookie = document.cookie;
          console.log('Raw document.cookie:', testCookie);
        } catch (e) {
          console.error('Error reading document.cookie:', e);
        }
        
        // If cookies failed, try localStorage
        console.log('🔄 Attempting localStorage fallback...');
        try {
          localStorage.setItem(SAVE_COOKIE_NAME, saveData);
          console.log('✅ Fallback to localStorage successful');
          useLocalStorage = true;
        } catch (localStorageError) {
          console.error('❌ localStorage also failed:', localStorageError);
        }
      }
    }, 100);
    
    console.log('=== SAVE COMPLETE ===');
  } catch (error) {
    console.error('❌ Failed to save game state:', error);
  }
}

// Restore game state from loaded data
function restoreGameState(gameState) {
  try {
    console.log('Validating loaded game state...');
    
    // Validate the loaded data
    if (!gameState.poles || !Array.isArray(gameState.poles) || gameState.poles.length !== 4) {
      console.error('❌ Invalid save data: poles structure corrupted');
      console.log('Poles:', gameState.poles);
      console.log('Poles type:', typeof gameState.poles);
      console.log('Poles is array:', Array.isArray(gameState.poles));
      console.log('Poles length:', gameState.poles ? gameState.poles.length : 'undefined');
      return false;
    }
    
    // Check if save is too old (more than 30 days)
    const saveAge = Date.now() - gameState.timestamp;
    const maxAge = SAVE_COOKIE_EXPIRY_DAYS * 24 * 60 * 60 * 1000;
    console.log('Save age:', saveAge, 'ms');
    console.log('Max age:', maxAge, 'ms');
    console.log('Save timestamp:', new Date(gameState.timestamp).toISOString());
    
    if (saveAge > maxAge) {
      console.log('❌ Save data is too old, starting fresh game');
      clearGameSave();
      return false;
    }
    
    console.log('✅ Save data validation passed, restoring game state...');
    
    // Restore game state
    const oldPoles = [...poles];
    const oldScore = score;
    const oldGold = gold;
    
    poles = gameState.poles;
    score = gameState.score || 0;
    gold = gameState.gold || 0;
    blocksDropped = gameState.blocksDropped || 0;
    currentTargetBlockSize = gameState.currentTargetBlockSize || STARTING_BLOCK_SIZE;
    currentStage = gameState.currentStage || 1;
    weights = gameState.weights || [1, 2];
    probabilities = gameState.probabilities || [0.5, 0.5];
    nextQueue = gameState.nextQueue || [getRandomPiece(), getRandomPiece(), getRandomPiece()];
    
    // Restore the current active decay factor
    currentActiveDecayFactor = gameState.currentActiveDecayFactor || PROBABILITY_DECAY_FACTOR;
    
    // Restore button costs from saved state
    const oldBombCost = bombConversionCost;
    const oldTrashCost = trashButtonCost;
    bombConversionCost = gameState.bombConversionCost || 25;
    trashButtonCost = gameState.trashButtonCost || 25;
    bombConversionPresses = gameState.bombConversionPresses || 0;
    trashButtonPresses = gameState.trashButtonPresses || 0;
    
    // Restore bomb selection state from saved state
    bombSelected = gameState.bombSelected || false;
    previousBombCost = gameState.previousBombCost || bombConversionCost;
    
    // Restore merge sound type preference from saved state
    if (gameState.usePopMergeSounds !== undefined) {
      // Set the merge sound type preference in the sound manager
      soundManager.usePopMergeSounds = gameState.usePopMergeSounds;
    }
    
    // Restore sound volumes from saved state
    if (gameState.soundVolumes && typeof gameState.soundVolumes === 'object') {
      soundManager.setAllSoundVolumes(gameState.soundVolumes);
    }
    
    // Restore master mute state from saved state
    if (gameState.isMuted !== undefined) {
      soundManager.isMuted = gameState.isMuted;
      console.log('🔇 Restored master mute state:', gameState.isMuted);
    }
    
    // Always update the merge sound button to reflect current state (including default)
    const mergeSoundBtn = document.getElementById('mergeSoundBtn');
    if (mergeSoundBtn) {
      const usePopSounds = soundManager.getMergeSoundType();
      mergeSoundBtn.textContent = '🎵'; // Always show music note
      mergeSoundBtn.title = usePopSounds ? 'Switch to musical merge sounds' : 'Switch to pop merge sounds';
    }
    
    // Update sound button to reflect restored mute state
    const soundBtn = document.getElementById('soundBtn');
    if (soundBtn) {
      const isMuted = soundManager.getMuteState();
      soundBtn.textContent = isMuted ? '🔇' : '🔊';
      soundBtn.title = 'Sound Controls';
    }
    
    console.log('🔄 Restored button costs - Bomb:', oldBombCost, '→', bombConversionCost, 'Trash:', oldTrashCost, '→', trashButtonCost);
    
    console.log('Game state restored:');
    console.log('- Poles changed from', oldPoles.length, 'to', poles.length);
    console.log('- Score changed from', oldScore, 'to', score);
    console.log('- Gold changed from', oldGold, 'to', gold);
    console.log('- Current stage:', currentStage);
    console.log('- Weights:', weights);
    console.log('- Next queue length:', nextQueue.length);
    console.log('- Bomb conversion cost:', bombConversionCost);
    console.log('- Current active decay factor:', currentActiveDecayFactor);
    console.log('- Trash button cost:', trashButtonCost);
    console.log('- Bomb selected:', bombSelected);
    console.log('- Previous bomb cost:', previousBombCost);
    console.log('🔊 Sound settings restored:', {
      usePopMergeSounds: soundManager.getMergeSoundType(),
      soundVolumes: soundManager.getAllSoundVolumes(),
      isMuted: soundManager.getMuteState()
    });
    
    // Update cost displays after restoring game state
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostEl) {
      trashCostEl.textContent = formatNumber(trashButtonCost);
    }
    if (bombCostElMobile) {
      bombCostElMobile.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostElMobile) {
      trashCostElMobile.textContent = formatNumber(trashButtonCost);
    }
    
    // Update button states to reflect restored bomb selection state
    updateBombConversionButtonState();
    
    console.log('=== LOAD COMPLETE ===');
    return true;
  } catch (error) {
    console.error('❌ Failed to restore game state:', error);
    return false;
  }
}



// Load game state from cookies or localStorage
function loadGameState() {
  try {
    console.log('=== LOADING GAME STATE ===');
    
    // Check localStorage first if we're using it
    if (useLocalStorage) {
      console.log('📱 Loading from localStorage...');
      try {
        const saveData = localStorage.getItem(SAVE_COOKIE_NAME);
        if (saveData) {
          console.log('✅ Found save data in localStorage');
          const gameState = JSON.parse(saveData);
          return restoreGameState(gameState);
        } else {
          console.log('❌ No save data found in localStorage');
          return false;
        }
      } catch (localStorageError) {
        console.error('❌ localStorage load failed:', localStorageError);
        return false;
      }
    }
    
    console.log('All cookies:', document.cookie);
    
    const cookies = document.cookie.split(';');
    console.log('Parsed cookies:', cookies);
    
    // Check for both single cookie and chunked cookies
    const saveCookie = cookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '='));
    const infoCookie = cookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '_info='));
    
    console.log('Looking for cookie starting with:', SAVE_COOKIE_NAME + '=');
    console.log('Found single save cookie:', saveCookie ? 'YES' : 'NO');
    console.log('Found chunked save cookies:', infoCookie ? 'YES' : 'NO');
    
    let saveData;
    
    if (saveCookie) {
      // Single cookie approach
      console.log('📦 Loading from single cookie...');
      console.log('Raw save cookie:', saveCookie);
      const cookieValue = saveCookie.split('=')[1];
      console.log('Cookie value (first 100 chars):', cookieValue ? cookieValue.substring(0, 100) + '...' : 'undefined');
      
      saveData = decodeURIComponent(cookieValue);
      console.log('Decoded save data (first 200 chars):', saveData.substring(0, 200) + '...');
      console.log('Save data length:', saveData.length);
    } else if (infoCookie) {
      // Chunked cookies approach
      console.log('📦 Loading from chunked cookies...');
      
      // Parse chunk info
      const infoValue = infoCookie.split('=')[1];
      const chunkInfo = JSON.parse(decodeURIComponent(infoValue));
      console.log('Chunk info:', chunkInfo);
      
      // Collect all chunks
      const chunks = [];
      for (let i = 0; i < chunkInfo.totalChunks; i++) {
        const chunkCookie = cookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '_chunk_' + i + '='));
        if (chunkCookie) {
          const chunkValue = chunkCookie.split('=')[1];
          chunks.push(decodeURIComponent(chunkValue));
          console.log(`Loaded chunk ${i + 1}/${chunkInfo.totalChunks}`);
        } else {
          console.error(`❌ Missing chunk ${i + 1}/${chunkInfo.totalChunks}`);
          return false;
        }
      }
      
      // Reconstruct save data
      saveData = chunks.join('');
      console.log('Reconstructed save data length:', saveData.length);
      console.log('Save data preview:', saveData.substring(0, 200) + '...');
    } else {
      console.log('❌ No saved game found in cookies - starting fresh');
      return false;
    }
    
    const gameState = JSON.parse(saveData);
    console.log('Parsed game state:', gameState);
    
    return restoreGameState(gameState);
  } catch (error) {
    console.error('❌ Failed to load game state:', error);
    console.error('Error details:', error.message);
    console.error('Error stack:', error.stack);
    clearGameSave();
    return false;
  }
}

// Clear saved game data
function clearGameSave() {
  try {
    console.log('=== CLEARING GAME SAVE ===');
    
    // Clear all possible save cookies
    const cookiesToClear = [
      SAVE_COOKIE_NAME,
      SAVE_COOKIE_NAME + '_info'
    ];
    
    // Clear chunk cookies (up to 10 chunks)
    for (let i = 0; i < 10; i++) {
      cookiesToClear.push(SAVE_COOKIE_NAME + '_chunk_' + i);
    }
    
    console.log('Clearing cookies:', cookiesToClear);
    
    cookiesToClear.forEach(cookieName => {
      document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
    });
    
    // Verify cookies were removed
    const remainingCookies = document.cookie.split(';');
    const remainingSaveCookies = remainingCookies.filter(cookie => 
      cookie.trim().startsWith(SAVE_COOKIE_NAME + '=')
    );
    
    if (remainingSaveCookies.length === 0) {
      console.log('✅ All save cookies successfully removed');
    } else {
      console.error('❌ Some save cookies still exist:', remainingSaveCookies);
    }
    
    // Also clear localStorage if we're using it
    if (useLocalStorage) {
      try {
        localStorage.removeItem(SAVE_COOKIE_NAME);
        console.log('✅ localStorage save data cleared');
      } catch (e) {
        console.error('❌ Failed to clear localStorage:', e);
      }
    }
    
    console.log('=== CLEAR COMPLETE ===');
  } catch (error) {
    console.error('❌ Failed to clear game save:', error);
  }
}

// Auto-save game state periodically and on important events
function setupAutoSave() {
  // Test cookie functionality first
  console.log('=== TESTING COOKIE FUNCTIONALITY ===');
  console.log('Current URL protocol:', window.location.protocol);
  console.log('Current URL:', window.location.href);
  console.log('Document cookie before test:', document.cookie);
  
  // Try to set a simple test cookie
  document.cookie = 'test_cookie=hello';
  console.log('Document cookie after setting test:', document.cookie);
  
  // Check if test cookie was set
  const testCookie = document.cookie.includes('test_cookie');
  console.log('Test cookie set successfully:', testCookie ? 'YES' : 'NO');
  
  if (!testCookie) {
    console.error('❌ COOKIES ARE NOT WORKING - browser may be blocking them');
    console.log('This could be due to:');
    console.log('- Browser privacy settings');
    console.log('- Incognito/private browsing mode');
    console.log('- Browser extensions blocking cookies');
    console.log('- HTTPS/HTTP mismatch');
    console.log('- SameSite policy restrictions');
    
    // Check if it's a local file issue
    if (window.location.protocol === 'file:') {
      console.log('🚨 DETECTED LOCAL FILE PROTOCOL - Cookies are blocked by browser security');
      console.log('This is expected behavior for file:// URLs');
      console.log('Solutions:');
      console.log('1. Use a local web server (http://localhost)');
      console.log('2. Use localStorage fallback (automatic)');
      console.log('3. Deploy to a web server');
      console.log('');
      console.log('💡 QUICK LOCAL SERVER SETUP:');
      console.log('If you have Python installed:');
      console.log('  python -m http.server 8000');
      console.log('Then visit: http://localhost:8000');
      console.log('');
      console.log('If you have Node.js installed:');
      console.log('  npx http-server');
      console.log('Then visit: http://localhost:8080');
    }
    
    // Automatically switch to localStorage
    console.log('🔄 Automatically switching to localStorage fallback...');
    useLocalStorage = true;
    
    // Test localStorage functionality
    try {
      localStorage.setItem('test_storage', 'hello');
      const testValue = localStorage.getItem('test_storage');
      if (testValue === 'hello') {
        console.log('✅ localStorage working correctly');
        localStorage.removeItem('test_storage');
      } else {
        console.error('❌ localStorage test failed');
      }
    } catch (e) {
      console.error('❌ localStorage not available:', e);
    }
  } else {
    console.log('✅ Basic cookie functionality working');
    
    // Clean up test cookie
    document.cookie = 'test_cookie=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
    console.log('Test cookie cleaned up');
  }
  
  // Auto-save every 30 seconds during gameplay
  setInterval(() => {
    if (score > 0 || gold > 0) { // Only save if there's actual progress
      console.log(`🔄 Auto-save interval triggered (using ${useLocalStorage ? 'localStorage' : 'cookies'})...`);
      saveGameState();
    }
  }, 30000);
  
  // Save on page unload/visibility change
  window.addEventListener('beforeunload', () => {
    console.log('🔄 Page unloading - saving game state...');
    saveGameState();
  });
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      console.log('🔄 Page hidden - saving game state...');
      saveGameState();
    } else {
      console.log('🔄 Page visible - checking audio context state...');
      // Proactively resume audio context when page becomes visible
      if (soundManager.audioContext && soundManager.audioContext.state === 'suspended') {
        soundManager.audioContext.resume().catch(error => {
          console.warn('⚠️ Failed to resume audio context on page visibility change:', error);
        });
      }
    }
  });
  
  // Add page focus/blur handlers for better audio context management
  window.addEventListener('focus', () => {
    console.log('🔄 Window focused - checking audio context state...');
    // Resume audio context when window gains focus
    if (soundManager.audioContext && soundManager.audioContext.state === 'suspended') {
      soundManager.audioContext.resume().catch(error => {
        console.warn('⚠️ Failed to resume audio context on window focus:', error);
      });
    }
  });
  
  window.addEventListener('blur', () => {
    console.log('🔄 Window blurred - audio context may be suspended...');
    // Note: We don't suspend here as browsers handle this automatically
    // But we can log it for debugging
  });
}

// Number formatting utility function
function formatNumber(num) {
  if (num < 1000) {
    return num.toString();
  } else if (num < 1000000) {
    return (num / 1000).toFixed(1) + 'k';
  } else if (num < 1000000000) {
    return (num / 1000000).toFixed(1) + 'm';
  } else if (num < 1000000000000) {
    return (num / 1000000000).toFixed(1) + 'b';
  } else if (num < 1000000000000000) {
    return (num / 1000000000000).toFixed(1) + 't';
  } else if (num < 1000000000000000000) {
    return (num / 1000000000000000).toFixed(1) + 'q';
  } else {
    return (num / 1000000000000000000).toFixed(1) + 'Q';
  }
}

// Multiplier formatting utility function
function formatMultiplier(num) {
  if (num < 100000) {
    return num.toString() + ' x';
  } else {
    // Use scientific notation for 100,000 and above without + sign
    const exp = Math.floor(Math.log10(num));
    const mantissa = (num / Math.pow(10, exp)).toFixed(1);
    return mantissa + 'e' + exp + ' x';
  }
}

// Centralized display update functions
function updateScoreDisplay() {
  const scoreDisplay = document.querySelector('.score-value');
  if (scoreDisplay) {
    scoreDisplay.innerHTML = `<div class="score-star">⭐</div><div class="score-text">${score}</div>`;
  }
  // Update debug score display with exact value
  if (debugScore) {
    debugScore.textContent = score;
  }
  
  // Auto-save when score changes
  if (score > 0) {
    saveGameState();
  }
}

function updateGoldDisplay() {
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
    const oldMultiplier = goldDisplay.querySelector('.stage-multiplier-badge')?.textContent;
    const newMultiplier = formatMultiplier(stageMultiplier);
    
    // Only show badge for stage 2 and higher
    const badgeHTML = currentStage >= 2 ? `<div class="stage-multiplier-badge" id="stageMultiplierBadge">${newMultiplier}</div>` : '';
    
    goldDisplay.innerHTML = `
      <div class="gold-emoji">💰</div>
      <div class="gold-text">${formatNumber(gold)}</div>
      ${badgeHTML}
    `;
    
    // Add pulse animation for stage progression if multiplier changed and badge exists
    if (oldMultiplier && oldMultiplier !== newMultiplier && currentStage >= 2) {
      const badge = goldDisplay.querySelector('.stage-multiplier-badge');
      if (badge) {
        badge.classList.add('pulse');
        setTimeout(() => {
          badge.classList.remove('pulse');
        }, 600);
      }
    }
  }
  
  // Update debug gold display with exact value
  if (debugGold) {
    debugGold.textContent = gold;
  }
  
  // Auto-save when gold changes
  if (gold > 0) {
    saveGameState();
  }
}
const MAX_HEIGHT = 10;
const BOMB_CHANCE = 0.01; // 1% chance for bombs
const BOMB_DELAY_BLOCKS = 50; // No bombs for first 50 blocks
const STARTING_BLOCK_SIZE = 512; // Starting block size to merge for new stacks
const PROBABILITY_DECAY_FACTOR = 0.7; // Each block is 70% as likely as the previous one
// 
// PROBABILITY SYSTEM EXPLANATION:
// 
// The game uses a hybrid probability system:
// 
// FOUNDATION BLOCKS (equal probability):
// - Block 1: 100% base probability
// - Block 2: 100% base probability  
// - Block 4: 100% base probability
//
// DECAY BLOCKS (exponential decay):
// - Block 8: 60% base probability (0.6^1)
// - Block 16: 36% base probability (0.6^2)
// - Block 32: 21.6% base probability (0.6^3)
// - Block 64: 12.96% base probability (0.6^4)
// - And so on...
//
// These base probabilities are then normalized to sum to 100%.
// This creates a stable early game foundation while maintaining
// exponential rarity for higher-tier blocks.

// Initialize the current active decay factor
let currentActiveDecayFactor = PROBABILITY_DECAY_FACTOR;

function getRandomWeight(){
  // Validate probabilities before selecting
  if (!validateProbabilityDistribution()) {
    console.error('Probability validation failed, using uniform distribution');
    const randomIndex = Math.floor(Math.random() * weights.length);
    return weights[randomIndex];
  }
  
  let r = Math.random();
  let cum = 0;
  
  for(let i=0;i<probabilities.length;i++){
    cum += probabilities[i];
    if (r < cum) {
      console.log(`Random weight selected: ${weights[i]} (probability: ${probabilities[i].toFixed(4)}, cumulative: ${cum.toFixed(4)})`);
      return weights[i];
    }
  }
  
  // Fallback - this should rarely happen if probabilities are correct
  console.warn(`Random weight fallback: ${weights[probabilities.length-1]} (cumulative sum: ${cum.toFixed(6)})`);
  return weights[probabilities.length-1];
}

function getRandomPiece(){
  // Prevent bombs from spawning for the first 50 blocks
  const canSpawnBomb = blocksDropped >= BOMB_DELAY_BLOCKS;
  const bombChance = canSpawnBomb ? BOMB_CHANCE : 0;
  
  return { w: getRandomWeight(), bomb: Math.random() < bombChance };
}

let poles = [[],[],[],[]];
let score = 0;
let gold = 0; // Track accumulated gold
let blocksDropped = 0; // Track total blocks dropped for bomb delay
let placing = false; // block multiple rapid placements while animating
let lastPlacementTime = 0; // track when placement started for timeout safety
let currentTargetBlockSize = STARTING_BLOCK_SIZE; // Current block size needed to unlock new stack
let currentStackCapacity = MAX_HEIGHT; // Current maximum height for each stack (no longer reduced per stage)
let currentStage = 1; // Current stage (1 = starting, 2 = after first stack unlock, etc.)

// Bomb conversion button state
let bombConversionCost = 25;
let bombConversionPresses = 0; // Number of times button has been pressed
let lastGoldAmount = 0; // Track last gold amount to prevent unnecessary updates
let bombSelected = false; // Track if a bomb is currently selected but not yet placed
let previousBombCost = 25; // Store the previous bomb cost before conversion

// Trash button state
let trashButtonCost = 25;
let trashButtonPresses = 0; // Number of times button has been pressed

// Initialize next queue (probabilities will be set up after functions are defined)
let nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];

// Emergency reset keyboard shortcut (Ctrl+R) - will be set up after gameDiv is defined



function checkForNewStack() {
  // Stage progression without adding new stacks
  // IMPORTANT: This function should NEVER modify the poles array
  // Poles should remain at exactly 4 permanently
  
  // Safety check: ensure we still have exactly 4 poles
  if (poles.length !== 4) {
    console.error(`CRITICAL ERROR: checkForNewStack found ${poles.length} poles instead of 4! Resetting to 4 poles.`);
    poles = [[],[],[],[]];
  }
  
  // Increment stage counter for gold multiplier
  currentStage++;
  // Double the target block size for the next unlock
  currentTargetBlockSize *= 2;
  // Don't call updateBlockRange() here - let the merge system handle block unlocking
  const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
  console.log(`Advanced to Stage ${currentStage}! Gold earnings now multiplied by ${stageMultiplier}x`);
  console.log(`Poles count remains at ${poles.length} (should always be 4)`);
  console.log(`New target block size: ${currentTargetBlockSize} (need to merge to ${currentTargetBlockSize * 2} for next stage)`);
  
  // Save game state after stage progression
  console.log('🔄 Triggering save after stage progression...');
  saveGameState();
}

function checkForNewBlockSize(mergedSize) {
  // Check if this merge unlocks a new block size for future drops
  // The merged size should be available as a droppable piece
  if (!weights.includes(mergedSize)) {
    weights.push(mergedSize);
    
    // Check if this was a stage-triggering block
    if (mergedSize === currentTargetBlockSize * 2) {
      // This was a stage progression block
      console.log(`Stage progression block ${mergedSize} added to droppable pieces`);
    } else {
      // This was a regular merge unlock
      console.log(`Regular block size ${mergedSize} unlocked`);
    }
    
    // Implement a better probability distribution system
    // Lower tier blocks should remain more common, higher tiers progressively rarer
    updateProbabilityDistribution();
    
    console.log(`New block size unlocked: ${mergedSize}`);
    
    // Save game state after unlocking new block size
    console.log('🔄 Triggering save after unlocking new block size...');
    saveGameState();
  }
}

function updateProbabilityDistribution() {
  try {
    console.log('🔄 updateProbabilityDistribution called with decay factor:', currentActiveDecayFactor);
    // Call the custom version with the current active decay factor
    updateProbabilityDistributionCustom(currentActiveDecayFactor);
    console.log('✅ updateProbabilityDistribution completed successfully');
  } catch (error) {
    console.error('❌ Error in updateProbabilityDistribution:', error);
    console.error('Error stack:', error.stack);
    throw error; // Re-throw to be caught by the caller
  }
}

function updateProbabilityDistributionCustom(decayFactor) {
  try {
    console.log('🔄 updateProbabilityDistributionCustom called with decay factor:', decayFactor);
    
    // Create a hybrid probability system with foundation blocks and exponential decay
    // Foundation blocks (1, 2, 4) get equal probabilities for stable early game
    // Higher blocks (8+) follow an exponential decay curve for progression
    
    const numBlocks = weights.length;
    console.log('📊 Number of blocks available:', numBlocks);
    console.log('📊 Current weights:', weights);
    
    if (numBlocks === 0) {
      console.warn('No blocks available for probability distribution');
      return;
    }
    
    // Sort weights to ensure they're in ascending order for proper curve calculation
    const sortedWeights = [...weights].sort((a, b) => a - b);
    const sortedIndices = sortedWeights.map(w => weights.indexOf(w));
    
    // Calculate base probabilities using exponential decay
    const baseProbabilities = [];
    
    for (let i = 0; i < numBlocks; i++) {
      const blockSize = sortedWeights[i];
      
      if (i < 3) {
        // First three blocks (1, 2, 4) get equal, high probabilities
        // This creates a stable foundation for the early game
        baseProbabilities.push(1.0);
      } else {
        // Starting from block 8 (index 3), apply exponential decay
        // Each subsequent block is progressively rarer
        const decayPosition = i - 2; // Start decay from position 1 (after the foundation blocks)
        const baseProbability = Math.pow(decayFactor, decayPosition);
        baseProbabilities.push(baseProbability);
      }
    }
    
    // Normalize probabilities to sum to 1.0
    const totalProbability = baseProbabilities.reduce((sum, p) => sum + p, 0);
    
    if (totalProbability === 0) {
      console.error('Total probability is 0, using uniform distribution');
      probabilities = new Array(numBlocks).fill(1.0 / numBlocks);
    } else {
      // Map the normalized probabilities back to the original weights order
      const normalizedProbs = baseProbabilities.map(p => p / totalProbability);
      probabilities = new Array(numBlocks);
      
      // Place probabilities back in original order
      sortedIndices.forEach((originalIndex, sortedIndex) => {
        probabilities[originalIndex] = normalizedProbs[sortedIndex];
      });
    }
    
    // Verify probabilities sum to 1.0 (with small floating point tolerance)
    const actualSum = probabilities.reduce((sum, p) => sum + p, 0);
    if (Math.abs(actualSum - 1.0) > 0.0001) {
      console.warn(`Probability sum is ${actualSum.toFixed(6)}, expected 1.0. Normalizing...`);
      // Force normalization
      const correctedSum = probabilities.reduce((sum, p) => sum + p, 0);
      probabilities = probabilities.map(p => p / correctedSum);
    }
    
    // Final validation
    validateProbabilityDistribution();
    
    // Log the current state for debugging
    logProbabilityState();
    
    // Update the debug display
    updateDebugProbabilitiesDisplay();
    
    console.log('Updated probability distribution:', weights.map((w, i) => `${w}: ${probabilities[i].toFixed(4)}`).join(', '));
    console.log('Probability sum:', probabilities.reduce((sum, p) => sum + p, 0).toFixed(6));
    console.log('Current weights array:', weights);
    console.log('Decay factor used:', decayFactor);
    
    // Log the foundation vs decay blocks for clarity
    if (weights.length >= 3) {
      console.log('Foundation blocks (equal prob):', weights.slice(0, 3).join(', '));
      if (weights.length > 3) {
        console.log('Decay blocks (exponential):', weights.slice(3).join(', '));
      }
    }
    
    console.log('✅ updateProbabilityDistributionCustom completed successfully');
  } catch (error) {
    console.error('❌ Error in updateProbabilityDistributionCustom:', error);
    console.error('Error stack:', error.stack);
    throw error; // Re-throw to be caught by the caller
  }
}

function validateProbabilityDistribution() {
  // Validate that probabilities are mathematically correct
  if (!probabilities || probabilities.length === 0) {
    console.error('Probabilities array is empty or undefined');
    return false;
  }
  
  if (probabilities.length !== weights.length) {
    console.error(`Mismatch: ${probabilities.length} probabilities vs ${weights.length} weights`);
    return false;
  }
  
  // Check for negative probabilities
  const negativeProbs = probabilities.filter(p => p < 0);
  if (negativeProbs.length > 0) {
    console.error('Found negative probabilities:', negativeProbs);
    return false;
  }
  
  // Check that probabilities sum to 1.0 (with tolerance for floating point errors)
  const sum = probabilities.reduce((s, p) => s + p, 0);
  if (Math.abs(sum - 1.0) > 0.0001) {
    console.error(`Probabilities sum to ${sum.toFixed(6)}, expected 1.0`);
    return false;
  }
  
  // Check that all probabilities are finite numbers
  const invalidProbs = probabilities.filter(p => !isFinite(p));
  if (invalidProbs.length > 0) {
    console.error('Found invalid probabilities:', invalidProbs);
    return false;
  }
  
  console.log('Probability distribution validation passed ✓');
  return true;
}

// updateBlockRange function removed - block unlocking now handled entirely by checkForNewBlockSize





function showGoldEarned(amount) {
  // Create the gold earned display element
  const goldEl = document.createElement('div');
  goldEl.className = 'gold-earned';
  
  // Debug: Check if formatNumber is available and working
  console.log('showGoldEarned called with amount:', amount);
  console.log('formatNumber function available:', typeof formatNumber);
  if (typeof formatNumber === 'function') {
    console.log('Formatted amount:', formatNumber(amount));
  }
  
  goldEl.textContent = `+${formatNumber(amount)}`;
  
  // Position it closer to the top right corner of the gold display
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    const rect = goldDisplay.getBoundingClientRect();
    goldEl.style.left = (rect.right + 2) + 'px';
    goldEl.style.top = (rect.top + 5) + 'px';
  } else {
    // Fallback positioning if gold display not found
    goldEl.style.left = '50%';
    goldEl.style.top = '50%';
    goldEl.style.transform = 'translate(-50%, -50%)';
  }
  
  document.body.appendChild(goldEl);
  
  // Add pulse animation to the gold count
  if (goldDisplay) {
    goldDisplay.classList.add('pulse');
    setTimeout(() => {
      goldDisplay.classList.remove('pulse');
    }, 300);
  }
  
  // Remove after animation completes
  setTimeout(() => {
    if (goldEl.parentNode) {
      goldEl.parentNode.removeChild(goldEl);
    }
  }, 1200);
}

function handleBombConversion() {
  // Check if there's a next block to work with
  if (nextQueue.length === 0) {
    return;
  }
  
  const currentBlock = nextQueue[0];
  
  // If a bomb is already selected, allow undoing the selection
  if (bombSelected && currentBlock.bomb) {
    // Undo bomb selection
    currentBlock.bomb = false;
    // Note: No gold to refund since payment hasn't been made yet
    bombConversionCost = previousBombCost; // Restore previous cost
    bombSelected = false;
    
    console.log(`Undid bomb selection, restored cost to ${previousBombCost}`);
    
    // No need to update gold display since no gold was deducted
    
    // Re-render to show the regular block
    renderNext();
    
    // Update button cost display
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (bombCostElMobile) {
      bombCostElMobile.textContent = formatNumber(bombConversionCost);
    }
    
    // Update button state and appearance
    updateBombConversionButtonState();
    
    // Save game state after undoing bomb selection
    console.log('🔄 Triggering save after undoing bomb selection...');
    saveGameState();
    return;
  }
  
  // Check if the next block is already a bomb (either natural or from previous conversion)
  if (currentBlock.bomb) {
    // Show feedback that the block is already a bomb
    bombConversionBtn.classList.add('pulse');
    setTimeout(() => bombConversionBtn.classList.remove('pulse'), 300);
    if (bombConversionBtnMobile) {
      bombConversionBtnMobile.classList.add('pulse');
      setTimeout(() => bombConversionBtnMobile.classList.remove('pulse'), 300);
    }
    return;
  }
  
  // Check if player has enough gold for new bomb conversion
  if (gold < bombConversionCost) {
    // Show feedback that they don't have enough gold
    bombConversionBtn.classList.add('pulse');
    setTimeout(() => bombConversionBtn.classList.remove('pulse'), 300);
    if (bombConversionBtnMobile) {
      bombConversionBtnMobile.classList.add('pulse');
      setTimeout(() => bombConversionBtnMobile.classList.remove('pulse'), 300);
    }
    return;
  }
  
  // Store the current cost before converting
  previousBombCost = bombConversionCost;
  
  // Convert the current next block to a bomb (don't deduct gold yet)
  // Gold will be deducted when the bomb block is actually placed
  if (currentBlock) {
    currentBlock.bomb = true;
    bombSelected = true; // Mark that a bomb is selected
    console.log(`Converted block ${currentBlock.w} to bomb for ${bombConversionCost} gold`);
    
    // Update gold display
    updateGoldDisplay();
    const goldDisplay = document.querySelector('.gold-value');
    if (goldDisplay) {
      goldDisplay.classList.add('pulse');
      setTimeout(() => {
        goldDisplay.classList.remove('pulse');
      }, 300);
    }
    
    // Re-render to show the bomb
    renderNext();
    
    // Also re-render the main game to ensure pole placement logic is updated
    // This ensures that if bomb status affects any placement decisions, they're properly reflected
    render();
    
    // Note: Cost will increase when the bomb block is actually placed, not when selected
    // Update button state
    updateBombConversionButtonState();
    
    // Save game state after bomb conversion and cost increase
    console.log('🔄 Triggering save after bomb conversion and cost increase...');
    saveGameState();
  }
}

function handleTrashButton() {
  // Check if player has enough gold
  if (gold < trashButtonCost) {
    // Show feedback that they don't have enough gold
    trashButton.classList.add('pulse');
    setTimeout(() => trashButton.classList.remove('pulse'), 300);
    if (trashButtonMobile) {
      trashButtonMobile.classList.add('pulse');
      setTimeout(() => trashButtonMobile.classList.remove('pulse'), 300);
    }
    return;
  }
  
  // Check if there's a next block to remove
  if (nextQueue.length === 0) {
    return;
  }
  
  // Deduct gold
  gold -= trashButtonCost;
  
  // Play purchase sound for the trash button usage
  soundManager.playPurchaseSound();
  
  // Remove the current next block from the queue
  const removedBlock = nextQueue.shift();
  console.log(`Removed block ${removedBlock.w} from queue for ${trashButtonCost} gold`);
  
  // Add a new random block to the end of the queue to maintain 3 blocks
  nextQueue.push(getRandomPiece());
  
  // Update gold display
  updateGoldDisplay();
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    goldDisplay.classList.add('pulse');
    setTimeout(() => {
      goldDisplay.classList.remove('pulse');
    }, 300);
  }
  
  // Play the same animation as placing a block, but don't place it
  animateNextQueueAdvance(true).then(() => {
    // After the queue animation completes, re-render to update pole placement logic
    // This ensures that the new next block can be properly evaluated for placement
    render();
  }); // true = queue already modified
  
  // Increment press count and double the cost
  trashButtonCost *= 2;
  
  // Update button cost display
  const trashCostEl = document.getElementById('trashCost');
  if (trashCostEl) {
    trashCostEl.textContent = formatNumber(trashButtonCost);
  }
  if (trashCostElMobile) {
    trashCostElMobile.textContent = formatNumber(trashButtonCost);
  }
  
  // Update button state (cost changed, so force update)
  updateTrashButtonState();
  
  // Save game state after using trash button and cost increase
  console.log('🔄 Triggering save after using trash button and cost increase...');
  saveGameState();
}

function updateBombConversionButtonState() {
  // Always update when called since we call this strategically
  if (bombConversionBtn) {
    // If a bomb is selected, the button should always be enabled for undo
    if (bombSelected) {
      bombConversionBtn.disabled = false;
      bombConversionBtn.classList.remove('affordable');
      bombConversionBtn.classList.add('undo-mode');
      bombConversionBtn.title = "Press again to undo bomb selection";
              bombConversionBtn.querySelector('.powerup-emoji').textContent = "↩️";
    } else {
      // Check if the next block is already a bomb (either natural or from previous conversion)
      const nextBlockIsBomb = nextQueue.length > 0 && nextQueue[0].bomb;
      
      if (nextBlockIsBomb) {
        // Next block is already a bomb, disable the button
        bombConversionBtn.disabled = true;
        bombConversionBtn.classList.remove('affordable');
        bombConversionBtn.classList.remove('undo-mode');
        bombConversionBtn.title = "Next block is already a bomb";
        bombConversionBtn.querySelector('.powerup-emoji').textContent = "💣";
      } else {
        // Next block is not a bomb, check if player has enough gold
        const hasEnoughGold = gold >= bombConversionCost;
        bombConversionBtn.disabled = !hasEnoughGold;
        
        // Update visual styling based on affordability
        // Red border (default): when gold < cost (disabled)
        // White border (affordable): when gold >= cost (enabled)
        if (hasEnoughGold) {
          bombConversionBtn.classList.add('affordable');
        } else {
          bombConversionBtn.classList.remove('affordable');
        }
        bombConversionBtn.classList.remove('undo-mode');
        bombConversionBtn.title = "Convert next block to bomb (press again to undo)";
        bombConversionBtn.querySelector('.powerup-emoji').textContent = "💣";
      }
    }
    
    // Update the tracked gold amount
    lastGoldAmount = gold;
  }
  
  // Also update mobile button if it exists
  if (bombConversionBtnMobile) {
    // If a bomb is selected, the button should always be enabled for undo
    if (bombSelected) {
      bombConversionBtnMobile.disabled = false;
      bombConversionBtnMobile.classList.remove('affordable');
      bombConversionBtnMobile.classList.add('undo-mode');
      bombConversionBtnMobile.title = "Press again to undo bomb selection";
              bombConversionBtnMobile.querySelector('.powerup-emoji').textContent = "↩️";
    } else {
      // Check if the next block is already a bomb (either natural or from previous conversion)
      const nextBlockIsBomb = nextQueue.length > 0 && nextQueue[0].bomb;
      
      if (nextBlockIsBomb) {
        // Next block is already a bomb, disable the button
        bombConversionBtnMobile.disabled = true;
        bombConversionBtnMobile.classList.remove('affordable');
        bombConversionBtnMobile.classList.remove('undo-mode');
        bombConversionBtnMobile.title = "Next block is already a bomb";
        bombConversionBtnMobile.querySelector('.powerup-emoji').textContent = "💣";
      } else {
        // Next block is not a bomb, check if player has enough gold
        const hasEnoughGold = gold >= bombConversionCost;
        bombConversionBtnMobile.disabled = !hasEnoughGold;
        
        if (hasEnoughGold) {
          bombConversionBtnMobile.classList.add('affordable');
        } else {
          bombConversionBtnMobile.classList.remove('affordable');
        }
        bombConversionBtnMobile.classList.remove('undo-mode');
        bombConversionBtnMobile.title = "Convert next block to bomb (press again to undo)";
        bombConversionBtnMobile.querySelector('.powerup-emoji').textContent = "💣";
      }
    }
  }
}

function updateTrashButtonState() {
  // Always update when called since we call this strategically
  console.log(`updateTrashButtonState called - gold: ${gold}, trashButtonCost: ${trashButtonCost}, lastGoldAmount: ${lastGoldAmount}`);
  console.log(`trashButton element:`, trashButton);
  if (trashButton) {
    const hasEnoughGold = gold >= trashButtonCost;
    console.log(`Trash button - hasEnoughGold: ${hasEnoughGold}, will disable: ${!hasEnoughGold}`);
    trashButton.disabled = !hasEnoughGold;
    
    // Update visual styling based on affordability
    // Red border (default): when gold < cost (disabled)
    // White border (affordable): when gold >= cost (enabled)
    if (hasEnoughGold) {
      trashButton.classList.add('affordable');
      console.log('Trash button: Added affordable class');
    } else {
      trashButton.classList.remove('affordable');
      console.log('Trash button: Removed affordable class');
    }
    
    // Update the tracked gold amount
    lastGoldAmount = gold;
    console.log(`Updated lastGoldAmount to: ${lastGoldAmount}`);
  } else {
    console.log('Trash button element not found');
  }
  
  // Also update mobile button if it exists
  if (trashButtonMobile) {
    const hasEnoughGold = gold >= trashButtonCost;
    trashButtonMobile.disabled = !hasEnoughGold;
    
    if (hasEnoughGold) {
      trashButtonMobile.classList.add('affordable');
    } else {
      trashButtonMobile.classList.remove('affordable');
    }
  }
}

// More targeted update function for when we know gold has changed
// Use this instead of updateBombConversionButtonState() when gold changes during gameplay
function updateBombButtonIfGoldChanged() {
  updateBombConversionButtonState();
}

// More targeted update function for trash button when we know gold has changed
function updateTrashButtonIfGoldChanged() {
  console.log(`updateTrashButtonIfGoldChanged called - gold: ${gold}, lastGoldAmount: ${lastGoldAmount}`);
  updateTrashButtonState();
}

// AI state
let aiEnabled = false;
let aiInterval = null;
const AI_DELAY_MS = 500;

// Speed control state
let currentSpeed = 2; // 0-4, default 2 (Medium): 0=Very Slow, 1=Slow, 2=Medium, 3=Fast, 4=Blazing

// Debug pane state
let debugPane = null;
let debugClose = null;
let bombToggle = null;
let bombStatus = null;
let debugScore = null;
let debugGold = null;
let debugStacks = null;
let debugCapacity = null;
let debugTarget = null;
let debugMaxBlock = null;
let debugBlocksDropped = null;
let debugBombStatus = null;
let debugStage = null;
let debugAiToggle = null;
let debugSpeedSlider = null;
let debugSpeedLabel = null;
let customBlockMode = false;
let customBlockSize = null;
let customBlockBomb = false;

// DOM refs
const gameDiv = document.getElementById('game');
const nextContainer = document.getElementById('nextContainer');
const scoreEl = document.getElementById('scoreDisplay');
const goldEl = document.getElementById('goldDisplay');

const helpBtn = document.getElementById('helpBtn');
const helpModal = document.getElementById('helpModal');
const helpClose = document.getElementById('helpClose');

// Bomb conversion button DOM refs
const bombConversionBtn = document.getElementById('bombConversionBtn');
const bombCostEl = document.getElementById('bombCost');

// Trash button DOM refs
const trashButton = document.getElementById('trashButton');
const trashCostEl = document.getElementById('trashCost');

// Mobile button DOM refs
const bombConversionBtnMobile = document.getElementById('bombConversionBtnMobile');
const bombCostElMobile = document.getElementById('bombCostMobile');
const trashButtonMobile = document.getElementById('trashButtonMobile');
const trashCostElMobile = document.getElementById('trashCostMobile');

// Debug pane DOM refs
debugPane = document.getElementById('debugPane');
debugClose = document.getElementById('debugClose');
bombToggle = document.getElementById('bombToggle');
bombStatus = document.getElementById('bombStatus');
debugScore = document.getElementById('debugScore');
debugGold = document.getElementById('debugGold');
debugStacks = document.getElementById('debugStacks');
debugCapacity = document.getElementById('debugCapacity');
debugTarget = document.getElementById('debugTarget');
debugMaxBlock = document.getElementById('debugMaxBlock');
debugBlocksDropped = document.getElementById('debugBlocksDropped');
debugBombStatus = document.getElementById('debugBombStatus');
debugStage = document.getElementById('debugStage');
const grantGoldBtn = document.getElementById('grantGoldBtn');
const grantScoreBtn = document.getElementById('grantScoreBtn');

// Debug auto-play DOM refs
debugAiToggle = document.getElementById('debugAiToggle');
debugSpeedSlider = document.getElementById('debugSpeedSlider');
debugSpeedLabel = document.getElementById('debugSpeedLabel');

// Emergency reset keyboard shortcut (Ctrl+R)
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 'r') {
    e.preventDefault();
    console.log('Emergency reset triggered via Ctrl+R');
    placing = false; // Force reset placing state
    
    // Re-enable hover effects and pointer events on all poles
    if (gameDiv && gameDiv.children) {
      const allPoles = Array.from(gameDiv.children);
      allPoles.forEach(poleDiv => {
        poleDiv.style.pointerEvents = '';
        poleDiv.classList.remove('no-hover');
      });
    }
    
    resetGame(true);
  }
});



// Help modal wiring
function openHelp(){ helpModal.classList.remove('hidden'); }
function closeHelp(){ helpModal.classList.add('hidden'); }
helpBtn.addEventListener('click', openHelp);
helpClose.addEventListener('click', closeHelp);
helpModal.addEventListener('click', (e) => { if (e.target === helpModal) closeHelp(); });

// Sound button event listener
soundBtn.addEventListener('click', () => {
  openSoundControlModal();
});

// Merge sound button event listener
const mergeSoundBtn = document.getElementById('mergeSoundBtn');
mergeSoundBtn.addEventListener('click', () => {
  const usePopSounds = soundManager.toggleMergeSoundType();
  mergeSoundBtn.textContent = '🎵'; // Always show music note
  mergeSoundBtn.title = usePopSounds ? 'Switch to musical merge sounds' : 'Switch to pop merge sounds';
});

// Set initial merge sound button state
if (mergeSoundBtn) {
  const usePopSounds = soundManager.getMergeSoundType();
  mergeSoundBtn.textContent = '🎵'; // Always show music note
  mergeSoundBtn.title = usePopSounds ? 'Switch to musical merge sounds' : 'Switch to pop merge sounds';
}

// Set initial sound button state
if (soundBtn) {
  const isMuted = soundManager.getMuteState();
  soundBtn.textContent = isMuted ? '🔇' : '🔊';
  soundBtn.title = 'Sound Controls';
}
window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !helpModal.classList.contains('hidden')) closeHelp(); });

// Bomb conversion button event listener
bombConversionBtn.addEventListener('click', handleBombConversion);

// Trash button event listener
trashButton.addEventListener('click', handleTrashButton);

// Mobile button event listeners
bombConversionBtnMobile.addEventListener('click', handleBombConversion);
trashButtonMobile.addEventListener('click', handleTrashButton);

// Game over popup - any click anywhere closes it
const gameOverButton = document.getElementById('gameOverButton');
if (gameOverButton) {
  // Add click listener to the document to close game over popup on any click
  document.addEventListener('click', () => {
    if (gameOverButton.classList.contains('show')) {
      gameOverButton.classList.remove('show');
    }
  });
}

// Add button event listener for new game
const addBtn = document.getElementById('addBtn');
if (addBtn) {
  addBtn.addEventListener('click', openNewGameModal);
}

// New game modal button event listeners
const confirmNewGameBtn = document.getElementById('confirmNewGameBtn');
if (confirmNewGameBtn) {
  confirmNewGameBtn.addEventListener('click', handleNewGameConfirmation);
}

const cancelNewGameBtn = document.getElementById('cancelNewGameBtn');
if (cancelNewGameBtn) {
  cancelNewGameBtn.addEventListener('click', handleNewGameCancel);
}

// Close new game modal when clicking outside
const newGameModal = document.getElementById('newGameModal');
if (newGameModal) {
  newGameModal.addEventListener('click', (e) => {
    if (e.target === newGameModal) {
      closeNewGameModal();
    }
  });
}

// Close new game modal with Escape key
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && newGameModal && !newGameModal.classList.contains('hidden')) {
    closeNewGameModal();
  }
});

// Sound Control Modal Functions
function openSoundControlModal() {
  const modal = document.getElementById('soundControlModal');
  if (modal) {
    console.log('🎚️ Opening sound control modal...');
    console.log('🔊 Current sound volumes before UI update:', soundManager.getAllSoundVolumes());
    
    // Update UI with current sound settings
    updateSoundControlUI();
    
    console.log('🔊 Sound volumes after UI update:', soundManager.getAllSoundVolumes());
    modal.classList.remove('hidden');
  }
}

function closeSoundControlModal() {
  const modal = document.getElementById('soundControlModal');
  if (modal) {
    modal.classList.add('hidden');
  }
}

function updateSoundControlUI() {
  // Update master mute button
  const masterMuteBtn = document.getElementById('masterMuteBtn');
  if (masterMuteBtn) {
    const isMuted = soundManager.getMuteState();
    masterMuteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
    masterMuteBtn.classList.toggle('muted', isMuted);
  }
  
  // Update volume sliders and values
  const soundTypes = ['drop', 'merge', 'coin', 'bomb', 'other'];
  soundTypes.forEach(soundType => {
    const slider = document.getElementById(`${soundType}VolumeSlider`);
    const value = document.getElementById(`${soundType}VolumeValue`);
    
    if (slider && value) {
      const currentVolume = soundManager.getSoundVolume(soundType);
      console.log(`🎚️ UI Update: ${soundType} slider set to ${currentVolume}`);
      slider.value = currentVolume;
      value.textContent = currentVolume;
    }
  });
}

function initializeSoundControlModal() {
  // Master mute button
  const masterMuteBtn = document.getElementById('masterMuteBtn');
  if (masterMuteBtn) {
    masterMuteBtn.addEventListener('click', () => {
      const isMuted = soundManager.toggleMute();
      masterMuteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
      masterMuteBtn.classList.toggle('muted', isMuted);
      
      // Update sound button in title bar
      const soundBtn = document.getElementById('soundBtn');
      if (soundBtn) {
        soundBtn.textContent = isMuted ? '🔇' : '🔊';
        soundBtn.title = 'Sound Controls';
      }
      
      // Save game state to cookies to persist the mute change
      saveGameState();
    });
  }
  
  // Volume sliders
  const soundTypes = ['drop', 'merge', 'coin', 'bomb', 'other'];
  soundTypes.forEach(soundType => {
    const slider = document.getElementById(`${soundType}VolumeSlider`);
    const value = document.getElementById(`${soundType}VolumeValue`);
    
    if (slider && value) {
      slider.addEventListener('input', (e) => {
        const newVolume = parseInt(e.target.value);
        console.log(`🎚️ ${soundType} volume slider changed to: ${newVolume}`);
        soundManager.setSoundVolume(soundType, newVolume);
        value.textContent = newVolume;
        
        // Test the volume change immediately
        testVolumeChange(soundType, newVolume);
        
        // Save game state to cookies to persist the volume change
        saveGameState();
      });
    }
  });
  
  // Close button
  const closeBtn = document.getElementById('soundControlClose');
  if (closeBtn) {
    closeBtn.addEventListener('click', closeSoundControlModal);
  }
  
  // Test all sounds button
  const testAllSoundsBtn = document.getElementById('testAllSoundsBtn');
  if (testAllSoundsBtn) {
    testAllSoundsBtn.addEventListener('click', () => {
      console.log('🧪 Testing all sounds with current volume settings...');
      
      // Test each sound type
      const soundTypes = ['drop', 'merge', 'coin', 'bomb', 'other'];
      soundTypes.forEach((soundType, index) => {
        setTimeout(() => {
          testVolumeChange(soundType, soundManager.getSoundVolume(soundType));
        }, index * 500); // Play each sound 500ms apart
      });
    });
  }
  
  // Debug volumes button
  const debugVolumeBtn = document.getElementById('debugVolumeBtn');
  if (debugVolumeBtn) {
    debugVolumeBtn.addEventListener('click', () => {
      debugVolumeHandling();
    });
  }
  
  // Close modal when clicking outside
  const modal = document.getElementById('soundControlModal');
  if (modal) {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeSoundControlModal();
      }
    });
  }
  
  // Close modal with Escape key
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal && !modal.classList.contains('hidden')) {
      closeSoundControlModal();
    }
  });
}

// Initialize button states
updateBombConversionButtonState();
updateTrashButtonState();

// Initialize cost displays
if (bombCostEl) {
  bombCostEl.textContent = formatNumber(bombConversionCost);
}
if (trashCostEl) {
  trashCostEl.textContent = formatNumber(trashButtonCost);
}
if (bombCostElMobile) {
  bombCostElMobile.textContent = formatNumber(bombConversionCost);
}
if (trashCostElMobile) {
  trashCostElMobile.textContent = formatNumber(trashButtonCost);
}

// Debug button wiring
debugBtn.addEventListener('click', openDebugPane);

// Simple title selection detection to reveal debug button
document.addEventListener('DOMContentLoaded', () => {
  const titleElement = document.querySelector('h1');
  const debugBtn = document.getElementById('debugBtn');
  
  titleElement.addEventListener('mouseup', () => {
    const selection = window.getSelection();
    if (selection.toString().toLowerCase().includes('merge')) {
      debugBtn.style.display = 'block';
      console.log('Debug button revealed!');
    }
  });
  
  // Initialize sound control modal after DOM is loaded
  initializeSoundControlModal();
});

// Test function to verify volume changes are working
function testVolumeChange(soundType, volume) {
  console.log(`🧪 Testing ${soundType} volume change to ${volume}`);
  
  // Get the actual volume value that would be used
  const actualVolume = soundManager.getActualVolume(soundType);
  console.log(`🔊 ${soundType} actual volume: ${actualVolume} (${Math.round(actualVolume * 100)}%)`);
  
  // Test playing a sound if the volume is not 0
  if (actualVolume > 0) {
    console.log(`🎵 ${soundType} volume is not muted, sound should play`);
    
    // Play a test sound based on the sound type
    switch (soundType) {
      case 'drop':
        console.log('📦 Testing drop sound...');
        soundManager.playDropSound(1);
        break;
      case 'merge':
        console.log('🔗 Testing merge sound...');
        soundManager.playMergeSound(2);
        break;
      case 'coin':
        console.log('💰 Testing coin sound...');
        soundManager.playCoinSound();
        break;
      case 'bomb':
        console.log('💥 Testing bomb sound...');
        soundManager.playBombSound();
        break;
      case 'other':
        console.log('🚀 Testing stage up sound...');
        soundManager.playStageProgressionSound();
        break;
    }
  } else {
    console.log(`🔇 ${soundType} volume is muted (0), sound should NOT play`);
  }
}

// Debug function to test volume handling
function debugVolumeHandling() {
  console.log('🔍 Debugging volume handling...');
  
  // Test setting a volume to 0
  console.log('🧪 Setting drop volume to 0...');
  soundManager.setSoundVolume('drop', 0);
  
  // Test getting the volume back
  const retrievedVolume = soundManager.getSoundVolume('drop');
  console.log(`📊 Retrieved drop volume: ${retrievedVolume} (should be 0)`);
  
  // Test the actual volume calculation
  const actualVolume = soundManager.getActualVolume('drop');
  console.log(`🔊 Actual drop volume: ${actualVolume} (should be 0)`);
  
  // Test setting it back to 3
  console.log('🧪 Setting drop volume back to 3...');
  soundManager.setSoundVolume('drop', 3);
  
  const retrievedVolume2 = soundManager.getSoundVolume('drop');
  console.log(`📊 Retrieved drop volume: ${retrievedVolume2} (should be 3)`);
  
  const actualVolume2 = soundManager.getActualVolume('drop');
  console.log(`🔊 Actual drop volume: ${actualVolume2} (should be 0.6)`);
  
  console.log('🔍 Volume handling debug complete');
}

function toggleAI(enable){
  if(enable === aiEnabled) return;
  aiEnabled = enable;
  
  console.log('AI toggled:', aiEnabled ? 'ON' : 'OFF');
  
  // Update debug pane display if it exists
  if (debugAiToggle) {
    updateDebugAutoPlayDisplay();
  }
  

  
  if(aiEnabled){
    // start AI interval
    if(aiInterval) clearInterval(aiInterval);
    // make an immediate move then interval
    console.log('AI: Starting immediate move');
    aiStep();
    // Set up the initial interval based on current speed
    const delays = [2000, 1500, 1000, 500, 50];
    const initialDelay = delays[currentSpeed];
    console.log('AI: Setting up interval with delay:', initialDelay, 'ms');
    aiInterval = setInterval(aiStep, initialDelay);
  } else {
    if(aiInterval) clearInterval(aiInterval);
    aiInterval = null;
    console.log('AI: Stopped and cleared interval');
    
    // Reset animation speed to default when auto-play is turned off
    currentSpeed = 2; // Medium
    if (debugSpeedSlider) {
      debugSpeedSlider.value = currentSpeed;
    }
    updateSpeedLabel();
    updateDebugSpeedLabel();
    updateAnimationSpeed();
  }
}

function updateSpeedLabel() {
  if (debugSpeedLabel) {
    const speedLabels = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Blazing'];
    debugSpeedLabel.textContent = speedLabels[currentSpeed];
  }
}

function updateAISpeed() {
  if (!aiEnabled) return;
  
  // Clear existing interval if it exists
  if (aiInterval) {
    clearInterval(aiInterval);
  }
  
  // Calculate new delay based on speed (0-4)
  // Speed 0 = Very Slow (2000ms), Speed 4 = Blazing (50ms)
  const delays = [2000, 1500, 1000, 500, 50];
  const newDelay = delays[currentSpeed];
  
  // Restart interval with new speed
  aiInterval = setInterval(aiStep, newDelay);
}

function updateAnimationSpeed() {
  // Calculate animation multiplier based on speed (0-4)
  // Speed 0 = Very Slow (3x slower), Speed 4 = Blazing (0x - instant, no animations)
  const multipliers = [3, 2, 1, 0.5, 0];
  
  // When speed is 4 (Blazing), set multiplier to 0 to disable animations
  const multiplier = multipliers[currentSpeed];
  
  // Update CSS custom properties for animation durations
  document.documentElement.style.setProperty('--animation-speed', multiplier);
  
  // Apply animation speed to all animated elements for instant animation support
  const animatedElements = document.querySelectorAll('.disc, .next-disc, .pole');
  animatedElements.forEach(el => {
    el.style.setProperty('--animation-speed', multiplier);
  });
  
  console.log(`Animation speed updated: ${multiplier} (speed level: ${currentSpeed})`);
}

function updateStackHeight() {
  // Stack height is now fixed at MAX_HEIGHT (10) - no more dynamic reduction
  // Base height varies by screen size for mobile responsiveness
  // Each slot needs: disc height + margin-top
  // 10 slots need: (disc height + margin) × 10 + pole padding
  let baseHeight = 542; // Desktop: 42px disc + 9px margin = 51px per slot, 10 slots = 510px + 32px padding = 542px
  
  // Check if we're on mobile and adjust height accordingly
  if (window.innerWidth <= 480) {
    // Extra small mobile: 26px disc + 4px margin = 30px per slot
    // 10 slots: 30px × 10 = 300px + 16px padding (8px top + 8px bottom) = 316px
    baseHeight = 316;
    console.log('Mobile (≤480px): Setting stack height to', baseHeight, 'px for 10 slots');
  } else if (window.innerWidth <= 768) {
    // Regular mobile: 30px disc + 6px margin = 36px per slot  
    // 10 slots: 36px × 10 = 360px + 24px padding (12px top + 12px bottom) = 384px
    baseHeight = 384;
    console.log('Mobile (≤768px): Setting stack height to', baseHeight, 'px for 10 slots');
  } else {
    console.log('Desktop: Setting stack height to', baseHeight, 'px for 10 slots');
  }
  
  // Update CSS custom property for stack height
  document.documentElement.style.setProperty('--stack-height', baseHeight + 'px');
  console.log('Updated --stack-height to', baseHeight, 'px');
}

function updateDebugPane() {
  if (debugScore) debugScore.textContent = score;
  if (debugGold) debugGold.textContent = gold;
  if (debugStacks) debugStacks.textContent = poles.length;
  if (debugCapacity) debugCapacity.textContent = currentStackCapacity;
  if (debugTarget) debugTarget.textContent = currentTargetBlockSize * 2;
  if (debugMaxBlock) debugMaxBlock.textContent = Math.max(...weights);
  if (debugBlocksDropped) debugBlocksDropped.textContent = blocksDropped;
  if (debugBombStatus) debugBombStatus.textContent = blocksDropped >= BOMB_DELAY_BLOCKS ? 'Enabled' : 'Disabled';
  if (debugStage) debugStage.textContent = currentStage;
  
  // Update probabilities display
  updateDebugProbabilitiesDisplay();
}



// Debug pane wiring
function openDebugPane(){ 
  debugPane.classList.add('show'); 
  syncDebugControls();
}
function closeDebugPane(){ 
  debugPane.classList.remove('show'); 
  // Reset custom block mode when debug pane is closed
  customBlockMode = false;
  
  console.log('Debug pane closed, custom block mode disabled');
}
debugClose.addEventListener('click', closeDebugPane);
debugPane.addEventListener('click', (e) => { if (e.target === debugPane) closeDebugPane(); });
window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && debugPane.classList.contains('show')) closeDebugPane(); });

// New Game Modal Functions
function openNewGameModal() {
  const newGameModal = document.getElementById('newGameModal');
  if (newGameModal) {
    newGameModal.classList.remove('hidden');
  }
}

function closeNewGameModal() {
  const newGameModal = document.getElementById('newGameModal');
  if (newGameModal) {
    newGameModal.classList.add('hidden');
  }
}

function handleNewGameConfirmation() {
  closeNewGameModal();
  // Play stage up sound effect when starting a new game
  soundManager.playStageProgressionSound();
  resetGame(true);
}

function handleNewGameCancel() {
  closeNewGameModal();
}

function syncDebugControls() {
  // Sync auto-play state
  updateDebugAutoPlayDisplay();
  
  // Sync speed control
  if (debugSpeedSlider) {
    debugSpeedSlider.value = currentSpeed;
  }
  updateDebugSpeedLabel();
  
  // Sync sound controls
  if (debugVolumeSlider) {
    debugVolumeSlider.value = Math.round(soundManager.getVolume() * 100);
  }
  updateDebugVolumeLabel();
  
  if (debugMuteToggle) {
    debugMuteToggle.checked = soundManager.getMuteState();
  }
  updateDebugMuteStatus();
  
  // Sync probability curve controls
  if (debugDecaySlider) {
    // Always show the current active decay factor
    debugDecaySlider.value = currentActiveDecayFactor;
    updateDebugDecayLabel(currentActiveDecayFactor);
  } else {
    updateDebugDecayLabel(currentActiveDecayFactor);
  }
  
  // Update probabilities display
  updateDebugProbabilitiesDisplay();
  
  // Set up event listeners for debug controls (only if they exist)
  if (debugVolumeSlider) {
    // Remove existing listeners to avoid duplicates
    debugVolumeSlider.removeEventListener('input', handleVolumeChange);
    debugVolumeSlider.addEventListener('input', handleVolumeChange);
  }
  
  if (debugMuteToggle) {
    // Remove existing listeners to avoid duplicates
    debugMuteToggle.removeEventListener('change', handleMuteToggle);
    debugMuteToggle.addEventListener('change', handleMuteToggle);
  }
  
  if (debugDecaySlider) {
    // Remove existing listeners to avoid duplicates
    debugDecaySlider.removeEventListener('input', handleDecayChange);
    debugDecaySlider.addEventListener('input', handleDecayChange);
  }
  
  if (debugUpdateProbBtn) {
    // Remove existing listeners to avoid duplicates
    debugUpdateProbBtn.removeEventListener('click', handleUpdateProbabilities);
    debugUpdateProbBtn.addEventListener('click', handleUpdateProbabilities);
  }
  
  // Set up auto-play control event listeners
  if (debugAiToggle) {
    // Remove existing listeners to avoid duplicates
    debugAiToggle.removeEventListener('click', handleAiToggle);
    debugAiToggle.addEventListener('click', handleAiToggle);
  }
  
  if (debugSpeedSlider) {
    // Remove existing listeners to avoid duplicates
    debugSpeedSlider.removeEventListener('input', handleSpeedSlider);
    debugSpeedSlider.addEventListener('input', handleSpeedSlider);
  }
  
  // Set up debug button event listeners
  if (grantGoldBtn) {
    // Remove existing listeners to avoid duplicates
    grantGoldBtn.removeEventListener('click', handleGrantGold);
    grantGoldBtn.addEventListener('click', handleGrantGold);
  }
  
  if (grantScoreBtn) {
    // Remove existing listeners to avoid duplicates
    grantScoreBtn.removeEventListener('click', handleGrantScore);
    grantScoreBtn.addEventListener('click', handleGrantScore);
  }
  
  const checkCoinStatusBtn = document.getElementById('checkCoinStatusBtn');
  if (checkCoinStatusBtn) {
    // Remove existing listeners to avoid duplicates
    checkCoinStatusBtn.removeEventListener('click', handleCheckCoinStatus);
    checkCoinStatusBtn.addEventListener('click', handleCheckCoinStatus);
  }
  
  // Set up block grid interface event listeners
  document.querySelectorAll('.block-item').forEach(blockItem => {
    // Remove existing listeners to avoid duplicates
    blockItem.removeEventListener('click', () => handleBlockItemClick(blockItem));
    blockItem.addEventListener('click', () => handleBlockItemClick(blockItem));
  });
  
  // Set up bomb toggle event listener
  if (bombToggle) {
    // Remove existing listeners to avoid duplicates
    bombToggle.removeEventListener('change', handleBombToggle);
    bombToggle.addEventListener('change', handleBombToggle);
  }
}

// Debug pane controls will be set up in syncDebugControls()

// Debug button event listeners will be set up in syncDebugControls()

// Debug auto-play controls - will be set up in syncDebugControls()

// Event listener handler functions for debug controls
function handleVolumeChange(e) {
  const volume = parseInt(e.target.value) / 100;
  soundManager.setVolume(volume);
  updateDebugVolumeLabel();
}

function handleMuteToggle(e) {
  const isMuted = soundManager.toggleMute();
  updateDebugMuteStatus();
  // Update the main sound button to match
  const soundBtn = document.getElementById('soundBtn');
  if (soundBtn) {
    soundBtn.textContent = isMuted ? '🔇' : '🔊';
    soundBtn.title = isMuted ? 'Unmute sound' : 'Mute sound';
  }
}

function handleDecayChange(e) {
  const decayFactor = parseFloat(e.target.value);
  updateDebugDecayLabel(decayFactor);
}

function handleUpdateProbabilities() {
  const decayFactor = parseFloat(debugDecaySlider.value);
  updateProbabilityDistributionWithDecay(decayFactor);
}

function handleAiToggle() {
  toggleAI(!aiEnabled);
  updateDebugAutoPlayDisplay();
}

function handleSpeedSlider(e) {
  currentSpeed = parseInt(e.target.value);
  updateSpeedLabel();
  updateDebugSpeedLabel();
  updateAISpeed();
  updateAnimationSpeed();
}

function handleGrantGold() {
  gold += 1000;
  // Update gold display
  updateGoldDisplay();
  // Update bomb conversion button state
  updateBombButtonIfGoldChanged();
  // Update trash button state
  updateTrashButtonIfGoldChanged();
  
  // Play coin sound effect for earning gold
  soundManager.playCoinSound();
  
  // Save game state after granting gold
  console.log('🔄 Triggering save after granting gold...');
  saveGameState();
  
  console.log(`Granted 1000 gold. New balance: ${gold}`);
}

function handleGrantScore() {
  score += 1000;
  // Update score display
  updateScoreDisplay();
  
  // Save game state after granting score
  console.log('🔄 Triggering save after granting score...');
  saveGameState();
  
  console.log(`Granted 1000 score. New score: ${score}`);
}

function handleCheckCoinStatus() {
  const status = soundManager.getCoinSoundStatus();
  console.log('🪙 Coin Sound Status:', status);
  
  if (status.loaded && status.count === status.expected) {
    console.log('✅ All coin sounds loaded successfully!');
  } else {
    console.warn('⚠️ Coin sound loading issues detected');
  }
}

function handleBlockItemClick(blockItem) {
  // Remove previous selection
  document.querySelectorAll('.block-item').forEach(item => item.classList.remove('selected'));
  
  // Select this block
  blockItem.classList.add('selected');
  
  // Check if "No Block" is selected
  if (blockItem.dataset.value === 'none') {
    customBlockSize = null;
    customBlockMode = false;
    console.log('No block selected - using queue');
  } else {
    // Update the custom block size
    const value = parseInt(blockItem.dataset.value);
    customBlockSize = value;
    
    // Enable custom block mode
    customBlockMode = true;
    
    console.log(`Selected block: ${value}`);
  }
  
  // Re-render to update pole enabling/disabling based on the new custom block
  render();
}

function handleBombToggle(e) {
  customBlockBomb = e.target.checked;
  bombStatus.textContent = customBlockBomb ? 'Yes' : 'No';
  
  // Re-render to update pole enabling/disabling if custom block mode is active
  if (customBlockMode && customBlockSize) {
    render();
  }
}

function updateDebugAutoPlayDisplay() {
  debugAiToggle.textContent = aiEnabled ? 'Auto Play: On' : 'Auto Play: Off';
  debugAiToggle.classList.toggle('active', aiEnabled);
}

function updateDebugSpeedLabel() {
  const speedLabels = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Blazing'];
  debugSpeedLabel.textContent = speedLabels[currentSpeed];
}

function updateDebugVolumeLabel() {
  const volume = Math.round(soundManager.getVolume() * 100);
  debugVolumeLabel.textContent = volume + '%';
}

function updateDebugMuteStatus() {
  const isMuted = soundManager.getMuteState();
  debugMuteStatus.textContent = isMuted ? 'Yes' : 'No';
  
  // Also update merge sound button state in debug panel
  const mergeSoundBtn = document.getElementById('mergeSoundBtn');
  if (mergeSoundBtn) {
    const usePopSounds = soundManager.getMergeSoundType();
    mergeSoundBtn.textContent = '🎵'; // Always show music note
    mergeSoundBtn.title = usePopSounds ? 'Switch to musical merge sounds' : 'Switch to pop merge sounds';
  }
}

function updateDebugDecayLabel(decayFactor) {
  debugDecayLabel.textContent = decayFactor.toFixed(2);
}

function updateDebugProbabilitiesDisplay() {
  const probDiv = document.getElementById('debugProbabilities');
  if (!probDiv) return;
  
  if (!probabilities || probabilities.length === 0) {
    probDiv.innerHTML = '<em>No probabilities available</em>';
    return;
  }
  
  let html = '<div style="margin-bottom: 8px;"><strong>Block | Probability | Cumulative</strong></div>';
  
  let cumulative = 0;
  for (let i = 0; i < weights.length; i++) {
    cumulative += probabilities[i];
    const percentage = (probabilities[i] * 100).toFixed(2);
    const cumulativePercentage = (cumulative * 100).toFixed(2);
    
    // Different styling for foundation vs decay blocks
    const isFoundation = i < 3;
    const blockColor = isFoundation ? '#10B981' : '#0ea5e9'; // Green for foundation, blue for decay
    const bgColor = i % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'transparent';
    const borderStyle = isFoundation ? '2px solid #10B981' : 'none';
    
    html += `<div style="margin: 2px 0; padding: 2px 4px; background: ${bgColor}; border-radius: 2px; border: ${borderStyle};">
      <span style="color: ${blockColor}; font-weight: 600;">${weights[i]}</span> | 
      <span style="color: #10B981;">${percentage}%</span> | 
      <span style="color: #F59E0B;">${cumulativePercentage}%</span>
      ${isFoundation ? ' <span style="color: #10B981; font-size: 10px;">(Foundation)</span>' : ''}
    </div>`;
  }
  
  probDiv.innerHTML = html;
}

function updateProbabilityDistributionWithDecay(decayFactor) {
  // Update the current active decay factor
  currentActiveDecayFactor = decayFactor;
  
  console.log(`Updating probability distribution with decay factor: ${decayFactor}`);
  
  // Recalculate probabilities with the new decay factor
  updateProbabilityDistributionCustom(decayFactor);
  
  // Log the change
  console.log(`Probability distribution updated with decay factor: ${decayFactor}`);
  
  // Update the debug display
  updateDebugDecayLabel(decayFactor);
  
  // Update the slider to reflect the current active setting
  if (debugDecaySlider) {
    debugDecaySlider.value = decayFactor;
  }
}

function colorFor(w){
  const colors = [
    '#cfef08', // lime green - value 1 (subtle)
    '#10B981', // emerald-500 - value 2 (soft green)
    '#2563EB', // blue-600 - value 4 (medium blue)
    '#7C3AED', // violet-600 - value 8 (violet - midpoint between blue and dark purple)
    '#581C87', // violet-800 - value 16 (dark purple)
    '#D946EF', // fuchsia-500 - value 32 (bright fuchsia - clearly different from 16)
    '#EC4899', // pink-500 - value 64 (hot pink)
    '#e86758', // red-500 - value 128 (intense red)
    '#F59E0B', // amber-500 - value 256 (bright amber)
    '#ea580c', // orange-600 - value 512 (vibrant orange)
    '#dc2626', // red-600 - value 1024 (bright red)
    '#9d174d', // rose-700 - value 2048 (darker magenta)
    '#7c2d6d',    // darker purple-magenta - value 4096
    '#64748b', // gray - value 8192
    '#fff'     // white - value 16384
  ];
  
  const log2w = Math.log2(w);
  const colorIndex = Math.min(Math.floor(log2w), colors.length - 1);
  return colors[colorIndex];
}

function labelForPiece(piece){
  if (piece && piece.bomb) {
    // Format bomb text for large numbers (6+ digits)
    const displayValue = piece.w >= 100000 ? formatNumber(piece.w) : piece.w;
    return `<div class="bomb-content"><div class="bomb-emoji">💣</div><div class="bomb-text">${displayValue}</div></div>`;
  }
  // Format regular block text for large numbers (6+ digits)
  return piece.w >= 100000 ? formatNumber(piece.w) : String(piece.w);
}

function getTextColorFor(w){
  // Return black text for lime green block (value 1) and blocks >= 16384, white for others
  return (w === 1 || w >= 16384) ? '#000000' : '#ffffff';
}

function render(){
  // build poles
  gameDiv.innerHTML = '';
  
  // Safety check: ensure we only have exactly 4 poles
  if (poles.length !== 4) {
    console.warn(`Warning: Expected 4 poles but found ${poles.length}. Resetting to 4 poles.`);
    poles = [[],[],[],[]];
  }
  
  console.log(`Rendering ${poles.length} poles:`, poles.map(p => p.length));
  
  poles.forEach((pole, idx) => {
    const poleDiv = document.createElement('div');
    const isAtCapacity = pole.length >= currentStackCapacity;
    
    // Determine which piece to check against for pole enabling/disabling
    let pieceToCheck;
    if (customBlockMode && customBlockSize && debugPane && debugPane.classList.contains('show')) {
      pieceToCheck = { w: customBlockSize, bomb: customBlockBomb };
    } else {
      pieceToCheck = nextQueue[0];
    }
    
    const playable = canPlaceOnPole(pieceToCheck, pole);
    const isDisabled = isAtCapacity && !playable;
    
    poleDiv.className = 'pole' + (isDisabled ? ' full' : '');
    
    // Preserve the no-hover state if we're currently placing
    if (placing) {
      poleDiv.classList.add('no-hover');
      poleDiv.style.pointerEvents = 'none';
    }
    
    // If stack is disabled (full and can't merge), disable interactions
    if (isDisabled) {
      poleDiv.classList.add('no-hover');
      poleDiv.style.pointerEvents = 'none';
      poleDiv.style.cursor = 'not-allowed';
    }
    
    poleDiv.setAttribute('role', 'button');
    poleDiv.tabIndex = isDisabled ? -1 : 0;
    poleDiv.setAttribute('aria-label', `Stack ${idx + 1}, contains ${pole.length} blocks${isAtCapacity ? (playable ? ', merge available' : ', blocked') : ''}`);
    poleDiv.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (!isDisabled) {
          placeOnPole(idx);
        }
      }
    });
    // existing discs (no animation class)
    pole.forEach(p => {
      const d = document.createElement('div');
      d.className = 'disc';
      if (p.bomb) {
        d.innerHTML = labelForPiece(p);
      } else {
        d.textContent = labelForPiece(p);
      }
      d.style.background = p.bomb ? '#000' : colorFor(p.w);
      d.style.color = p.bomb ? '#fff' : getTextColorFor(p.w);
      
      // Add dynamic gold glow effect for white blocks (16384+)
      if (!p.bomb && p.w >= 16384) {
        d.classList.add('white-block-glow');
        
        // Calculate glow intensity based on block value
        const log2Value = Math.log2(p.w);
        const baseLog2 = Math.log2(16384); // 14
        const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
        
        // Set CSS custom properties for dynamic glow
        d.style.setProperty('--glow-intensity', intensityMultiplier.toString());
        d.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
        d.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
        d.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
        d.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
        d.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
      }
      
      poleDiv.appendChild(d);
    });
    
    // Only add click handler if stack is not disabled
    if (!isDisabled) {
      poleDiv.addEventListener('click', () => placeOnPole(idx));
      
      // Add touch event handling for better mobile experience
      let touchStartTime = 0;
      let touchStartY = 0;
      
      poleDiv.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        touchStartY = e.touches[0].clientY;
        // Prevent default to avoid double-tap zoom on mobile
        e.preventDefault();
      }, { passive: false });
      
      poleDiv.addEventListener('touchend', (e) => {
        const touchEndTime = Date.now();
        const touchEndY = e.changedTouches[0].clientY;
        const touchDuration = touchEndTime - touchStartTime;
        const touchDistance = Math.abs(touchEndY - touchStartY);
        
        // Only trigger placement if it's a quick tap (not a swipe) and close to start position
        if (touchDuration < 300 && touchDistance < 20) {
          placeOnPole(idx);
        }
      });
      
      // Clear hover state when touch moves (prevents stuck highlights)
      poleDiv.addEventListener('touchmove', (e) => {
        // If touch moves significantly, don't trigger placement
        const currentY = e.touches[0].clientY;
        if (Math.abs(currentY - touchStartY) > 20) {
          // Touch moved too much, this won't be a valid tap
        }
      });
      
      // Handle touch cancellation
      poleDiv.addEventListener('touchcancel', () => {
        // Touch was cancelled, do nothing
      });
    }
    
    gameDiv.appendChild(poleDiv);
    
    // Apply current animation speed to the new pole
    poleDiv.style.setProperty('--animation-speed', document.documentElement.style.getPropertyValue('--animation-speed'));
  });
  
  // Final safety check: verify we only have 4 pole elements
  const renderedPoles = gameDiv.querySelectorAll('.pole');
  if (renderedPoles.length !== 4) {
    console.error(`Error: Rendered ${renderedPoles.length} pole elements instead of 4! Clearing and re-rendering...`);
    gameDiv.innerHTML = '';
    // Force a single re-render
    setTimeout(() => render(), 0);
    return;
  }
  
  console.log(`Successfully rendered ${renderedPoles.length} poles`);
  
  // update score display in game info
  updateScoreDisplay();
  
  // update gold display in game info
  updateGoldDisplay();
  
  // Update bomb conversion button state
  updateBombButtonIfGoldChanged();
  // Update trash button state
  updateTrashButtonIfGoldChanged();
  

  
  updateDebugPane();
  
  renderNext();
}

function renderNext(){
  nextContainer.innerHTML = '';
  nextQueue.forEach((p, idx) => {
    const d = document.createElement('div');
    d.className = 'next-disc' + (idx === 0 ? ' current' : '');
    if (p.bomb) {
      d.innerHTML = labelForPiece(p);
    } else {
      d.textContent = labelForPiece(p);
    }
    d.style.background = p.bomb ? '#000' : colorFor(p.w);
    d.style.color = p.bomb ? '#fff' : getTextColorFor(p.w);
    
    // Add dynamic gold glow effect for white blocks (16384+)
    if (!p.bomb && p.w >= 16384) {
      d.classList.add('white-block-glow');
      
      // Calculate glow intensity based on block value
      const log2Value = Math.log2(p.w);
      const baseLog2 = Math.log2(16384); // 14
      const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
      
      // Set CSS custom properties for dynamic glow
      d.style.setProperty('--glow-intensity', intensityMultiplier.toString());
      d.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
      d.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
      d.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
      d.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
      d.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
    }
    
    nextContainer.appendChild(d);
    
    // Apply current animation speed to the new next disc
    d.style.setProperty('--animation-speed', document.documentElement.style.getPropertyValue('--animation-speed'));
  });
}

function placeOnPole(idx){
  console.log('placeOnPole called with idx:', idx, 'placing:', placing);
  if (placing) { 
    console.log('Placement in progress, ignoring click for pole:', idx);
    return; // Simply ignore clicks during placement instead of queueing
  }
  const pole = poles[idx];
  
  // Check if custom block mode is active AND debug pane is open
  let nextPiece;
  let wasCustomBlock = false;
  if (customBlockMode && customBlockSize && debugPane && debugPane.classList.contains('show')) {
    nextPiece = { w: customBlockSize, bomb: customBlockBomb };
    wasCustomBlock = true;
    // Custom block mode only works when debug pane is visible and a block is selected
  } else {
    nextPiece = nextQueue[0];
  }
  
  // Safety check: ensure this stack can actually accept the piece
  if (!canPlaceOnPole(nextPiece, pole)) {
    console.log('Cannot place piece on this pole, ignoring click');
    return;
  }
  placing = true;
  lastPlacementTime = Date.now();

  // Disable hover effects on all poles during placement
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = 'none';
    poleDiv.classList.add('no-hover');
    console.log('Added no-hover class to pole:', poleDiv);
    console.log('Pole classes after adding no-hover:', poleDiv.className);
    console.log('Pole computed pointer-events:', window.getComputedStyle(poleDiv).pointerEvents);
  });

  // append an animated disc to the pole DOM, without modifying the data model yet
  const poleDiv = gameDiv.children[idx];
  const animDisc = document.createElement('div');
  animDisc.className = 'disc animate';
  if (nextPiece.bomb) {
    animDisc.innerHTML = labelForPiece(nextPiece);
  } else {
    animDisc.textContent = labelForPiece(nextPiece);
  }
  animDisc.style.background = nextPiece.bomb ? '#000' : colorFor(nextPiece.w);
  animDisc.style.color = nextPiece.bomb ? '#fff' : getTextColorFor(nextPiece.w);
  
  // Add dynamic gold glow effect for white blocks (16384+)
  if (!nextPiece.bomb && nextPiece.w >= 16384) {
    animDisc.classList.add('white-block-glow');
    
    // Calculate glow intensity based on block value
    const log2Value = Math.log2(nextPiece.w);
    const baseLog2 = Math.log2(16384); // 14
    const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
    
    // Set CSS custom properties for dynamic glow
    animDisc.style.setProperty('--glow-intensity', intensityMultiplier.toString());
    animDisc.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
    animDisc.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
    animDisc.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
    animDisc.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
    animDisc.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
  }
  
  // Apply current animation speed to the animated disc
  animDisc.style.setProperty('--animation-speed', document.documentElement.style.getPropertyValue('--animation-speed'));
  
  // Apply current stack height to the animated disc
  animDisc.style.setProperty('--stack-height', document.documentElement.style.getPropertyValue('--stack-height'));
  
  // Let CSS handle the mobile-specific drop animations
  // The CSS media queries will automatically apply the correct animation
  
  poleDiv.appendChild(animDisc);

  // Quick check if audio context is already active (most common case)
  if (soundManager.isAudioContextActive()) {
    // Audio context is active, play sound immediately
    soundManager.playDropSound(nextPiece.w);
  } else {
    // Audio context might be suspended, ensure it's active then play
    soundManager.ensureAudioContextActive().then(() => {
      soundManager.playDropSound(nextPiece.w);
    }).catch(error => {
      console.warn('⚠️ Failed to ensure audio context active for drop sound:', error);
      // Try to play anyway as fallback
      soundManager.playDropSound(nextPiece.w);
    });
  }

  // Check if animations are disabled (speed = 0)
  const animationSpeed = parseFloat(document.documentElement.style.getPropertyValue('--animation-speed') || '1');
  const isInstantAnimation = animationSpeed === 0;

  // after drop animation, commit, then animate merge cascade step-by-step
  const handlePlacement = async () => {
    // Add safety timeout to prevent hanging
    const safetyTimeout = setTimeout(() => {
      if (placing) {
        console.error('Placement safety timeout - forcing completion');
        placing = false;
        
        render();
        checkGameOver();
      }
    }, 10000); // 10 second safety timeout
    
    try {
      poles[idx].push(nextPiece);
      
      // Check if this is a purchased bomb that needs payment
      if (bombSelected && nextPiece.bomb) {
        // Deduct gold for the bomb usage
        gold -= bombConversionCost;
        
        // Play purchase sound for the bomb usage
        soundManager.playPurchaseSound();
        
        // Increment press count and double the cost for next time
        bombConversionCost *= 2;
        
        // Update button cost display
        if (bombCostEl) {
          bombCostEl.textContent = formatNumber(bombConversionCost);
        }
        if (bombCostElMobile) {
          bombCostElMobile.textContent = formatNumber(bombConversionCost);
        }
        
        // Reset bomb selection since it's now placed
        bombSelected = false;
        
        // Update gold display
        updateGoldDisplay();
        
        // Update button states
        updateBombConversionButtonState();
        updateBombButtonIfGoldChanged();
        
        console.log(`Bomb placed! Deducted ${bombConversionCost / 2} gold, new cost: ${bombConversionCost}`);
        
        // Save game state after bomb payment
        saveGameState();
      }
      
      // scoring: add only the dropped piece's weight
      score += nextPiece.w;
      updateScoreDisplay();
      
      // Save game state after placing a block
      console.log('🔄 Triggering save after block placement...');
      saveGameState();
      
      // Add pulse animation to the score display
      const scoreDisplay = document.querySelector('.score-value');
      if (scoreDisplay) {
        scoreDisplay.classList.add('pulse');
        setTimeout(() => {
          scoreDisplay.classList.remove('pulse');
        }, 300);
      }
      
      // Increment blocks dropped counter (only for regular pieces, not custom debug pieces)
      if (!wasCustomBlock) {
        blocksDropped++;
      }
      
      // Only advance the queue if we used a regular piece, not a custom one
      if (!wasCustomBlock) {
        // animate next queue: consume current, shift others, append new
        await animateNextQueueAdvance(); // false = queue not yet modified
      }
      
      render();
      try {
        await animateMergeCascade(idx);
        
        // Only set placing to false after merge cascade completes
        placing = false;
        console.log('Placement completed, placing set to false');
      } catch (error) {
        console.error('Merge cascade error:', error);
        // Force reset placing flag on error to prevent game freeze
        placing = false;
        console.log('Placement error - forcing placing to false');
        
        // Re-enable hover effects and pointer events after placing is false
        const allPoles = Array.from(gameDiv.children);
        allPoles.forEach(poleDiv => {
          poleDiv.style.pointerEvents = '';
          poleDiv.classList.remove('no-hover');
          console.log('Removed no-hover class from pole (error):', poleDiv);
        });
      }
      render();
      checkGameOver();
      

      
    } finally {
      clearTimeout(safetyTimeout);
    }
  };

  // If animations are disabled or very fast, execute placement immediately
  if (isInstantAnimation || animationSpeed <= 0.5) {
    console.log(`Fast/instant animation detected (${animationSpeed}), executing placement immediately`);
    // Remove the animated disc since we don't need it
    animDisc.remove();
    // Execute placement logic immediately
    handlePlacement();
  } else {
    // Wait for animation to complete
    console.log(`Normal animation speed (${animationSpeed}), waiting for animationend event`);
    animDisc.addEventListener('animationend', handlePlacement, { once: true });
  }
}

function waitForAnimation(element){
  return new Promise(resolve => {
    // Check if animations are disabled (speed = 0)
    const animationSpeed = element.style.getPropertyValue('--animation-speed') || 
                          document.documentElement.style.getPropertyValue('--animation-speed') || '1';
    const speedValue = parseFloat(animationSpeed);
    
    if (speedValue === 0) {
      console.log('Animations disabled, resolving immediately');
      // Add a small delay to ensure DOM updates are processed
      setTimeout(resolve, 10);
      return;
    }
    
    // For very fast animations (speed <= 0.5), add a small delay to ensure proper timing
    if (speedValue <= 0.5) {
      console.log(`Very fast animation detected (${speedValue}), adding delay`);
      setTimeout(resolve, Math.max(50, speedValue * 100)); // At least 50ms delay
      return;
    }
    
    // Add multiple event listeners to catch different animation end events
    const handleAnimationEnd = () => {
      console.log('Animation ended for element:', element);
      resolve();
    };
    
    element.addEventListener('animationend', handleAnimationEnd, { once: true });
    element.addEventListener('webkitAnimationEnd', handleAnimationEnd, { once: true });
    
    // Also check if animation is actually running
    const computedStyle = window.getComputedStyle(element);
    const animationName = computedStyle.animationName;
    
    if (animationName === 'none') {
      console.log('No animation detected, resolving immediately');
      resolve();
      return;
    }
    
    // Fallback timeout to prevent hanging
    setTimeout(() => {
      console.log('Animation timeout fallback triggered for:', animationName);
      resolve();
    }, 1500); // 1.5 second timeout
  });
}

// Function to check if any animations are currently running
function areAnyAnimationsRunning() {
  // Check all poles for running animations
  const allPoles = Array.from(gameDiv.children);
  for (const pole of allPoles) {
    const discs = pole.querySelectorAll('.disc');
    for (const disc of discs) {
      const computedStyle = window.getComputedStyle(disc);
      const animationName = computedStyle.animationName;
      if (animationName !== 'none') {
        console.log('Found running animation on disc:', animationName, disc);
        return true;
      }
    }
  }
  
  // Check next queue for running animations
  const nextItems = nextContainer.querySelectorAll('.next-disc');
  for (const item of nextItems) {
    const computedStyle = window.getComputedStyle(item);
    const animationName = computedStyle.animationName;
    if (animationName !== 'none') {
      console.log('Found running animation on next item:', animationName, item);
      return true;
    }
  }
  
  return false;
}

async function animateMergeCascade(index){
  console.log('Starting merge cascade for pole:', index);
  
  // Global timeout to prevent infinite hanging
  const globalTimeout = setTimeout(() => {
    console.error('Merge cascade global timeout - forcing completion');
    throw new Error('Merge cascade timeout');
  }, 5000); // 5 second global timeout
  
  try {
    let iterationCount = 0;
    const maxIterations = 20; // Prevent infinite loops
    let mergeCount = 0; // Track number of merges in this cascade for gold calculation
    
    while (true){
      iterationCount++;
      if (iterationCount > maxIterations) {
        console.error('Merge cascade exceeded max iterations, forcing completion');
        break;
      }
      
      const poleArr = poles[index];
      // find top-first adjacent equal pair
      let pairIndex = -1;
      for (let i = poleArr.length - 1; i > 0; i--) {
        if (poleArr[i] && poleArr[i - 1] && poleArr[i].w === poleArr[i - 1].w) { pairIndex = i; break; }
      }
      if (pairIndex === -1) {
        console.log('No more merges found, breaking');
        break;
      }
    
    console.log('Found merge pair at index:', pairIndex, 'weights:', poleArr[pairIndex].w, poleArr[pairIndex-1].w);

    // animate both discs merging out with enhanced visual effects
    const poleDiv = gameDiv.children[index];
    const discs = poleDiv.querySelectorAll('.disc');
    const topEl = discs[pairIndex];
    const belowEl = discs[pairIndex - 1];
    if (!topEl || !belowEl) break;
    
    try {
      // Add glow effect to both discs before merging
      topEl.classList.add('merging');
      belowEl.classList.add('merging');
      
      // Stagger the merge-out animations slightly for better visual flow
      topEl.classList.add('merge-out');
      await new Promise(resolve => setTimeout(resolve, 25)); // Reduced delay for snappier effect
      belowEl.classList.add('merge-out');
      
      // Wait for both animations to complete with error handling
      await Promise.all([
        waitForAnimation(topEl).catch(err => console.log('Top animation error:', err)),
        waitForAnimation(belowEl).catch(err => console.log('Bottom animation error:', err))
      ]);
      
      // Remove glow effects
      topEl.classList.remove('merging');
      belowEl.classList.remove('merging');
    } catch (error) {
      console.log('Merge animation error:', error);
      // Clean up classes in case of error
      topEl.classList.remove('merging', 'merge-out');
      belowEl.classList.remove('merging', 'merge-out');
    }

    // commit merge to data model
    const a = poleArr[pairIndex];
    const b = poleArr[pairIndex - 1];
    const newW = a.w * 2; // weights are equal here
    const isBombMerge = a.bomb || b.bomb;
    poleArr.splice(pairIndex - 1, 2, { w: newW, bomb: isBombMerge });
    
    // Play merge sound effect for the newly created block
    soundManager.playMergeSound(newW);
    
    // Earn gold for this merge (increases by 1 for each merge in the cascade, multiplied by current stage)
    mergeCount++;
    const baseGoldEarned = mergeCount;
    // Stage 1: 1x multiplier, Stage 2+: 10x multiplier
    const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
    const goldEarned = baseGoldEarned * stageMultiplier;
    gold += goldEarned;
    updateGoldDisplay();
    console.log(`Merge ${mergeCount}: Earned ${formatNumber(goldEarned)} gold (${baseGoldEarned} × ${stageMultiplier}x multiplier) (Total: ${formatNumber(gold)})`);
    
    // Show gold earned animation
    showGoldEarned(goldEarned);
    
    // Play coin sound effect for earning gold
    soundManager.playCoinSound();
    
    // Update bomb conversion button state
    updateBombButtonIfGoldChanged();
    // Update trash button state
    updateTrashButtonIfGoldChanged();
    
    // Save game state after merge and gold earning
    console.log('🔄 Triggering save after merge...');
    saveGameState();

    if (isBombMerge){
      // Bomb merge - clear the entire stack
      await animateClearPoleWithFallingBlock(index, pairIndex - 1, newW);
      // after animation, pole is cleared; continue which will break
      continue;
    }
    
      // Check if this merge unlocks a new stack (stage progression)
  if (newW === currentTargetBlockSize * 2){
    console.log(`Stage progression triggered! Merged to ${newW}, target was ${currentTargetBlockSize}`);
    // Check if this merge unlocks a new block size for future drops BEFORE stage progression
    checkForNewBlockSize(newW);
    // Stage progression: keep the merged block, clear the rest of the stack
    await animateStageProgression(index, pairIndex - 1, newW);
    // Check if we should add a new stack
    checkForNewStack();
    // after animation, pole has only the merged block; continue which will break
    continue;
  }

    // Check if this merge unlocks a new block size for future drops
    checkForNewBlockSize(newW);
    
    // re-render and pop-in the new merged disc with enhanced effects
    render();
    const poleDivAfter = gameDiv.children[index];
    const discsAfter = poleDivAfter.querySelectorAll('.disc');
    const mergedEl = discsAfter[pairIndex - 1];
    if (mergedEl){
      try {
        // Add glow effect for the new merged block
        mergedEl.classList.add('merging');
        mergedEl.classList.add('merge-in');
        await waitForAnimation(mergedEl);
        mergedEl.classList.remove('merge-in');
        mergedEl.classList.remove('merging');
      } catch (error) {
        console.log('Merge-in animation error:', error);
        // Clean up classes in case of error
        mergedEl.classList.remove('merging', 'merge-in');
      }
    }
    
    console.log('Merge iteration completed, checking for more merges...');
    
    // Re-render to ensure DOM is up to date before next iteration
    // Note: This render call is now conditional to prevent excessive rendering
    if (gameDiv.children.length !== 4) {
      console.warn('Pole count mismatch detected, re-rendering...');
      render();
    }
  }
  
  console.log('Merge cascade completed for pole:', index);
  
  // Re-enable hover effects and pointer events after the cascade is complete
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = '';
    poleDiv.classList.remove('no-hover');
    console.log('Re-enabled hover effects for pole:', poleDiv);
  });
  
  } finally {
    clearTimeout(globalTimeout);
  }
}

function checkGameOver(){
  if (!hasAnyMove(nextQueue[0])){
    if (aiEnabled) toggleAI(false);
    showGameOver();
  }
}

function showGameOver(){
  // Show game over button overlay centered on screen with fade-in effect
  const gameOverButton = document.getElementById('gameOverButton');
  if (gameOverButton) {
    // Small delay to make the fade-in more noticeable
    setTimeout(() => {
      gameOverButton.classList.add('show');
    }, 200);
  }
  
      // Add glowing effect to the ➕ button to guide user to start new game
  const addBtn = document.getElementById('addBtn');
  if (addBtn) {
    addBtn.classList.add('game-over-glow');
  }
  
  // Reset bomb selection state when game over is reached
  bombSelected = false;
  
  // Note: Pole interactions are no longer disabled to allow players to examine the final state
  
  // Save final game state when game over is reached
  console.log('🔄 Triggering final save at game over...');
  saveGameState();
}



function resetGame(isFreshGame = true){
  // Hide game over button overlay
  const gameOverButton = document.getElementById('gameOverButton');
  if (gameOverButton) {
    gameOverButton.classList.remove('show');
  }
  
      // Remove glowing effect from the ➕ button
  const addBtn = document.getElementById('addBtn');
  if (addBtn) {
    addBtn.classList.remove('game-over-glow');
  }
  
  poles = [[],[],[],[]];
  score = 0;
  gold = 0; // Reset gold counter
  blocksDropped = 0; // Reset blocks dropped counter
  currentTargetBlockSize = STARTING_BLOCK_SIZE; // Reset target block size
  currentStackCapacity = MAX_HEIGHT; // Reset stack capacity
  currentStage = 1; // Reset stage counter
  
  // Only reset button costs if this is a fresh game (not a UI reset)
  if (isFreshGame) {
    // Reset bomb conversion button state
    bombConversionCost = 25;
    bombConversionPresses = 0;
    lastGoldAmount = 0; // Reset tracked gold amount to force button state update
    bombSelected = false; // Reset bomb selection state
    previousBombCost = 25; // Reset previous bomb cost
    
    // Reset trash button state
    trashButtonCost = 25;
    trashButtonPresses = 0;
  }
  
  // Update cost displays after reset (only if costs were actually reset)
  if (isFreshGame) {
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostEl) {
      trashCostEl.textContent = formatNumber(trashButtonCost);
    }
    if (bombCostElMobile) {
      bombCostElMobile.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostElMobile) {
      trashCostElMobile.textContent = formatNumber(trashButtonCost);
    }
  }
  
  // Reset weights and probabilities to initial state
  weights = [1, 2];
  
  // Reset decay factor to default for fresh games
  if (isFreshGame) {
    currentActiveDecayFactor = PROBABILITY_DECAY_FACTOR;
  }
  
  // Let updateProbabilityDistribution calculate the correct initial probabilities
  updateProbabilityDistribution();
  
  nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
  placing = false;
  
  // Re-enable hover effects and pointer events on all poles
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = '';
    poleDiv.classList.remove('no-hover');
  });
  
  // Reset custom block mode
  customBlockMode = false;
  
  // Reset speed to default (Medium)
  currentSpeed = 2;
  updateAnimationSpeed();
  
  updateStackHeight();
  updateScoreDisplay();
  updateGoldDisplay();
  render();
  
  // Clear saved game after reset
  clearGameSave();
}

// ------------------
// AI logic: simplified to focus on core priorities:
// 1. MERGING - If a merge can be made, do it immediately
// 2. CLEAN STACKS - Place blocks on next size up (16 on 32, 8 on 16, etc.)
// 3. NEXT CLOSEST - Place on closest larger size when optimal isn't available
// 4. BOMB STRATEGY - Clean up messy stacks, avoid disrupting valuable ones
// 5. MINIMAL DISRUPTION - Only disrupt when necessary, prefer empty poles
// ------------------
function topOf(pole){
  return pole.length === 0 ? null : pole[pole.length - 1];
}

function canPlaceOnPole(pieceOrWeight, pole){
  const weight = typeof pieceOrWeight === 'number' ? pieceOrWeight : pieceOrWeight.w;
  const top = topOf(pole);
  return pole.length < currentStackCapacity || (top && top.w === weight);
}

function hasAnyMove(pieceOrWeight){
  return poles.some(p => canPlaceOnPole(pieceOrWeight, p));
}

async function animateNextQueueAdvance(queueAlreadyModified = false){
  // add consume animation to current
  const items = nextContainer.querySelectorAll('.next-disc');
  const current = items[0];
  const second = items[1];
  const third = items[2];
  if (current) current.classList.add('consume-out');
  if (second) second.classList.add('shift-left');
  if (third) third.classList.add('shift-left');

  // wait for ALL animations to complete before proceeding
  const animations = [];
  if (current) animations.push(waitForAnimation(current));
  if (second) animations.push(waitForAnimation(second));
  if (third) animations.push(waitForAnimation(third));
  
  // Wait for all animations to complete
  await Promise.all(animations);

  // Only update queue data if it hasn't already been modified
  if (!queueAlreadyModified) {
    // Reset bomb selection state when the queue advances (bomb was placed)
    bombSelected = false;
    
    nextQueue.shift();
    nextQueue.push(getRandomPiece());
  }
  
  renderNext();
  
  // Update button states since queue changed
  updateBombButtonIfGoldChanged();
  updateTrashButtonIfGoldChanged();
}

function getElementPageRect(el){
  const r = el.getBoundingClientRect();
  return { left: r.left + window.scrollX, top: r.top + window.scrollY, width: r.width, height: r.height };
}



async function animateStageProgression(index, mergedIndex, weight){
  // Render so the merged block exists in the DOM
  render();
  const poleDiv = gameDiv.children[index];
  const discs = poleDiv.querySelectorAll('.disc');
  const mergedEl = discs[mergedIndex];
  if(!mergedEl){
    poles[index] = [];
    render();
    return;
  }

  // Let the new block behave like a normal merge result first
  mergedEl.classList.add('merge-in');
  await waitForAnimation(mergedEl);
  mergedEl.classList.remove('merge-in');

  // Now treat the target block like a bomb - make it explode and clear the entire stack
  const allDiscs = Array.from(poleDiv.querySelectorAll('.disc'));
  
  // Check if animations are disabled (speed = 0)
  const animationSpeed = parseFloat(document.documentElement.style.getPropertyValue('--animation-speed') || '1');
  const isInstantAnimation = animationSpeed === 0;
  
  if (isInstantAnimation) {
    // Instant animation - immediately hide all blocks
    allDiscs.forEach(d => {
      d.style.transform = 'scale(0.8)';
      d.style.opacity = '0';
      d.style.filter = 'brightness(0.8) saturate(0.9)';
    });
  } else {
    // Start the explosion from the merged block (target location) and propagate outward in both directions
    const targetIndex = mergedIndex; // The target block location
    
    // First, apply the bomb explosion effect to the target block itself
    const targetDisc = allDiscs[targetIndex];
    if (targetDisc) {
      targetDisc.classList.add('bomb-explosion');
      // Play stage up sound effect for the stage progression
      soundManager.playStageProgressionSound();
    }
    
    // Then apply the shockwave effect to other blocks with decreasing intensity
    for (let i = 0; i < allDiscs.length; i++) {
      if (i === targetIndex) continue; // Skip the target block, it already has explosion effect
      
      const disc = allDiscs[i];
      // Calculate distance from target location for wave propagation
      const distanceFromTarget = Math.abs(i - targetIndex);
      // Add a small delay to create the wave effect, starting from target location
      const delay = distanceFromTarget * 40; // 40ms delay per block distance for the ripple effect (faster)
      
      setTimeout(() => {
        disc.classList.add('bomb-ripple');
        // No more individual sound effects - just visual ripple effect
      }, delay);
    }
    
    // Wait for the entire explosion animation to complete
    const totalAnimationTime = Math.max(...Array.from({length: allDiscs.length}, (_, i) => 
      Math.abs(i - targetIndex) * 40 + 350
    )); // Max delay + 350ms animation duration (faster)
    await new Promise(resolve => setTimeout(resolve, totalAnimationTime));
    
    // Clean up the explosion and ripple classes
    allDiscs.forEach(d => {
      d.classList.remove('bomb-explosion');
      d.classList.remove('bomb-ripple');
    });
  }

  // Clear the entire pole
  poles[index] = [];
  
  // Now create the new target block
  const newBlock = { w: weight, bomb: false };
  poles[index].push(newBlock);
  
  // Re-render to show the cleared stack with the new target block
  render();
}

async function animateClearPoleWithFallingBlock(index, mergedIndex, weight){
  // Render so the merged block exists in the DOM
  render();
  const poleDiv = gameDiv.children[index];
  const discs = poleDiv.querySelectorAll('.disc');
  const mergedEl = discs[mergedIndex];
  if(!mergedEl){
    poles[index] = [];
    render();
    return;
  }

  // Bombs no longer give gold rewards when clearing stacks



  // Let the new block behave like a normal merge result first
  mergedEl.classList.add('merge-in');
  await waitForAnimation(mergedEl);
  mergedEl.classList.remove('merge-in');

  // Create a shockwave ripple effect that propagates through the stack
  const allDiscs = Array.from(poleDiv.querySelectorAll('.disc'));
  
  // Check if animations are disabled (speed = 0)
  const animationSpeed = parseFloat(document.documentElement.style.getPropertyValue('--animation-speed') || '1');
  const isInstantAnimation = animationSpeed === 0;
  
  if (isInstantAnimation) {
    // Instant animation - immediately hide all blocks
    allDiscs.forEach(d => {
      d.style.transform = 'scale(0.8)';
      d.style.opacity = '0';
      d.style.filter = 'brightness(0.8) saturate(0.9)';
    });
  } else {
    // Start the explosion from the merged block (bomb location) and propagate outward in both directions
    const bombIndex = mergedIndex; // The bomb merge location
    
    // First, apply the bomb explosion effect to the bomb block itself
    const bombDisc = allDiscs[bombIndex];
    if (bombDisc) {
      bombDisc.classList.add('bomb-explosion');
      // Play bomb sound effect for the initial bomb explosion
      soundManager.playBombSound();
    }
    
    // Then apply the shockwave effect to other blocks with decreasing intensity
    for (let i = 0; i < allDiscs.length; i++) {
      if (i === bombIndex) continue; // Skip the bomb block, it already has explosion effect
      
      const disc = allDiscs[i];
      // Calculate distance from bomb location for wave propagation
      const distanceFromBomb = Math.abs(i - bombIndex);
      // Add a small delay to create the wave effect, starting from bomb location
      const delay = distanceFromBomb * 40; // 40ms delay per block distance for the ripple effect (faster)
      
      setTimeout(() => {
        disc.classList.add('bomb-ripple');
        // No more individual sound effects - just visual ripple effect
      }, delay);
    }
    
    // Wait for the entire explosion animation to complete
    const totalAnimationTime = Math.max(...Array.from({length: allDiscs.length}, (_, i) => 
      Math.abs(i - bombIndex) * 40 + 350
    )); // Max delay + 350ms animation duration (faster)
    await new Promise(resolve => setTimeout(resolve, totalAnimationTime));
    
    // Clean up the explosion and ripple classes
    allDiscs.forEach(d => {
      d.classList.remove('bomb-explosion');
      d.classList.remove('bomb-ripple');
    });
  }

  // Clear pole and re-render
  poles[index] = [];
  render();
}

function choosePoleFor(pieceOrWeight){
  console.log('choosePoleFor called with:', pieceOrWeight);
  let avail = poles.map((p,i)=> ({p,i})).filter(x=> canPlaceOnPole(pieceOrWeight, x.p));
  console.log('Available poles:', avail);
  if(avail.length === 0) {
    console.log('No available poles found');
    return null;
  }
  
  const piece = typeof pieceOrWeight === 'number' ? { w: pieceOrWeight, bomb: false } : pieceOrWeight;
  const isBomb = piece.bomb;
  
  // Helper function to check if a stack is "messy" (order disrupted)
  function isStackMessy(pole) {
    if (pole.length < 2) return false;
    for (let i = pole.length - 1; i > 0; i--) {
      if (pole[i].w >= pole[i-1].w) return true; // Order is disrupted
    }
    return false;
  }
  
  // Helper function to get stack height
  function getStackHeight(pole) {
    return pole.length;
  }
  
  // Helper function to get total point value of a stack
  function getStackValue(pole) {
    return pole.reduce((sum, disc) => sum + disc.w, 0);
  }
  
  // Helper function to check if placing this piece would create a merge
  function wouldCreateMerge(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w === piece.w;
  }
  
  // Helper function to check if placing this piece would be on a block exactly 1 size above
  function wouldBeOnExactSize(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w === piece.w * 2;
  }
  
  // Helper function to check if placing this piece would be on a larger block (but not exact size)
  function wouldBeOnLargerBlock(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w > piece.w;
  }
  
  // Check for bomb in queue (special case 1.5)
  const hasBombInQueue = nextQueue.some(p => p.bomb);
  const isBombMatch = hasBombInQueue && nextQueue.some(p => p.bomb && p.w === piece.w);
  
  if (!isBomb) {
    // NORMAL BLOCKS LOGIC
    
    // Priority 1: Merges (100% override)
    const mergeOptions = avail.filter(x => wouldCreateMerge(x.p, piece));
    if (mergeOptions.length > 0) {
      return mergeOptions[0].i;
    }
    
    // Priority 1.5: Avoid placing normal blocks on stacks with bombs anywhere in them
    // This prevents cutting off bombs from being able to merge and clear the stack
    const bombAvoidanceOptions = avail.filter(x => {
      if (x.p.length === 0) return true; // Empty stack is fine
      
      // Check if there's a bomb anywhere in the stack
      const hasBombInStack = x.p.some(disc => disc.bomb);
      
      if (hasBombInStack) {
        // If there's a bomb in the stack, only allow placement if:
        // 1. The block is smaller than the bomb it would be placed on, OR
        // 2. We're placing on an empty stack (which shouldn't happen here, but safety check)
        const top = x.p[x.p.length - 1];
        if (top.bomb) {
          // Placing on a bomb - only allow if block is smaller
          return piece.w < top.w;
        } else {
          // Placing above a bomb - this would cut off the bomb, so never allow larger blocks
          return piece.w < top.w;
        }
      }
      
      return true; // No bomb in stack, so placement is fine
    });
    
    // If we have no valid options after bomb avoidance, fall back to all available
    if (bombAvoidanceOptions.length === 0) {
      // This should rarely happen, but if it does, we'll use the original avail list
      console.warn('AI: No bomb-avoidance options available, using fallback');
    } else {
      // Use the filtered options for the rest of the logic
      avail = bombAvoidanceOptions;
    }
    
    // Priority 2: Special case - bomb match in queue
    if (isBombMatch) {
      const messyStacks = avail.filter(x => isStackMessy(x.p));
      if (messyStacks.length > 0) {
        return messyStacks[0].i;
      }
    }
    
    // Priority 3: Place on block exactly 1 size above
    const exactSizeOptions = avail.filter(x => wouldBeOnExactSize(x.p, piece));
    if (exactSizeOptions.length > 0) {
      // Prefer stacks with less height if multiple options
      exactSizeOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
      return exactSizeOptions[0].i;
    }
    
    // Priority 4: Place on larger block (but not exact size)
    const largerBlockOptions = avail.filter(x => wouldBeOnLargerBlock(x.p, piece));
    if (largerBlockOptions.length > 0) {
      // Prefer messy stacks, then by height
      const messyOptions = largerBlockOptions.filter(x => isStackMessy(x.p));
      const cleanOptions = largerBlockOptions.filter(x => !isStackMessy(x.p));
      
      if (messyOptions.length > 0) {
        // Choose messiest stack among messy options
        messyOptions.sort((a, b) => {
          // Count how many order violations each stack has
          const getViolations = (pole) => {
            let violations = 0;
            for (let i = pole.length - 1; i > 0; i--) {
              if (pole[i].w >= pole[i-1].w) violations++;
            }
            return violations;
          };
          return getViolations(b.p) - getViolations(a.p); // More violations = messier
        });
        return messyOptions[0].i;
      } else {
        // All stacks are clean, choose by height
        cleanOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
        return cleanOptions[0].i;
      }
    }
    
    // Priority 5: Place on smaller block or empty stack
    const remainingOptions = avail.filter(x => !wouldBeOnLargerBlock(x.p, piece));
    if (remainingOptions.length > 0) {
      // Prefer messy stacks, then by height
      const messyOptions = remainingOptions.filter(x => isStackMessy(x.p));
      const cleanOptions = remainingOptions.filter(x => !isStackMessy(x.p));
      
      if (messyOptions.length > 0) {
        // Choose messiest stack among messy options
        messyOptions.sort((a, b) => {
          const getViolations = (pole) => {
            let violations = 0;
            for (let i = pole.length - 1; i > 0; i--) {
              if (pole[i].w >= pole[i-1].w) violations++;
            }
            return violations;
          };
          return getViolations(b.p) - getViolations(a.p);
        });
        return messyOptions[0].i;
      } else {
        // All stacks are clean, choose by height
        cleanOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
        return cleanOptions[0].i;
      }
    }
    
  } else {
    // BOMB LOGIC
    
    // Priority 1: Tallest, messiest stack
    const messyStacks = avail.filter(x => isStackMessy(x.p));
    if (messyStacks.length > 0) {
      // Sort by height first, then by messiness
      messyStacks.sort((a, b) => {
        const heightDiff = getStackHeight(b.p) - getStackHeight(a.p);
        if (Math.abs(heightDiff) > 0) return heightDiff;
        
        // If heights are equal, sort by messiness
        const getViolations = (pole) => {
          let violations = 0;
          for (let i = pole.length - 1; i > 0; i--) {
            if (pole[i].w >= pole[i-1].w) violations++;
          }
          return violations;
        };
        return getViolations(b.p) - getViolations(a.p);
      });
      return messyStacks[0].i;
    }
    
    // Priority 2: Must place on clean stack - choose lowest total value
    const cleanStacks = avail.filter(x => !isStackMessy(x.p));
    if (cleanStacks.length > 0) {
      cleanStacks.sort((a, b) => getStackValue(a.p) - getStackValue(b.p));
      return cleanStacks[0].i;
    }
  }
  
  // Fallback: return first available pole
  return avail[0].i;
}

function aiStep(){
  console.log('AI: aiStep called, placing:', placing, 'aiEnabled:', aiEnabled);
  
  if(placing) {
    console.log('AI: Waiting for placement to complete...');
    return;
  }
  
  // Safety check: if placing has been true for too long, reset it
  if (placing && Date.now() - lastPlacementTime > 10000) { // 10 second timeout
    console.warn('AI: Placement timeout detected, resetting placing flag');
    placing = false;
    
    // Re-enable hover effects and pointer events on all poles
    const allPoles = Array.from(gameDiv.children);
    allPoles.forEach(poleDiv => {
      poleDiv.style.pointerEvents = '';
      poleDiv.classList.remove('no-hover');
    });
  }
  
  // if game over, nothing to do
  const pick = choosePoleFor(nextQueue[0]);
  if(pick === null) { 
    console.log('AI: No valid move available, checking game over');
    checkGameOver(); 
    return; 
  }
  
  console.log('AI: Making move on pole', pick, 'with piece', nextQueue[0]);
  placeOnPole(pick);
}

// Ensure merge sound button is properly initialized with current state
const initMergeSoundBtn = document.getElementById('mergeBtn');
if (initMergeSoundBtn) {
  const usePopSounds = soundManager.getMergeSoundType();
  initMergeSoundBtn.textContent = '🎵'; // Always show music note
  initMergeSoundBtn.title = usePopSounds ? 'Switch to musical merge sounds' : 'Switch to pop merge sounds';
}



// Initial render will happen after game state loading

// Initialize animation speed and stack height
updateAnimationSpeed();
updateStackHeight();

// Initialize displays with proper formatting
updateScoreDisplay();
updateGoldDisplay();

// Set up auto-save system
console.log('Setting up auto-save system...');
setupAutoSave();
console.log('Auto-save system initialized');

// Safety check: ensure we start with exactly 4 poles
ensureCorrectPoleCount();

// Initialize debug pane - Block grid interface
document.addEventListener('DOMContentLoaded', () => {
  // Set initial selection to "No Block" option
  const noBlockOption = document.querySelector('.block-item[data-value="none"]');
  if (noBlockOption) {
    noBlockOption.classList.add('selected');
    customBlockSize = null;
    customBlockMode = false;
  }
  

  
  // Initial render is handled after game state loading
});

if (bombToggle && bombStatus) {
  bombToggle.checked = false;
  bombStatus.textContent = 'No';
  customBlockBomb = false;
}

// Initialize debug auto-play controls
if (debugSpeedSlider) {
  debugSpeedSlider.value = currentSpeed;
}
updateDebugSpeedLabel();
updateAnimationSpeed();

// Initialize bomb conversion button state
updateBombConversionButtonState();

// Handle window resize for mobile responsiveness
window.addEventListener('resize', () => {
  console.log('Window resized to', window.innerWidth, 'x', window.innerHeight, '- updating stack heights');
  updateStackHeight();
});

// GitHub Pages redirect fix - if we're on the wrong page, redirect to the game
(function() {
  // Check if we're on the right page by looking for game elements
  if (!document.getElementById('game')) {
    // We're probably on the README page, redirect to the game
    window.location.href = window.location.href;
  }
})();

// Global safety check to ensure we always have exactly 4 poles
function ensureCorrectPoleCount() {
  if (poles.length !== 4) {
    console.error(`CRITICAL ERROR: Global pole count check found ${poles.length} poles instead of 4! Resetting to 4 poles.`);
    poles = [[],[],[],[]];
    // Force a re-render to fix the display
    render();
  }
  
  // Also check the DOM to ensure we have exactly 4 pole elements
  if (gameDiv && gameDiv.children.length !== 4) {
    console.error(`CRITICAL ERROR: DOM contains ${gameDiv.children.length} pole elements instead of 4! Re-rendering...`);
    render();
  }
}

// Run safety check every 5 seconds
setInterval(ensureCorrectPoleCount, 5000);

function testProbabilityDistribution() {
  console.log('=== Testing Probability Distribution ===');
  console.log('Current weights:', weights);
  console.log('Current probabilities:', probabilities);
  
  // Simulate 1000 random selections to test distribution
  const results = {};
  const iterations = 1000;
  
  for (let i = 0; i < iterations; i++) {
    const weight = getRandomWeight();
    results[weight] = (results[weight] || 0) + 1;
  }
  
  // Create the results table HTML
  let tableHTML = `
    <table class="prob-test-table">
      <thead>
        <tr>
          <th>Block</th>
          <th>Expected</th>
          <th>Actual</th>
          <th>Difference</th>
        </tr>
      </thead>
      <tbody>
  `;
  
  let totalExpected = 0;
  let totalActual = 0;
  
  for (const weight of weights) {
    const count = results[weight] || 0;
    const actualProb = count / iterations;
    const expectedProb = probabilities[weights.indexOf(weight)];
    const difference = Math.abs(actualProb - expectedProb);
    
    totalExpected += expectedProb;
    totalActual += actualProb;
    
    tableHTML += `
      <tr>
        <td class="block-value">${weight}</td>
        <td class="expected">${(expectedProb * 100).toFixed(2)}%</td>
        <td class="actual">${(actualProb * 100).toFixed(2)}%</td>
        <td class="difference">${(difference * 100).toFixed(2)}%</td>
      </tr>
    `;
    
    // Also log to console for debugging
    console.log(`Block ${weight}: Expected ${(expectedProb * 100).toFixed(2)}%, Got ${(actualProb * 100).toFixed(2)}%, Diff: ${(difference * 100).toFixed(2)}%`);
  }
  
  tableHTML += `
      </tbody>
    </table>
    
    <div class="prob-test-summary">
      <div class="total">Total Probability: ${(totalExpected * 100).toFixed(2)}% (Expected) vs ${(totalActual * 100).toFixed(2)}% (Actual)</div>
    </div>
  `;
  
  // Populate the modal content
  const contentDiv = document.getElementById('probTestContent');
  if (contentDiv) {
    contentDiv.innerHTML = tableHTML;
  }
  
  // Show the modal
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.remove('hidden');
  }
  
  console.log('=== End Test ===');
}

// Modal functionality
function showProbabilityTestModal() {
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.remove('hidden');
  }
}

function hideProbabilityTestModal() {
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.add('hidden');
  }
}

function logProbabilityState() {
  console.log('=== Current Probability State ===');
  console.log(`Total blocks available: ${weights.length}`);
  console.log('Block | Weight | Probability | Cumulative');
  console.log('------|--------|-------------|------------');
  
  let cumulative = 0;
  for (let i = 0; i < weights.length; i++) {
    cumulative += probabilities[i];
    console.log(`${i.toString().padStart(5)} | ${weights[i].toString().padStart(6)} | ${(probabilities[i] * 100).toFixed(2).padStart(11)}% | ${(cumulative * 100).toFixed(2).padStart(10)}%`);
  }
  
  console.log(`Total probability: ${(cumulative * 100).toFixed(2)}%`);
  console.log('=====================================');
}

// Test probabilities button
const testProbBtn = document.getElementById('testProbBtn');
testProbBtn.addEventListener('click', testProbabilityDistribution);

// Test audio context button
const testAudioContextBtn = document.getElementById('testAudioContextBtn');
testAudioContextBtn.addEventListener('click', () => {
  soundManager.testAudioContextState();
});

// Cascade test button
const cascadeTestBtn = document.getElementById('cascadeTestBtn');
cascadeTestBtn.addEventListener('click', () => {
  // Clear the first column (pole 0)
  poles[0] = [];
  
  // Create a perfect cascade stack from 512 to 1
  // This will create the largest possible cascade when blocks are dropped
  const cascadeValues = [512, 256, 128, 64, 32, 16, 8, 4, 2, 1];
  
  cascadeValues.forEach(value => {
    poles[0].push({ w: value, bomb: false });
  });
  
  // Re-render the game to show the new stack
  render();
  
  // Save game state after cascade test setup
  console.log('🔄 Triggering save after cascade test setup...');
  saveGameState();
  
  console.log('Cascade test stack created: 512 → 256 → 128 → 64 → 32 → 16 → 8 → 4 → 2 → 1');
});

// Probability test modal close button
const probTestClose = document.getElementById('probTestClose');
if (probTestClose) {
  probTestClose.addEventListener('click', hideProbabilityTestModal);
}

// Close probability test modal when clicking outside
const probTestModal = document.getElementById('probTestModal');
if (probTestModal) {
  probTestModal.addEventListener('click', (e) => {
    if (e.target === probTestModal) {
      hideProbabilityTestModal();
    }
  });
}



// Add keyboard support for probability test modal
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (probTestModal && !probTestModal.classList.contains('hidden')) {
      hideProbabilityTestModal();
    }
  }
});

// Initialize the game after all functions are defined
console.log('🎮 Starting game initialization...');

try {
  // Set up initial probability distribution for the starting block sizes (1 and 2)
  console.log('📊 Setting up initial probability distribution...');
  updateProbabilityDistribution();
  console.log('✅ Probability distribution initialized');

  // Initialize next queue after probability distribution is set up
  console.log('🔄 Initializing next queue...');
  nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
  console.log('✅ Next queue initialized:', nextQueue);

  console.log('🎮 Game initialized with probability system');
  
  // Now try to load saved game state AFTER everything is initialized
  console.log('=== ATTEMPTING TO LOAD SAVED GAME STATE ===');
  const gameLoaded = loadGameState();
  console.log('Load result:', gameLoaded ? 'SUCCESS' : 'FAILED - starting fresh game');
  
  // Force a render after loading (or if loading failed)
  console.log('🔄 Rendering game display...');
  render();
  renderNext();
  console.log('✅ Game display rendered');
  
  // Proactively check audio context state after game initialization
  console.log('🔊 Checking audio context state...');
  if (soundManager.initialized) {
    soundManager.ensureAudioContextActive().then(() => {
      console.log('✅ Audio context is active and ready');
    }).catch(error => {
      console.warn('⚠️ Audio context check failed:', error);
    });
  }
  
} catch (error) {
  console.error('❌ Error during game initialization:', error);
  console.error('Error stack:', error.stack);
}

</script>
</body>
</html>
