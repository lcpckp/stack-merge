<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Stack Merge</title>
<link rel="icon" type="image/png" href="favicon.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Quantico:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
  :root{ 
    --bg:#0f172a; 
    --panel:#1e293b; 
    --text:#f8fafc; 
    --font-family: 'Quantico', monospace;
    
    /* Theme colors are now handled dynamically via JavaScript */
  }
  body { 
    margin:0; 
    font-family: var(--font-family); 
    background:var(--bg); 
    color:var(--text); 
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    height: 100vh; /* Lock page height to exactly viewport height */
    overflow: hidden; /* Prevent any scrolling */
  }
  
  /* Development mode - enable scrolling for debug access */
  body.development-mode {
    overflow: auto; /* Allow scrolling in development */
    min-height: 100vh; /* Ensure minimum height while allowing content to expand */
  }
  
  /* Ensure debug button is accessible on mobile in development */
  body.development-mode #debugBtn {
    position: relative;
    z-index: 1000;
    margin-bottom: 20px; /* Add some bottom margin for mobile scrolling */
  }
  .topbar { width:100%; max-width:1200px; display:flex; flex-direction:column; align-items:center; gap:24px; padding:24px 16px 8px; box-sizing:border-box; }
  h1 { margin:0; font-size:36px; font-weight:700; text-align:center; font-family: var(--font-family); }
  
  /* Title section styling */
  .title-section { 
    display: flex; 
    flex-direction: row; 
    align-items: center; 
    width: 100%;
    position: relative;
    margin-top: 24px;
    margin-bottom: 24px;
  }
  
  /* Left section - positioned to the left of center */
  .title-section .left-section {
    position: absolute;
    right: calc(50% + 180px);
    display: flex;
    align-items: center;
    gap: 16px;
  }
  
  /* Center section - absolutely centered title */
  .title-section .center-section {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
  }
  
  /* Right section - positioned to the right of center */
  .title-section .right-section {
    position: absolute;
    left: calc(50% + 180px);
    display: flex;
    align-items: center;
    gap: 16px;
  }
  
  /* Title button styling */
  .title-btn {
    background: var(--panel);
    color: var(--text);
    border: 1px solid #475569;
    width: 48px;
    height: 48px;
    border-radius: 10px;
    font-weight: 700;
    font-size: 24px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    font-family: var(--font-family);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  
  .title-btn:hover {
    background: #334155;
    border-color: #64748b;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(0,0,0,0.25);
  }
  
  .title-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
  }
  
  /* Glowing ➕ button after game over */
  .title-btn.game-over-glow {
    box-shadow: 0 0 8px rgba(14, 165, 233, 0.6), 0 0 16px rgba(14, 165, 233, 0.4), 0 0 24px rgba(14, 165, 233, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    animation: breatheGlow 1.5s ease-in-out infinite;
    border-color: #3b82f6;
  }
  
  /* Glowing ❔ button for new players */
  .title-btn.help-glow {
    box-shadow: 0 0 8px rgba(239, 68, 68, 0.6), 0 0 16px rgba(239, 68, 68, 0.4), 0 0 24px rgba(239, 68, 68, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    animation: breatheGlowRed 1.5s ease-in-out infinite;
    border-color: #ef4444;
  }
  
  /* Glowing ⚙️ button when new theme is unlocked */
  .title-btn.settings-glow {
    box-shadow: 0 0 8px rgba(34, 197, 94, 0.6), 0 0 16px rgba(34, 197, 94, 0.4), 0 0 24px rgba(34, 197, 94, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    animation: breatheGlowGreen 1.5s ease-in-out infinite;
    border-color: #22c55e;
  }
  
  /* Sound button states */
  .title-btn#soundBtn {
    transition: all 0.2s ease;
  }
  
  .title-btn#soundBtn:hover {
    transform: scale(1.05);
  }
  

  
  @keyframes breatheGlow {
    0%, 100% { 
      box-shadow: 0 0 8px rgba(14, 165, 233, 0.6), 0 0 16px rgba(14, 165, 233, 0.4), 0 0 24px rgba(14, 165, 233, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    }
    50% { 
      box-shadow: 0 0 12px rgba(14, 165, 233, 0.8), 0 0 20px rgba(14, 165, 233, 0.6), 0 0 28px rgba(14, 165, 233, 0.4), 0 3px 0 rgba(0,0,0,0.25);
    }
  }
  
  @keyframes breatheGlowRed {
    0%, 100% { 
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.6), 0 0 16px rgba(239, 68, 68, 0.4), 0 0 24px rgba(239, 68, 68, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    }
    50% { 
      box-shadow: 0 0 12px rgba(239, 68, 68, 0.8), 0 0 20px rgba(239, 68, 68, 0.6), 0 0 28px rgba(239, 68, 68, 0.4), 0 3px 0 rgba(0,0,0,0.25);
    }
  }
  
  @keyframes breatheGlowGreen {
    0%, 100% { 
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.6), 0 0 16px rgba(34, 197, 94, 0.4), 0 0 24px rgba(34, 197, 94, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    }
    50% { 
      box-shadow: 0 0 12px rgba(34, 197, 94, 0.8), 0 0 20px rgba(34, 197, 94, 0.6), 0 0 28px rgba(34, 197, 94, 0.4), 0 3px 0 rgba(0,0,0,0.25);
    }
  }
  
  /* Mobile responsive sizing for title buttons */
  @media (max-width: 768px) {
    .title-btn {
      width: 38px;
      height: 38px;
      border-radius: 8px;
      font-size: 20px;
    }
    
    .title-section {
      gap: 16px;
    }
  }
  
  /* Mobile responsive spacing for title sections */
  @media (max-width: 768px) {
    .title-section .left-section {
      right: calc(50% + 110px);
      gap: 8px; /* Reduced gap between buttons on mobile */
    }
    
    .title-section .right-section {
      left: calc(50% + 110px);
      gap: 8px; /* Reduced gap between buttons on mobile */
    }
  }
  
  /* Extra small mobile devices - adjust title section spacing */
  @media (max-width: 480px) {
    .title-section {
      gap: 12px;
    }
    
    .title-btn {
      width: 36px;
      height: 36px;
      border-radius: 7px;
      font-size: 18px;
    }
    
    .title-section .left-section {
      gap: 8px; /* Slightly larger gap for better touch targets */
    }
    
    .title-section .right-section {
      gap: 8px; /* Slightly larger gap for better touch targets */
    }
  }
  
  /* Disable hover effects on mobile/touch devices */
  @media (hover: none) and (pointer: coarse) {
    .title-btn:hover {
      background: var(--panel);
      border-color: #475569;
      transform: none;
      box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    }
    
    .title-btn#soundBtn:hover {
      transform: none;
    }
    

    

  }
  

  
  /* Controls section styling */
  .controls { display:flex; align-items:center; gap:18px; }

  .game-info { display: flex; justify-content: center; gap: 48px; margin-top: 40px; /* Increased spacing between title and game info */ }
  .score-display { display:flex; flex-direction:column; align-items:center; gap:12px; }
  .score-label { font-size:18px; opacity:0.9; font-family: var(--font-family); }
  .next { display:flex; flex-direction:column; align-items:center; gap:12px; }
  .next .label { font-size:18px; opacity:0.9; font-family: var(--font-family); }
  .next-row { display:flex; align-items:center; gap:12px; }
  .next-disc { width:108px; height:45px; border-radius:9px; display:flex; align-items:center; justify-content:center; font-weight:600; font-size:24px; box-shadow:0 3px 0 rgba(0,0,0,0.25); transition: transform calc(0.18s * var(--animation-speed, 1)) ease; font-family: var(--font-family); transform-origin: center center; }
  .next-disc.current { outline:3px solid #fff; outline-offset:3px; }
  .next-disc.consume-out { 
    animation: nextConsume calc(0.18s * var(--animation-speed, 1)) ease forwards; 
    transition: none; /* Disable transition during animation to prevent conflicts */
  }
  @keyframes nextConsume {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0.85); opacity: 0; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .next-disc.consume-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.85); opacity: 0; }
  .next-disc.shift-left { transform: translateX(-120px); }
  
  /* Instant animations when speed is 0 (Blazing) */
  .next-disc.shift-left[style*="--animation-speed: 0"] { transform: translateX(-120px); }


  
  /* Score value styling to match other modules */
  .score-value { 
    background: var(--panel); 
    color: var(--text); 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 24px; 
    min-width: 70px; 
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
  }
  
  /* Score star emoji styling as a badge in top left corner */
  .score-star {
    position: absolute;
    top: -12px;
    left: -12px;
    font-size: 28px;
    opacity: 1;
    z-index: 1;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }
  
  .score-text {
    position: relative;
    z-index: 2;
    font-size: 28px;
    font-weight: 600;
    line-height: 1;
    font-family: var(--font-family);
  }

  /* Gold display styling to match score display */
  .gold-display { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 12px; 
  }
  .gold-label { 
    font-size: 18px; 
    opacity: 0.9; 
    font-family: var(--font-family);
  }
  .gold-value { 
    background: #FCD34D; 
    color: #000; 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 24px; 
    min-width: 70px; 
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
  }
  
  /* Gold emoji styling as a badge in top left corner */
  .gold-emoji {
    position: absolute;
    top: -12px;
    left: -12px;
    font-size: 28px;
    opacity: 1;
    z-index: 1;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }
  
  .gold-text {
    position: relative;
    z-index: 2;
    font-size: 28px !important;
    font-weight: 600;
    line-height: 1;
    font-family: var(--font-family);
  }
  
  /* Stage multiplier badge styling centered on lower edge of gold counter */
  .stage-multiplier-badge {
    position: absolute;
    bottom: -16px;
    left: 50%;
    transform: translateX(-50%);
    background: #dc2626;
    color: white;
    font-size: 12px;
    font-weight: 700;
    padding: 4px 6px;
    border-radius: 8px;
    border: 2px solid var(--bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 1;
    font-family: var(--font-family);
    min-width: 20px;
    text-align: center;
    line-height: 1;
    box-sizing: border-box;
    white-space: nowrap;
  }
  
  /* Stage multiplier badge pulse animation */
  .stage-multiplier-badge.pulse {
    animation: stageBadgePulse 0.6s ease-out;
  }
  
  @keyframes stageBadgePulse {
    0% { transform: translateX(-50%) scale(1); }
    50% { transform: translateX(-50%) scale(1.2); }
    100% { transform: translateX(-50%) scale(1); }
  }
  
  /* Score count pulse animation */
  .score-value.pulse {
    animation: scorePulse 0.3s ease-out;
  }
  
  @keyframes scorePulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  
  /* Gold earned animation */
  .gold-earned {
    position: fixed;
    color: #FCD34D;
    font-weight: 700;
    font-size: 20px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
    z-index: 1000;
    pointer-events: none;
    animation: goldEarned 1.2s ease-out forwards;
  }
  
  @keyframes goldEarned {
    0% {
      opacity: 0;
      transform: translateY(0) scale(0.8);
    }
    15% {
      opacity: 1;
      transform: translateY(-15px) scale(1.2);
    }
    70% {
      opacity: 1;
      transform: translateY(-45px) scale(1.1);
    }
    100% {
      opacity: 0;
      transform: translateY(-65px) scale(1);
    }
  }

  /* Personal best animation */
  .personal-best {
    position: fixed;
    color: #fbbf24;
    font-weight: 700;
    font-size: 18px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
    z-index: 1000;
    pointer-events: none;
    animation: personalBest 3s ease-out forwards;
  }
  
  @keyframes personalBest {
    0% {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.7);
    }
    20% {
      opacity: 1;
      transform: translate(-50%, calc(-50% - 8px)) scale(1.1);
    }
    40% {
      opacity: 1;
      transform: translate(-50%, calc(-50% - 12px)) scale(1);
    }
    100% {
      opacity: 0;
      transform: translate(-50%, calc(-50% - 30px)) scale(1);
    }
  }
  
  /* Gold count pulse animation */
  .gold-value.pulse {
    animation: goldPulse 0.3s ease-out;
  }
  
  @keyframes goldPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }

  /* Bomb conversion button pulse animation */
  .bomb-conversion-btn.pulse {
    animation: bombBtnPulse 0.3s ease-out;
  }
  
  @keyframes bombBtnPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  
  /* Trash button pulse animation */
  .trash-btn.pulse {
    animation: trashBtnPulse 0.3s ease-out;
  }
  
  @keyframes trashBtnPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }

  /* AI button styling to match score-value and interface */
  .ai-btn {
    background: var(--panel);
    color: var(--text);
    border: 1px solid #475569;
    padding: 12px 24px;
    border-radius: 9px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    font-family: var(--font-family);
  }
  .ai-btn:hover {
    background: #334155;
    border-color: #64748b;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(0,0,0,0.25);
  }
  .ai-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
  }
  


  .hidden { display:none !important; }

  /* Help modal */
  .modal-backdrop { 
    position:fixed; 
    inset:0; 
    background:rgba(0,0,0,0.6); 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    z-index:1000; 
    /* Ensure backdrop respects safe areas with extra buffer for mobile UI controls */
    padding: calc(env(safe-area-inset-top, 0px) + 20px) calc(env(safe-area-inset-left, 0px) + 16px) calc(env(safe-area-inset-bottom, 0px) + 20px) calc(env(safe-area-inset-right, 0px) + 16px);
    box-sizing: border-box;
  }
  .modal { 
    background:var(--panel); 
    color:var(--text); 
    width:min(720px, 92vw); 
    border-radius:16px; 
    padding:24px 28px; 
    box-shadow:0 15px 45px rgba(0,0,0,0.4); 
    font-family: var(--font-family); 
    /* Ensure modal respects safe areas with extra buffer for mobile UI controls */
    max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 120px);
  }
  .modal h2 { margin:0 0 12px; font-size:24px; font-family: var(--font-family); }
  .modal p, .modal li { font-size:16px; line-height:1.5; font-family: var(--font-family); }
  .modal ul { margin:12px 0 0 24px; padding:0; }
  .modal .actions { display:flex; justify-content:flex-end; margin-top:18px; }
  
  /* Mobile responsive sizing for help modal stage progression elements */
  @media (max-width: 768px) {
    /* Ensure modal is properly positioned on mobile with safe areas */
    .help-modal {
      max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 120px);
      margin: 0;
      padding: 20px;
      /* Ensure content is properly spaced from edges */
      box-sizing: border-box;
    }
    
    /* Ensure modal title has proper spacing and layout */
    .help-modal h2 {
      margin-top: 0 !important;
      padding-top: 0 !important;
      display: flex !important;
      justify-content: space-between !important;
      align-items: center !important;
      width: 100% !important;
    }

      /* High score display in help modal title */
  
  .help-modal .title-text {
    font-size: 1em !important;
    color: var(--text) !important;
    font-weight: 700 !important;
  }
  
  /* Stats button styling - Manual reset approach */
  .help-modal .stats-btn,
  .help-modal button.stats-btn,
  .help-modal #showStatsBtn {
    /* Manual reset of button defaults instead of all: unset */
    font-size: 0.8em !important;
    color: var(--text) !important;
    font-weight: 500 !important;
    margin: 0 !important;
    margin-left: auto !important;
    padding: 6px 12px !important;
    
    /* Background and border */
    background: #334155 !important;
    background-color: #334155 !important;
    background-image: none !important;
    border: 1px solid #475569 !important;
    border-radius: 8px !important;
    
    /* Layout and display */
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-sizing: border-box !important;
    vertical-align: middle !important;
    white-space: nowrap !important;
    text-align: center !important;
    line-height: 1 !important;
    
    /* Interaction */
    cursor: pointer !important;
    user-select: none !important;
    outline: none !important;
    text-decoration: none !important;
    
    /* Remove browser button styling */
    appearance: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    
    /* Effects */
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2) !important;
    transition: all 0.2s ease !important;
    font-family: var(--font-family) !important;
    
    /* Force dimensions */
    min-height: auto !important;
    min-width: auto !important;
    height: auto !important;
    width: auto !important;
  }

  /* Desktop-specific styling to override mobile styles */
  @media (min-width: 769px) {
    .help-modal .stats-btn,
    .help-modal button.stats-btn,
    .help-modal #showStatsBtn {
      font-size: 0.8em !important;
      padding: 6px 12px !important;
      background: #334155 !important;
      background-color: #334155 !important;
      border: 1px solid #475569 !important;
      border-color: #475569 !important;
      color: var(--text) !important;
      font-weight: 500 !important;
      font-family: var(--font-family) !important;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2) !important;
      border-radius: 8px !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      margin-left: auto !important;
      cursor: pointer !important;
      transition: all 0.2s ease !important;
      appearance: none !important;
      -webkit-appearance: none !important;
    }
  }
  
  .help-modal .stats-btn:hover,
  .help-modal button.stats-btn:hover,
  .help-modal #showStatsBtn:hover {
    background: #475569 !important;
    background-color: #475569 !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3) !important;
  }
  
  .help-modal .stats-btn:active,
  .help-modal button.stats-btn:active,
  .help-modal #showStatsBtn:active {
    transform: translateY(0) !important;
    background: #334155 !important;
    background-color: #334155 !important;
  }

  /* Desktop-specific hover and active states */
  @media (min-width: 769px) {
    .help-modal .stats-btn:hover,
    .help-modal button.stats-btn:hover,
    .help-modal #showStatsBtn:hover {
      background: #475569 !important;
      background-color: #475569 !important;
      transform: translateY(-1px) !important;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3) !important;
    }
    
    .help-modal .stats-btn:active,
    .help-modal button.stats-btn:active,
    .help-modal #showStatsBtn:active {
      transform: translateY(0) !important;
      background: #334155 !important;
      background-color: #334155 !important;
    }
  }
    
    /* Ensure close button has proper spacing */
    .help-modal .actions {
      margin-bottom: 0;
      padding-bottom: 0;
    }
    
    /* Make target blocks smaller in help modal */
    .help-modal .next-stage-block {
      width: 70px !important;
      height: 32px !important;
      font-size: 16px !important;
    }
    
    /* Make gold displays smaller in help modal */
    .help-modal .gold-value {
      padding: 6px 12px !important;
      font-size: 16px !important;
      min-width: 60px !important;
    }
    
    /* Make gold emojis smaller in help modal */
    .help-modal .gold-emoji {
      font-size: 18px !important;
      top: -6px !important;
      left: -6px !important;
    }
    
    /* Make gold text smaller in help modal */
    .help-modal .gold-text {
      font-size: 16px !important;
    }
    
    /* Make stage multiplier badges smaller in help modal */
    .help-modal .stage-multiplier-badge {
      font-size: 10px !important;
      padding: 2px 4px !important;
      bottom: -10px !important;
      min-width: 16px !important;
    }
    
    /* Reduce gaps in help modal stage progression */
    .help-modal .merge-example[style*="gap: 40px"] {
      gap: 16px !important;
    }
    
    .help-modal [style*="gap: 40px"] {
      gap: 16px !important;
    }
    
    /* Make the stage progression examples more compact on mobile */
    .help-modal [style*="max-width: 600px"] {
      max-width: 90vw !important;
    }
  }

  /* Enhanced Help Modal Styles */
  .help-modal { 
    width: min(900px, 95vw); 
    max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 120px); 
    overflow-y: auto; 
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    /* Ensure modal fits within safe area */
    margin: 0;
    position: absolute;
    top: 20px; /* Default top position for desktop */
  }

  /* Override modal backdrop padding for help modal to allow proper positioning */
  .help-modal-backdrop {
    padding: 0;
    align-items: flex-start;
    justify-content: center;
  }
  


  /* Desktop help modal backdrop should allow content positioning below close button */
  @media (min-width: 769px) {
    .help-modal-backdrop {
      align-items: flex-start;
    }
    

  }

  /* High score display in help modal title - Desktop */
  .help-modal h2 {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    width: 100% !important;
  }
  
  .help-modal .title-text {
    font-size: 1em !important;
    color: var(--text) !important;
    font-weight: 700 !important;
  }
  

  
  /* Modal Close Button - Desktop: floating in top-right of modal bounds */
  .help-modal-close-btn {
    position: fixed;
    top: 20px;
    right: calc(50vw - min(450px, 47.5vw) + 20px);
    padding: 10px 20px;
    min-width: auto;
    height: auto;
    border-radius: 8px;
    background: #334155;
    color: var(--text);
    border: 1px solid #475569;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    z-index: 1001;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.2s ease;
    font-family: var(--font-family);
  }
  
  /* Sound Control and Settings Modal Close Button - positioned for narrower modals */
  .sound-control-modal .help-modal-close-btn,
  .settings-modal .help-modal-close-btn {
    right: calc(50vw - 250px + 20px); /* Position relative to 500px modal width (250px is half) */
  }
  
  .help-modal-close-btn:hover {
    background: #475569;
    transform: translateY(-1px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
  }
  
  .help-modal-close-btn:active {
    transform: translateY(0);
    background: #334155;
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) */
  .help-modal::-webkit-scrollbar {
    display: none;
  }
  
  /* Reset Data Button Styling */
  #resetDataBtn {
    background-color: #dc2626 !important;
    color: white !important;
    border: none;
    transition: all 0.2s ease;
  }
  
  #resetDataBtn:hover {
    background-color: #b91c1c !important;
    transform: translateY(-1px);
  }
  
  #resetDataBtn:active {
    transform: translateY(0);
  }
  
  .help-grid { 
    display: flex; 
    flex-direction: column; 
    gap: 24px; 
    margin: 24px 0; 
  }
  
  .help-section { 
    background: #334155; 
    border-radius: 12px; 
    padding: 20px; 
    border: 1px solid #475569; 
  }
  
  .help-section-header { 
    display: flex; 
    align-items: center; 
    gap: 12px; 
    margin-bottom: 16px; 
  }
  
  .help-icon { 
    font-size: 24px; 
    opacity: 0.9; 
  }
  
  .help-section h3 { 
    margin: 0; 
    font-size: 18px; 
    font-weight: 600; 
    color: #f8fafc; 
  }
  
  .help-content p { 
    margin: 8px 0; 
    font-size: 14px; 
    line-height: 1.4; 
  }
  
  .help-content p:first-child { 
    margin-top: 0; 
  }
  
  .merge-example { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    gap: 20px; 
    margin: 16px 0; 
    padding: 20px; 
    background: #1e293b; 
    border-radius: 8px; 
    flex-wrap: wrap; 
  }
  
  .merge-before, .merge-after { 
    text-align: center; 
  }
  
  .merge-label { 
    display: block; 
    font-size: 12px; 
    color: #94a3b8; 
    margin-bottom: 8px; 
    font-weight: 500; 
  }
  
  .merge-blocks { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 8px; 
  }
  
  .merge-block { 
    width: 108px; 
    height: 42px; 
    border-radius: 9px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    font-weight: 700; 
    font-size: 24px; 
    box-shadow: 0 3px 0 rgba(0,0,0,0.25); 
    font-family: var(--font-family);
  }
  
  /* Block colors are now handled dynamically via JavaScript */
  .merge-block {
    /* Base styling for merge blocks */
  }
  
  .merge-block.bomb-block {
    width: 108px;
    height: 42px;
    border-radius: 9px;
    background: #000;
    color: white;
    position: relative;
    overflow: hidden;
  }
  
  .merge-block.bomb-block .bomb-content {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  .merge-block.bomb-block .bomb-emoji {
    position: absolute;
    top: -3px;
    left: -21px;
    font-size: 42px;
    opacity: 1;
    z-index: 1;
  }
  
  .merge-block.bomb-block .bomb-text {
    position: relative;
    z-index: 2;
    font-size: 24px;
    font-weight: 700;
    font-family: var(--font-family);
  }
  
  .merge-block.explosion {
    background: #F59E0B;
    color: white;
    font-size: 32px;
    width: 108px;
    height: 42px;
    border-radius: 9px;
  }
  
  .merge-arrow { 
    font-size: 20px; 
    color: #94a3b8; 
    font-weight: 600; 
  }
  
  .help-footer { 
    text-align: center; 
    margin: 24px 0 16px; 
    padding: 16px; 
    background: #334155; 
    border-radius: 8px; 
    border: 1px solid #475569; 
  }
  
  .help-footer p { 
    margin: 0; 
    font-size: 16px; 
    color: #f8fafc; 
  }

  /* Statistics Modal Styles */
  .stats-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(30, 41, 59, 0.95);
    backdrop-filter: blur(8px);
    border: 2px solid rgba(255, 255, 255, 0.8);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    width: auto;
    max-width: 90vw;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .stats-modal-backdrop {
    padding: 0;
    align-items: center;
    justify-content: center;
  }

  .stats-modal h2 {
    text-align: center;
    margin: 0 0 16px 0;
    color: var(--text);
    font-size: 20px;
    font-weight: 700;
    font-family: var(--font-family);
  }

  .stats-content {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin: 16px 0;
  }

  .stat-line {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 24px;
    padding: 6px 0;
  }

  .stat-icon {
    font-size: 24px;
    opacity: 0.9;
    flex-shrink: 0;
  }

  .stat-label {
    font-size: 16px;
    color: #94a3b8;
    font-weight: 500;
    flex-shrink: 0;
  }

  .stat-value {
    font-size: 18px;
    font-weight: 700;
    color: #f8fafc;
  }



  /* Mobile responsive for stats modal */
  @media (max-width: 768px) {
    .stats-modal {
      width: auto;
      max-width: calc(100vw - 40px);
      padding: 16px;
    }

    .stats-content {
      gap: 4px;
      margin: 12px 0;
    }

    .stat-line {
      padding: 4px 0;
      flex-wrap: nowrap;
      min-width: 0;
      gap: 16px;
    }

    .stat-icon {
      font-size: 20px;
      flex-shrink: 0;
    }

    .stat-label {
      font-size: 14px;
      flex-shrink: 0;
      white-space: nowrap;
    }

    .stat-value {
      font-size: 16px;
      flex-shrink: 0;
    }
  }

  .game-container {
    display: flex;
    align-items: flex-start;
    margin-top: 32px;
    padding-bottom: 28px;
    justify-content: center;
    position: relative;
  }
  
  .game { 
    display: flex; 
    gap: 24px; 
    justify-content: center; 
    flex-wrap: wrap;
    position: relative;
  }
  

  
  .bottom-actions { 
    display: flex; 
    justify-content: center; 
    align-items: center;
    gap: 18px; 
    margin-top: 18px; 
  }
  
  /* Powerup Shop - Grid Layout */
  .powerup-shop {
    position: absolute;
    left: calc(100% + 20px);
    top: 0;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  
  .shop-grid {
    display: flex;
    flex-direction: column;
    gap: 16px;
    align-items: flex-start;
  }
  
  .powerup-btn {
    background: var(--panel);
    color: var(--text);
    border: 2px solid #DC2626;
    min-width: 80px;
    min-height: 80px;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(220, 38, 38, 0.25);
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: flex-start;
    font-family: var(--font-family);
    pointer-events: auto;
    gap: 8px;
    position: relative;
    padding: 0 12px;
  }
  
  .powerup-btn:hover {
    border: 3px solid #0ea5e9;
    background: #334155;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(220, 38, 38, 0.3);
  }
  
  .powerup-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(220, 38, 38, 0.25);
  }
  
  .powerup-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 2px 0 rgba(220, 38, 38, 0.2);
  }
  
  .powerup-btn.affordable {
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1);
  }
  
  .powerup-btn.affordable:hover {
    border: 3px solid #0ea5e9;
    background: #334155;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(14, 165, 233, 0.3);
  }
  
  /* Undo mode styling - when a bomb is selected and can be undone */
  .powerup-btn.undo-mode {
    border: 2px solid #10B981;
    background: #065F46;
    box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25);
    animation: undoModePulse 2s ease-in-out infinite;
  }
  
  .powerup-btn.undo-mode:hover {
    border: 3px solid #34D399;
    background: #047857;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(16, 185, 129, 0.3);
  }
  
  .powerup-btn.undo-mode .powerup-emoji {
    content: "↩️";
  }
  
  @keyframes undoModePulse {
    0%, 100% { 
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25);
    }
    50% { 
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.4);
    }
  }
  
  .powerup-emoji {
    font-size: 32px;
    line-height: 1;
  }
  
  .powerup-cost {
    display: flex;
    align-items: center;
    gap: 2px;
    font-family: var(--font-family);
    font-size: 16px;
    white-space: nowrap;
    padding-right: 8px;
  }
  
  .cost-emoji {
    font-size: 18px;
  }
  
  .cost-amount {
    color: #FCD34D;
    font-weight: 700;
    font-size: 18px;
    white-space: nowrap;
  }
  
  /* Pulse animation for powerup buttons */
  .powerup-btn.pulse {
    animation: powerupBtnPulse 0.3s ease-out;
  }
  
  @keyframes powerupBtnPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }
  
  /* Mobile Powerup Shop - Flexible and Responsive */
  .mobile-powerup-shop {
    display: none;
    order: 4;
    margin-top: 16px;
    margin-bottom: 0;
    width: 100%;
    padding: 0 20px;
    box-sizing: border-box;
  }
  
  .mobile-shop-grid {
    display: flex;
    gap: 12px;
    justify-content: center;
    align-items: center;
  }
  
  /* Mobile button sizing - Flexible based on available space */
  .mobile-powerup-shop .powerup-btn {
    min-width: clamp(50px, 15vw, 70px);
    height: clamp(45px, 12vw, 65px);
    min-height: 45px;
    padding: 0 clamp(6px, 2vw, 10px);
  }
  
  .mobile-powerup-shop .powerup-emoji {
    font-size: clamp(20px, 5vw, 28px);
  }
  
  .mobile-powerup-shop .powerup-cost {
    font-size: clamp(12px, 3.5vw, 16px);
    white-space: nowrap;
  }
  
  .mobile-powerup-shop .cost-emoji {
    font-size: clamp(13px, 3.5vw, 18px);
  }
  
  .mobile-powerup-shop .cost-amount {
    font-size: clamp(12px, 3.5vw, 18px);
    white-space: nowrap;
  }
  

  


  
  /* Next block display styling in debug panel */

  .pole { position:relative; width:140px; height:var(--stack-height, 525px); background:var(--panel); border-radius:15px; display:flex; flex-direction:column-reverse; align-items:center; padding:16px; box-sizing:border-box; cursor:pointer; transition: all 0.2s ease; z-index: 0; }
  .pole:hover { border: 3px solid #0ea5e9; }
  .pole.full { opacity:0.6; cursor: not-allowed; }
  .pole.full:hover { opacity: 0.6; border: none; }
  .pole.no-hover:hover { border: none !important; opacity: 1 !important; }
  .pole.no-hover { pointer-events: none; }
  /* Touch device optimizations */
  @media (hover: none) and (pointer: coarse) {
    /* On touch devices, completely disable hover effects since they're not useful */
    .pole:hover {
      border: none !important;
      opacity: 1 !important;
    }
    
    /* Reduce transition duration on touch devices for snappier feedback */
    .pole {
      transition: all 0.1s ease;
    }
  }
  .disc { width:108px; height:42px; border-radius:9px; display:flex; align-items:center; justify-content:center; color:white; font-weight:700; font-size:24px; margin-top:9px; box-shadow:0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family); transform-origin: center center; position: relative; z-index: 1; }
  
  /* Bomb block styling */
  .bomb-content {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  .bomb-emoji {
    position: absolute;
    top: -3px;
    left: -21px;
    font-size: 42px;
    opacity: 1;
    z-index: 1;
  }
  
  .bomb-text {
    position: relative;
    z-index: 2;
    font-size: 24px;
    font-weight: 700;
    font-family: var(--font-family);
  }
  
  /* remove extra gap at the very top of a full pole (topmost disc has no margin) */
  .pole .disc:last-child { margin-top: 0; }

  .disc.animate { 
    animation: drop calc(0.15s * var(--animation-speed, 1)) ease-out;
  }
  @keyframes drop {
    from { transform: translateY(-60px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.animate[style*="--animation-speed: 0"] { animation: none; transform: translateY(0); opacity: 1; }

  /* Enhanced merge animations */
  .disc.merge-out { 
    animation: mergeOut calc(0.15s * var(--animation-speed, 1)) cubic-bezier(0.4, 0, 0.2, 1) forwards;
    filter: brightness(1.1) saturate(1.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.merge-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.7); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes mergeOut {
    0% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
    }
    25% { 
      transform: scale(1.1); 
      opacity: 1; 
      filter: brightness(1.2) saturate(1.3);
    }
    50% { 
      transform: scale(1.15); 
      opacity: 0.9; 
      filter: brightness(1.3) saturate(1.4);
    }
    75% { 
      transform: scale(1.05); 
      opacity: 0.6; 
      filter: brightness(1.1) saturate(1.2);
    }
    100% { 
      transform: scale(0.7); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
    }
  }

  /* Bomb explosion effect - for the bomb block itself */
  .disc.bomb-explosion {
    animation: bombExplosion calc(0.5s * var(--animation-speed, 1)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    filter: brightness(1.5) saturate(1.8);
    box-shadow: 0 0 20px rgba(220, 38, 38, 0.6), 0 0 40px rgba(220, 38, 38, 0.4);
    z-index: 15;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.bomb-explosion[style*="--animation-speed: 0"] { animation: none; transform: scale(0.8); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes bombExplosion {
    0% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
    15% { 
      transform: scale(1.6); 
      opacity: 1; 
      filter: brightness(2.0) saturate(2.2);
      box-shadow: 0 0 30px rgba(220, 38, 38, 0.8), 0 0 60px rgba(220, 38, 38, 0.5);
    }
    35% { 
      transform: scale(1.3); 
      opacity: 0.7; 
      filter: brightness(1.6) saturate(1.8);
      box-shadow: 0 0 25px rgba(220, 38, 38, 0.6), 0 0 50px rgba(220, 38, 38, 0.4);
    }
    70% { 
      transform: scale(0.9); 
      opacity: 0.3; 
      filter: brightness(1.2) saturate(1.3);
      box-shadow: 0 0 15px rgba(220, 38, 38, 0.3), 0 0 30px rgba(220, 38, 38, 0.2);
    }
    100% { 
      transform: scale(0.8); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
      box-shadow: 0 0 60px rgba(220, 38, 38, 0);
    }
  }

  /* Stage progression explosion effect - for blocks being cleared during stage advancement */
  .disc.stage-explosion {
    animation: bombRipple calc(0.5s * var(--animation-speed, 1)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    filter: brightness(1.3) saturate(1.4);
    box-shadow: 0 0 15px rgba(220, 38, 38, 0.4), 0 0 30px rgba(220, 38, 38, 0.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.stage-explosion[style*="--animation-speed: 0"] { animation: none; transform: scale(0.8); opacity: 0; filter: brightness(0.8) saturate(0.9); }

  /* Bomb shockwave ripple effect - for blocks affected by the explosion */
  .disc.bomb-ripple {
    animation: bombRipple calc(0.5s * var(--animation-speed, 1)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    filter: brightness(1.3) saturate(1.4);
    box-shadow: 0 0 15px rgba(220, 38, 38, 0.4), 0 0 30px rgba(220, 38, 38, 0.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.bomb-ripple[style*="--animation-speed: 0"] { animation: none; transform: scale(0.8); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes bombRipple {
    0% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
    20% { 
      transform: scale(1.2); 
      opacity: 1; 
      filter: brightness(1.4) saturate(1.6);
      box-shadow: 0 0 20px rgba(220, 38, 38, 0.5), 0 0 40px rgba(220, 38, 38, 0.3);
    }
    40% { 
      transform: scale(1.1); 
      opacity: 0.8; 
      filter: brightness(1.3) saturate(1.4);
      box-shadow: 0 0 15px rgba(220, 38, 38, 0.4), 0 0 30px rgba(220, 38, 38, 0.25);
    }
    70% { 
      transform: scale(0.9); 
      opacity: 0.4; 
      filter: brightness(1.1) saturate(1.2);
      box-shadow: 0 0 10px rgba(220, 38, 38, 0.2), 0 0 20px rgba(220, 38, 38, 0.15);
    }
    100% { 
      transform: scale(0.8); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
  }

  .disc.merge-in { 
    animation: mergeIn calc(0.2s * var(--animation-speed, 1)) cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    filter: brightness(1.05) saturate(1.1);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.merge-in[style*="--animation-speed: 0"] { animation: none; transform: scale(1); opacity: 1; filter: brightness(1) saturate(1); }
  @keyframes mergeIn {
    0% { 
      transform: scale(0.6); 
      opacity: 0; 
      filter: brightness(0.7) saturate(0.8);
    }
    30% { 
      transform: scale(0.85); 
      opacity: 0.7; 
      filter: brightness(0.9) saturate(1);
    }
    60% { 
      transform: scale(1.05); 
      opacity: 0.9; 
      filter: brightness(1.05) saturate(1.1);
    }
    80% { 
      transform: scale(0.98); 
      opacity: 1; 
      filter: brightness(1.02) saturate(1.05);
    }
    100% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
    }
  }

  /* Merge glow effect for visual appeal */
  .disc.merging {
    box-shadow: 0 0 15px rgba(14, 165, 233, 0.4), 0 0 25px rgba(14, 165, 233, 0.2);
    transition: box-shadow 0.1s ease;
    z-index: 5;
  }
  
  /* Enhanced disc transitions for smoother animations */
  .disc {
    transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform, opacity, filter;
  }
  
  /* Disable transitions during animations to prevent conflicts */
  .disc.merge-out,
  .disc.merge-in,
  .disc.bomb-explosion,
  .disc.bomb-ripple,
  .disc.stage-explosion,
  .disc.clear-out {
    transition: none;
  }
  


  /* special clear animation for high-value blocks */
  .disc.clear-out { animation: clearOut calc(0.26s * var(--animation-speed, 1)) ease forwards; }
  @keyframes clearOut {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0.85); opacity: 0; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.clear-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.85); opacity: 0; }

  /* removed falling/fade styles for simplified clear */



  .controls { margin-top:8px; font-size:13px; color:#ccc; }

  /* Debug pane styling */
  .debug-pane { 
    position: fixed; 
    top: 0; 
    right: 0; 
    height: 100vh; 
    background: var(--panel); 
    color: var(--text); 
    border-left: 3px solid #475569; 
    padding: 20px; 
    z-index: 1002; 
    width: 320px;
    box-shadow: -5px 0 25px rgba(0,0,0,0.4);
    font-family: var(--font-family);
    overflow-y: auto;
    overflow-x: hidden;
    box-sizing: border-box;
    transform: translateX(100%);
    transition: transform 0.3s ease-out;
    display: flex;
    flex-direction: column;
  }
  
  .debug-pane.show {
    transform: translateX(0);
  }
  
  /* Debug pane backdrop overlay */
  .debug-pane::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.3);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease-out;
    z-index: -1;
  }
  
  .debug-pane.show::before {
    opacity: 1;
  }
  

  .debug-pane h3 { margin: 0 0 16px; font-size: 20px; text-align: center; font-family: var(--font-family); }
  .debug-pane .section { margin-bottom: 18px; }
  
  .debug-pane .section:not(.bottom-buttons) {
    flex: 1;
  }
  .debug-pane .section-title { font-weight: 600; margin-bottom: 8px; font-size: 15px; font-family: var(--font-family); }
  .debug-pane .controls { display: flex; flex-direction: column; gap: 12px; }
  .debug-pane .control-row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
  .debug-pane .control-row label { font-size: 14px; min-width: 70px; font-family: var(--font-family); flex-shrink: 0; }
  .debug-pane .control-row input[type="range"] { flex: 1; min-width: 0; accent-color: #0ea5e9; }
  .debug-pane .control-row .value-display { 
    background: var(--bg); 
    padding: 6px 12px; 
    border-radius: 6px; 
    font-size: 13px; 
    min-width: 45px; 
    text-align: center; 
    font-family: var(--font-family);
    flex-shrink: 0;
  }
  .debug-pane .button { 
    background: #334155; 
    color: var(--text); 
    border: 1px solid #475569; 
    padding: 10px 16px; 
    border-radius: 6px; 
    cursor: pointer; 
    font-weight: 600; 
    font-size: 14px;
    transition: background 0.2s;
    font-family: var(--font-family);
    box-sizing: border-box;
  }
  
  .debug-pane .button-row {
    display: flex;
    gap: 8px;
  }
  
  .debug-pane .button-row .button {
    flex: 1;
    min-width: 0;
  }
  
  .debug-pane .bottom-buttons {
    margin-top: auto;
    padding-top: 16px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
  }
  
  /* Block grid styling */
  .block-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
    margin: 12px 0;
  }
  
  .block-item {
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
    user-select: none;
  }
  
  .block-item:hover {
    transform: scale(1.05);
    box-shadow: 0 3px 0 rgba(0,0,0,0.3);
  }
  
  .block-item.selected {
    outline: 3px solid #fff;
    outline-offset: 2px;
    transform: scale(1.1);
    box-shadow: 0 4px 0 rgba(0,0,0,0.4);
  }
  
  /* Debug block colors are now handled dynamically via JavaScript */
  
  /* Basic styling for debug blocks (colors applied via JavaScript) */
  .debug-pane .block-item {
    width: 40px;
    height: 40px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 2px solid transparent;
  }
  
  .debug-pane .block-item:hover {
    border-color: #64748b;
    transform: scale(1.05);
  }
  
  .debug-pane .block-item.selected {
    border-color: #0ea5e9;
    transform: scale(1.1);
  }
  
  /* General rule for any higher tier blocks (262144+) to use white styling */
  .block-item[data-value]:not([data-value="1"]):not([data-value="2"]):not([data-value="4"]):not([data-value="8"]):not([data-value="16"]):not([data-value="32"]):not([data-value="64"]):not([data-value="128"]):not([data-value="256"]):not([data-value="512"]):not([data-value="1024"]):not([data-value="2048"]):not([data-value="4096"]):not([data-value="8192"]):not([data-value="16384"]):not([data-value="32768"]):not([data-value="65536"]):not([data-value="131072"]):not([data-value="262144"]) {
    background: #fff !important;
    color: #000 !important;
  }
  
  /* Largest merge block styling - now handled dynamically via JavaScript */
  
  /* Largest merge block styling - now handled dynamically via JavaScript with proper theming */

  /* Theme switching classes - now handled dynamically via JavaScript */
  
  /* Dynamic gold glow effect for white blocks (16384+) in the game */
  .disc.white-block-glow {
    --glow-intensity: 1;
    --glow-spread: 8px;
    --glow-opacity: 0.6;
    --border-width: 2px;
    --border-opacity: 0.8;
    --inset-opacity: 0.1;
    
    box-shadow: 
      0 0 calc(var(--glow-spread) * 1) rgba(245, 215, 110, var(--glow-opacity)),
      0 0 calc(var(--glow-spread) * 2) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.67)),
      0 0 calc(var(--glow-spread) * 3) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.33)),
      0 0 calc(var(--glow-spread) * 4) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.17)),
      inset 0 0 calc(var(--glow-spread) * 1) rgba(245, 215, 110, var(--inset-opacity));
    border: var(--border-width) solid rgba(245, 215, 110, var(--border-opacity));
  }
  
  .block-item.no-block {
    background: #64748b;
    color: #fff;
    border: 2px solid #94a3b8;
    font-weight: 600;
  }
  
  .block-item.no-block:hover {
    background: #475569;
    border-color: #cbd5e1;
  }
  
  .block-item.no-block.selected {
    background: #475569;
    border-color: #e2e8f0;
    outline: 3px solid #e2e8f0;
  }
  
  .selected-block-info {
    text-align: center;
    font-size: 13px;
    color: rgba(255, 255, 255, 0.9);
    margin-top: 8px;
    padding: 8px;
    background: var(--bg);
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }
  .debug-pane .button:hover { background: #475569; }
  .debug-pane .button:active { background: #334155; }
  .debug-pane .button.primary { background: #0ea5e9; border-color: #0284c7; }
  .debug-pane .button.primary:hover { background: #0284c7; }
  .debug-pane .button.active { background: #0ea5e9; border-color: #0284c7; }
  .debug-pane .close-btn { 
    position: absolute; 
    top: 8px; 
    right: 12px; 
    background: none; 
    border: none; 
    color: #94a3b8; 
    font-size: 20px; 
    cursor: pointer; 
    padding: 6px; 
    border-radius: 6px;
    font-family: var(--font-family);
  }
  .debug-pane .close-btn:hover { background: #475569; color: var(--text); }
  .debug-pane .status { 
    background: var(--bg); 
    padding: 8px; 
    border-radius: 6px; 
    font-size: 13px; 
    text-align: center;
    border: 1px solid #475569;
    font-family: var(--font-family);
  }
  .debug-pane .status.active { border-color: #10B981; background: rgba(16, 185, 129, 0.1); }
  .debug-pane .status.inactive { border-color: #6B7280; background: rgba(107, 114, 128, 0.1); }
  
  /* Hide debug button by default - will be shown only in development mode */
  #debugBtn {
    display: none;
  }

  /* Game Over Button Overlay */
  .game-over-button-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: rgba(30, 41, 59, 0.95); /* Semi-transparent panel background */
    backdrop-filter: blur(8px); /* Add subtle blur effect */
    border: 2px solid rgba(255, 255, 255, 0.8); /* Semi-transparent white border */
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1); /* Smooth easing curve for fade-in */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    min-width: 200px;
  }

  .game-over-button-overlay.hiding {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* Fast transition for fade-out */
  }

  .game-over-button-overlay.show {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
  }

  .game-over-text {
    font-size: 24px;
    font-weight: 700;
    color: #ef4444;
    font-family: var(--font-family);
    text-align: center;
    margin: 0;
  }

  .new-high-score-message {
    font-size: 20px;
    font-weight: 700;
    color: #fbbf24;
    font-family: var(--font-family);
    text-align: center;
    margin: 8px 0;
    animation: celebrateHighScore 1s ease-in-out;
  }

  @keyframes celebrateHighScore {
    0% { 
      opacity: 0;
      transform: scale(0.8);
    }
    50% {
      opacity: 1;
      transform: scale(1.1);
    }
    100% {
      opacity: 1;
      transform: scale(1);
    }
  }

  .largest-merge-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    margin-top: 8px;
  }

  .largest-merge-label {
    font-size: 16px;
    font-weight: 600;
    color: var(--text);
    font-family: var(--font-family);
    text-align: center;
    margin: 0;
  }

  .largest-merge-block {
    width: 108px;
    height: 42px;
    border-radius: 9px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 24px;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    font-family: var(--font-family);
    transition: all 0.2s ease;
  }

  .gold-earned-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    margin-top: 16px;
  }

  .gold-earned-label {
    font-size: 16px;
    font-weight: 600;
    color: var(--text);
    font-family: var(--font-family);
    text-align: center;
    margin: 0;
  }

  .gold-earned-amount {
    background: #FCD34D; 
    color: #000; 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 20px; 
    min-width: 70px; 
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .new-game-btn {
    background: #10B981;
    color: white;
    border: none;
    padding: 16px 32px;
    border-radius: 12px;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .new-game-btn:hover {
    background: #059669;
    transform: translateY(-2px);
    box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
  }

  .new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }



  /* New Game Modal Styling */
  .new-game-modal {
    max-width: 300px;
    text-align: center;
    /* Add similar outline to Game Over window but with green/blue theme */
    border: 2px solid rgba(16, 185, 129, 0.8); /* Semi-transparent green border */
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3); /* Green-tinted shadow */
    background: rgba(30, 41, 59, 0.95); /* Semi-transparent panel background like Game Over */
    backdrop-filter: blur(8px); /* Add subtle blur effect like Game Over */
    /* Add smooth transition for hover effects */
    transition: all 0.3s ease;
  }

  /* Add hover effect to make the outline more prominent */
  .new-game-modal:hover {
    border-color: rgba(16, 185, 129, 1); /* Solid green on hover */
    box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4); /* Enhanced shadow on hover */
  }

  .new-game-modal h2 {
    margin-bottom: 24px;
    color: var(--text);
  }

  /* Update Modal Styling */
  .update-modal {
    max-width: 500px;
    text-align: center;
    border: 2px solid rgba(59, 130, 246, 0.8); /* Blue border for updates */
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3); /* Blue-tinted shadow */
    background: rgba(30, 41, 59, 0.95); /* Semi-transparent panel background */
    backdrop-filter: blur(8px); /* Add subtle blur effect */
    transition: all 0.3s ease;
  }

  .update-modal:hover {
    border-color: rgba(59, 130, 246, 1); /* Solid blue on hover */
    box-shadow: 0 10px 30px rgba(59, 130, 246, 0.4); /* Enhanced shadow on hover */
  }

  .update-modal h2 {
    margin-bottom: 20px;
    color: var(--text);
    font-size: 24px;
  }

  .update-modal h3 {
    margin: 0 0 12px 0;
    color: #60a5fa; /* Light blue for the update title */
    font-size: 20px;
  }

  .update-content {
    margin-bottom: 24px;
    text-align: left;
  }

  .update-content p {
    margin: 8px 0;
    line-height: 1.5;
  }

  .update-content em {
    color: #94a3b8; /* Muted color for the "more updates" text */
    font-size: 14px;
  }

  .update-got-it-btn {
    background: #10B981;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .update-got-it-btn:hover {
    background: #059669;
    transform: translateY(-2px);
    box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
  }

  .update-got-it-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

  /* Mobile responsive for update modal */
  @media (max-width: 768px) {
    .update-modal {
      max-width: 95vw;
      margin: 20px;
    }
    
    .update-modal h2 {
      font-size: 22px;
    }
    
    .update-modal h3 {
      font-size: 18px;
    }
    
    .update-got-it-btn {
      padding: 10px 20px;
      font-size: 15px;
    }
  }

  .new-game-buttons {
    display: flex;
    gap: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .confirm-new-game-btn {
    background: #10B981;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .confirm-new-game-btn:hover {
    background: #059669;
    transform: translateY(-2px);
    box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
  }

  .confirm-new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

  .cancel-new-game-btn {
    background: #DC2626;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .cancel-new-game-btn:hover {
    background: #b91c1c;
    transform: translateY(-2px);
    box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
  }

  .cancel-new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

/* Debug stats table styling */
.debug-stats-table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 8px;
  font-size: 12px;
  table-layout: fixed;
}

.debug-stats-table td {
  padding: 2px 4px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.debug-stats-table td:first-child {
  font-weight: 500;
  color: rgba(255, 255, 255, 0.7);
  width: 45%;
}

.debug-stats-table td:last-child {
  text-align: right;
  font-weight: 600;
  color: var(--text);
  width: 55%;
}

/* Mobile Responsive Design */
@media (max-width: 768px) {
  /* Adjust topbar for mobile */
  .topbar {
    padding: 16px 12px 8px;
    gap: 16px;
  }
  
  h1 {
    font-size: 28px;
  }
  
  /* Adjust game info layout for mobile */
  .game-info {
    flex-direction: row;
    justify-content: center;
    gap: 32px;
    margin-top: 20px; /* Increased from 20px to give more spacing on mobile */
    flex-wrap: wrap;
  }
  
  .score-display, .gold-display {
    gap: 8px;
  }
  
  /* Adjust stage multiplier badge for mobile */
  .stage-multiplier-badge {
    font-size: 10px;
    padding: 3px 5px;
    min-width: 18px;
    bottom: -14px;
    left: 50%;
    transform: translateX(-50%);
  }
  
  .next {
    order: 2;
    width: 100%;
    margin-top: 16px;
  }
  
  .score-label, .next .label, .gold-label {
    font-size: 16px;
  }
  
  .score-value, .gold-value {
    font-size: 20px;
    padding: 8px 16px;
    min-width: 60px;
  }
  
  .next-disc {
    width: 80px;
    height: 35px;
    font-size: 18px;
  }
  
  /* Adjust bomb blocks in next queue for mobile */
  .next-disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .next-disc .bomb-text {
    font-size: 18px;
  }
  
  /* Fix next blocks animation for mobile */
  .next-disc.shift-left {
    transform: translateX(-96px); /* Adjusted for mobile next-disc width + gap */
  }
  
  .next-disc.consume-out {
    animation-duration: calc(0.15s * var(--animation-speed, 1)); /* Slightly faster on mobile */
    transition: none; /* Disable transition during animation to prevent conflicts */
  }
  
  /* Fix drop animation for mobile - override default with higher specificity */
  .game .pole .disc.animate {
    animation: dropMobile calc(0.15s * var(--animation-speed, 1)) ease-out !important;
  }
  
  @keyframes dropMobile {
    from { transform: translateY(-50px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  /* Adjust game container for mobile */
  .game-container {
    margin-top: 20px;
    padding-bottom: 20px;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    display: flex;
  }
  
  .game {
    order: 1;
  }
  

  
  /* Show mobile powerup shop and hide desktop powerup shop on mobile */
  .powerup-shop {
    display: none;
  }
  
  .mobile-powerup-shop {
    display: block;
    order: 4;
    margin-top: 8px;
    margin-bottom: 0;
  }
  
  /* Adjust game grid for mobile */
  .game {
    gap: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  /* Make poles smaller for mobile */
  .pole {
    width: 100px;
    /* Height will be set by JavaScript via --stack-height variable */
    padding: 12px;
  }
  
  /* Adjust discs for smaller poles */
  .disc {
    width: 76px;
    height: 30px;
    font-size: 18px;
    margin-top: 6px;
  }
  
  /* Adjust bomb blocks for mobile to match disc sizing */
  .disc .bomb-emoji {
    font-size: 30px;
    top: -2px;
    left: -15px;
  }
  
  .disc .bomb-text {
    font-size: 18px;
  }
  
  /* Adjust bomb conversion button for mobile */
  .bomb-conversion-btn {
    width: 50px;
    height: 50px;
  }
  
  .bomb-conversion-btn .emoji {
    font-size: 24px;
  }
  
  .bomb-cost-text .emoji {
    font-size: 20px;
  }
  
  .bomb-cost-text .cost {
    font-size: 16px;
  }
  
  .trash-cost-text .emoji {
    font-size: 20px;
  }
  
  .trash-cost-text .cost {
    font-size: 16px;
  }
  
  /* Mobile button row styling */
  .mobile-button-row .mobile-bomb-container,
  .mobile-button-row .mobile-trash-container {
    display: flex;
    position: static;
    margin: 0;
    flex: 1;
    justify-content: center;
    align-items: center;
    gap: 12px;
  }
  

  
  /* Disable hover effects on mobile devices for bomb and trash buttons */
  @media (max-width: 768px) {
    /* Disable hover effects for all bomb and trash buttons on mobile */
    .bomb-conversion-btn:hover,
    .trash-btn:hover {
      /* Disable hover effects on mobile - no transform, border, background, or shadow changes */
      transform: none !important;
      border: 2px solid #DC2626 !important; /* Keep original border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(220, 38, 38, 0.25) !important; /* Keep original shadow */
    }
    
    .bomb-conversion-btn.affordable:hover {
      /* Disable hover effects for affordable state on mobile */
      transform: none !important;
      border: 2px solid rgba(255, 255, 255, 0.3) !important; /* Keep affordable border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1) !important; /* Keep affordable shadow */
    }
    
    .bomb-conversion-btn.undo-mode:hover {
      /* Disable hover effects for undo mode on mobile */
      transform: none !important;
      border: 2px solid #10B981 !important; /* Keep undo border */
      background: #065F46 !important; /* Keep undo background */
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25) !important; /* Keep undo shadow */
    }
    
    .trash-btn.affordable:hover {
      /* Disable hover effects for affordable state on mobile */
      transform: none !important;
      border: 2px solid rgba(255, 255, 255, 0.3) !important; /* Keep affordable border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1) !important; /* Keep affordable shadow */
    }
    
    /* Disable hover effects for mobile powerup buttons on mobile */
    .mobile-powerup-shop .powerup-btn:hover {
      /* Disable hover effects on mobile - no transform, border, background, or shadow changes */
      transform: none !important;
      border: 2px solid #DC2626 !important; /* Keep original border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(220, 38, 38, 0.25) !important; /* Keep original shadow */
    }
    
    .mobile-powerup-shop .powerup-btn.affordable:hover {
      /* Disable hover effects for affordable state on mobile */
      transform: none !important;
      border: 2px solid rgba(255, 255, 255, 0.3) !important; /* Keep affordable border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1) !important; /* Keep affordable shadow */
    }
    
    .mobile-powerup-shop .powerup-btn.undo-mode:hover {
      /* Disable hover effects for undo mode on mobile */
      transform: none !important;
      border: 2px solid #10B981 !important; /* Keep undo border */
      background: #065F46 !important; /* Keep undo background */
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25) !important; /* Keep undo shadow */
    }
  }
  
  /* Responsive adjustments for very small mobile screens */

  
  /* Pulse animation for mobile buttons */

  
  /* Adjust bottom actions for mobile */
  .bottom-actions {
    margin-top: 16px;
    gap: 12px;
    order: 5;
  }
  
  .ai-btn {
    padding: 10px 20px;
    font-size: 14px;
  }
  
  /* Adjust help modal for mobile */
  .help-modal {
    width: 95vw;
    padding: 20px;
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    /* Position will be set dynamically via JavaScript */
    position: absolute;
  }

  /* Mobile help modal backdrop positioning */
  .help-modal-backdrop {
    padding: 0;
    align-items: flex-start;
    justify-content: center;
  }
  


  /* Mobile responsive for help modal high score display */
  .help-modal .title-text {
    font-size: 1em !important;
    color: var(--text) !important;
    font-weight: 700 !important;
  }
  
  .help-modal .stats-btn {
    font-size: 16px !important;
    margin-left: auto !important;
    padding: 10px 16px !important;
    background: #334155 !important;
    border: 1px solid #475569 !important;
    color: var(--text) !important;
    font-weight: 500 !important;
    font-family: var(--font-family) !important;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2) !important;
  }




  
  /* Mobile responsive for help modal actions */
  .help-modal .actions {
    flex-direction: column;
    gap: 12px;
    align-items: stretch;
  }
  
  .help-modal .actions button {
    width: 100%;
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) on mobile */
  .help-modal::-webkit-scrollbar {
    display: none;
  }
  
  /* Mobile responsive for floating close button - screen corner with safe area */
  .help-modal-close-btn {
    position: fixed;
    top: calc(env(safe-area-inset-top, 0px) + 24px);
    right: calc(env(safe-area-inset-right, 0px) + 20px);
    padding: 10px 16px;
    font-size: 16px;
  }
  
  /* Mobile responsive for sound control and settings modal close buttons */
  .sound-control-modal .help-modal-close-btn,
  .settings-modal .help-modal-close-btn {
    position: fixed;
    top: calc(env(safe-area-inset-top, 0px) + 24px);
    right: calc(env(safe-area-inset-right, 0px) + 20px);
    padding: 10px 16px;
    font-size: 16px;
  }
  
  .help-grid {
    gap: 16px;
  }
  
  /* Adjust powerup buttons section for mobile */
  .help-modal .help-content [style*="gap: 80px"] {
    gap: 40px !important;
  }
  
  /* Make powerup buttons more compact on mobile */
  .help-modal .powerup-btn {
    min-width: 50px !important;
    min-height: 50px !important;
    padding: 0 6px !important;
  }
  
  .help-modal .powerup-emoji {
    font-size: 20px !important;
  }
  
  .help-modal .cost-emoji,
  .help-modal .cost-amount {
    font-size: 14px !important;
  }
  
  /* Adjust help section padding for mobile */
  .help-modal .help-section {
    padding: 16px !important;
  }
  
  /* Adjust help section header spacing for mobile */
  .help-modal .help-section-header {
    margin-bottom: 12px !important;
  }
  
  .help-modal .help-section-header h3 {
    font-size: 18px !important;
  }
  
  /* Make merge examples more compact on mobile */
  .help-modal .merge-example {
    gap: 30px !important;
  }
  
  .help-modal .merge-example[style*="gap: 80px"] {
    gap: 30px !important;
  }
  
  .help-modal .merge-block {
    width: 70px !important;
    height: 28px !important;
    font-size: 18px !important;
  }
  
  .help-modal .merge-block.bomb-block {
    width: 76px !important;
    height: 30px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-emoji {
    font-size: 30px !important;
    top: -2px !important;
    left: -15px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-text {
    font-size: 18px !important;
  }
  
  .help-modal .merge-arrow {
    font-size: 18px !important;
  }
  
  .help-modal .merge-example [style*="gap: 12px"] {
    gap: 10px !important;
  }
  
  .help-modal .merge-example [style*="margin-left: 20px"] {
    margin-left: 16px !important;
  }
  
  /* Adjust debug pane for mobile */
  .debug-pane {
    width: 95vw;
    right: 0;
  }
}

/* Extra small mobile devices */
@media (max-width: 480px) {
  .topbar {
    padding: 12px 8px 6px;
  }
  
  h1 {
    font-size: 24px;
  }
  
  /* Extra help modal adjustments for very small screens */
  .help-modal {
    width: 98vw;
    padding: 16px;
    position: absolute;
  }

  /* Extra small mobile help modal backdrop positioning */
  .help-modal-backdrop {
    padding: 0;
    align-items: flex-start;
    justify-content: center;
  }
  

  
  /* Extra small mobile floating close button - screen corner with safe area */
  .help-modal-close-btn {
    position: fixed;
    top: calc(env(safe-area-inset-top, 0px) + 16px);
    right: calc(env(safe-area-inset-right, 0px) + 16px);
    padding: 8px 12px;
    font-size: 14px;
  }
  
  /* Extra small mobile sound control and settings modal close buttons */
  .sound-control-modal .help-modal-close-btn,
  .settings-modal .help-modal-close-btn {
    position: fixed;
    top: calc(env(safe-area-inset-top, 0px) + 16px);
    right: calc(env(safe-area-inset-right, 0px) + 16px);
    padding: 8px 12px;
    font-size: 14px;
  }
  
  .help-modal .help-content [style*="gap: 80px"] {
    gap: 24px !important;
  }
  
  .help-modal .powerup-btn {
    min-width: 45px !important;
    min-height: 45px !important;
    padding: 0 4px !important;
  }
  
  .help-modal .powerup-emoji {
    font-size: 18px !important;
  }
  
  .help-modal .cost-emoji,
  .help-modal .cost-amount {
    font-size: 12px !important;
  }
  
  .help-modal .help-section {
    padding: 12px !important;
  }
  
  .help-modal .help-section-header h3 {
    font-size: 16px !important;
  }
  
  /* Make merge examples more compact on mobile */
  .help-modal .merge-example {
    gap: 20px !important;
  }
  
  .help-modal .merge-example[style*="gap: 80px"] {
    gap: 20px !important;
  }
  
  .help-modal .merge-block {
    width: 60px !important;
    height: 24px !important;
    font-size: 16px !important;
  }
  
  .help-modal .merge-block.bomb-block {
    width: 60px !important;
    height: 24px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-emoji {
    font-size: 24px !important;
    top: -2px !important;
    left: -12px !important;
  }
  
  .help-modal .merge-block.bomb-block .bomb-text {
    font-size: 16px !important;
  }
  
  .help-modal .merge-arrow {
    font-size: 16px !important;
  }
  
  .help-modal .merge-example [style*="gap: 12px"] {
    gap: 8px !important;
  }
  
  .help-modal .merge-example [style*="margin-left: 20px"] {
    margin-left: 12px !important;
  }
  
  .game-info {
    gap: 16px;
    margin-top: 16px;
    flex-direction: row;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  .next {
    order: 2;
    width: 100%;
    margin-top: 12px;
  }
  
  .pole {
    width: 80px;
    /* Height will be set by JavaScript via --stack-height variable */
    padding: 8px;
  }
  
  .disc {
    width: 64px;
    height: 26px;
    font-size: 16px;
    margin-top: 4px;
  }
  
  /* Adjust bomb blocks for extra small mobile */
  .disc .bomb-emoji {
    font-size: 22px;
    top: -1px;
    left: -11px;
  }
  
  .disc .bomb-text {
    font-size: 16px;
  }
  
  .next-disc {
    width: 70px;
    height: 30px;
    font-size: 16px;
  }
  
  /* Adjust bomb blocks in next queue for extra small mobile */
  .next-disc .bomb-emoji {
    font-size: 26px;
    top: -1px;
    left: -13px;
  }
  
  .next-disc .bomb-text {
    font-size: 16px;
  }
  
  /* Fix next blocks animation for extra small mobile */
  .next-disc.shift-left {
    transform: translateX(-84px); /* Adjusted for extra small mobile next-disc width + gap */
  }
  
  .next-disc.consume-out {
    animation-duration: calc(0.15s * var(--animation-speed, 1)); /* Slightly faster on mobile */
    transition: none; /* Disable transition during animation to prevent conflicts */
  }
  
  /* Extra small mobile uses same drop animation approach */
  
  /* Fix drop animation for extra small mobile - override default with higher specificity */
  .game .pole .disc.animate {
    animation: dropMobileSmall calc(0.15s * var(--animation-speed, 1)) ease-out !important;
  }
  
  @keyframes dropMobileSmall {
    from { transform: translateY(-40px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  .game {
    gap: 12px;
  }
  
  .bomb-conversion-btn {
    width: 45px;
    height: 45px;
  }
  
  .bomb-conversion-btn .emoji {
    font-size: 20px;
  }
  
  /* Adjust stage multiplier badge for extra small mobile */
  .stage-multiplier-badge {
    font-size: 9px;
    padding: 2px 4px;
    min-width: 16px;
    bottom: -12px;
    left: 50%;
    transform: translateX(-50%);
  }
  

  

  

}

/* Landscape mobile orientation */
@media (max-width: 768px) and (orientation: landscape) {
  .game-container {
    flex-direction: row;
    align-items: flex-start;
    gap: 12px;
  }
  

  

  
  .pole {
    height: 250px;
  }
  
  /* Adjust bomb blocks for landscape mobile */
  .disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .disc .bomb-text {
    font-size: 20px;
  }
  
  /* Adjust bomb blocks in next queue for landscape mobile */
  .next-disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .next-disc .bomb-text {
    font-size: 20px;
  }
}



/* Probability test results modal */
.prob-test-modal { 
  position: fixed; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%); 
  background: var(--panel); 
  color: var(--text); 
  width: min(600px, 90vw); 
  border-radius: 16px; 
  padding: 24px; 
  box-shadow: 0 15px 45px rgba(0,0,0,0.4); 
  font-family: var(--font-family);
  z-index: 1001;
  max-height: 80vh;
  overflow-y: auto;
}

.prob-test-modal h3 { 
  margin: 0 0 20px; 
  font-size: 20px; 
  text-align: center; 
  color: #0ea5e9;
  font-family: var(--font-family);
}

.prob-test-results {
  background: var(--bg);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
  border: 1px solid #475569;
}

.prob-test-table {
  width: 100%;
  border-collapse: collapse;
  margin: 12px 0;
  font-size: 14px;
}

.prob-test-table th,
.prob-test-table td {
  padding: 8px 12px;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.prob-test-table th {
  background: #334155;
  font-weight: 600;
  color: #f8fafc;
}

.prob-test-table td {
  font-family: 'Courier New', monospace;
  font-size: 13px;
}

.prob-test-table .block-value {
  font-weight: 600;
  color: #0ea5e9;
}

.prob-test-table .expected {
  color: #10B981;
}

.prob-test-table .actual {
  color: #F59E0B;
}

.prob-test-table .difference {
  color: #EF4444;
}

.prob-test-summary {
  text-align: center;
  margin-top: 16px;
  padding: 12px;
  background: #334155;
  border-radius: 6px;
  border: 1px solid #475569;
}

.prob-test-summary .total {
  font-size: 16px;
  font-weight: 600;
  color: #10B981;
}

.prob-test-close {
  background: #334155;
  color: var(--text);
  border: 1px solid #475569;
  padding: 10px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: background 0.2s;
  font-family: var(--font-family);
  width: 100%;
  margin-top: 16px;
}

.prob-test-close:hover {
  background: #475569;
}

.prob-test-close:active {
  background: #334155;
}



/* Hide next blocks section when game is over */
.next.game-over-hidden {
  opacity: 0.3;
  pointer-events: none;
}

/* Show new game button in place of next blocks */
.new-game-container {
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  margin-top: 16px;
}

.new-game-container.show {
  display: flex;
}

.new-game-container .label {
  font-size: 18px;
  opacity: 0.9;
  font-family: var(--font-family);
}

.new-game-container .new-game-btn {
  padding: 12px 24px;
  font-size: 16px;
}

  /* Sound Control Modal Styles */
  .sound-control-modal { 
    background: var(--panel); 
    color: var(--text); 
    width: min(500px, 85vw); /* Narrower width to create margins like help guide */
    border-radius: 16px; 
    padding: 28px; 
    box-shadow: 0 15px 45px rgba(0,0,0,0.4); 
    font-family: var(--font-family);
    z-index: 1001;
    max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 120px);
    overflow-y: auto;
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    /* Ensure modal fits within safe area and starts below close button */
    margin: 0;
    position: absolute;
    top: 80px; /* Start below the close button with proper spacing - accounts for button height + border + text */
  }

  .sound-control-modal h2 { 
    margin: 0 0 24px; 
    font-size: 24px; 
    text-align: center; 
    color: #0ea5e9;
    font-family: var(--font-family);
  }
  
  /* Settings Modal Styles - same positioning as sound control modal */
  .settings-modal { 
    background: var(--panel); 
    color: var(--text); 
    width: min(500px, 85vw); /* Narrower width to create margins like help guide */
    border-radius: 16px; 
    padding: 28px; 
    box-shadow: 0 15px 45px rgba(0,0,0,0.4); 
    font-family: var(--font-family);
    z-index: 1001;
    max-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px) - 120px);
    overflow-y: auto;
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    /* Ensure modal fits within safe area and starts below close button */
    margin: 0;
    position: absolute;
    top: 80px; /* Start below the close button with proper spacing - accounts for button height + border + text */
  }

.sound-control-container {
  background: var(--bg);
  border-radius: 8px;
  border: 1px solid #475569;
  padding: 20px;
  margin-bottom: 20px;
}

.sound-control-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
  gap: 16px;
}

.sound-control-row:last-child {
  margin-bottom: 0;
}

.sound-control-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 16px;
  min-width: 120px;
}

.sound-control-emoji {
  font-size: 20px;
}

.sound-control-slider {
  flex: 1;
  min-width: 0;
  accent-color: #0ea5e9;
}

.sound-control-controls {
  display: flex;
  align-items: center;
  gap: 16px;
  flex: 1;
}

.sound-control-controls .volume-value {
  min-width: 30px;
  text-align: center;
  font-weight: 600;
  color: var(--text);
  flex-shrink: 0;
}



.sound-control-mute {
  background: #334155;
  color: var(--text);
  border: 1px solid #475569;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.2s ease;
  font-family: var(--font-family);
  min-width: 80px;
}

.sound-control-mute:hover {
  background: #475569;
  border-color: #64748b;
}

.sound-control-mute:active {
  background: #334155;
}

.sound-control-mute.muted {
  background: #dc2626;
  border-color: #ef4444;
}

.sound-control-mute.muted:hover {
  background: #b91c1c;
  border-color: #dc2626;
}

.theme-selector {
  background: var(--panel);
  color: var(--text);
  border: 1px solid #475569;
  padding: 8px 12px;
  border-radius: 6px;
  font-family: var(--font-family);
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 120px;
}

.theme-selector:hover {
  border-color: #64748b;
}

  .theme-selector:focus {
    outline: none;
    border-color: #0ea5e9;
    box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.2);
  }
  
  /* Mobile responsive theme selector */
  @media (max-width: 768px) {
    .theme-selector {
      min-width: 100px;
      font-size: 16px; /* Prevent zoom on iOS */
      padding: 10px 14px;
    }
  }
  
  /* Debug pane theme selector styling */
  .debug-pane .theme-selector {
    min-width: 120px;
    background: var(--bg);
    border-color: #64748b;
  }





/* Mobile responsive design for sound control and settings modals */
@media (max-width: 768px) {
  .sound-control-modal,
  .settings-modal {
    width: 90vw; /* Narrower width to create margins like help guide */
    padding: 24px;
    margin: 20px;
    /* Mobile positioning - start below close button */
    position: absolute;
    top: calc(env(safe-area-inset-top, 0px) + 70px); /* Account for close button height + small padding */
  }
  
  .sound-control-modal h2,
  .settings-modal h2 {
    font-size: 22px;
    margin-bottom: 20px;
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) on mobile */
  .sound-control-modal::-webkit-scrollbar,
  .settings-modal::-webkit-scrollbar {
    display: none;
  }
  
  .sound-control-container {
    padding: 16px;
    margin-bottom: 16px;
  }
  
  /* Settings modal container styling */
  .settings-modal .sound-control-container {
    padding: 16px;
    margin-bottom: 16px;
  }
  
  .sound-control-row {
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    margin-bottom: 20px;
  }
  
  /* Settings modal row styling */
  .settings-modal .sound-control-row {
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    margin-bottom: 20px;
  }
  
  .sound-control-label {
    min-width: auto;
    justify-content: flex-start;
    flex-shrink: 0;
  }
  
  /* Settings modal label styling */
  .settings-modal .sound-control-label {
    min-width: auto;
    justify-content: flex-start;
    flex-shrink: 0;
  }
  
  .sound-control-slider {
    width: 200px !important;
    flex: none !important;
    flex-shrink: 0;
  }
  
  /* Create a horizontal container for slider + value on mobile */
  .sound-control-controls {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 12px;
    flex-shrink: 0;
  }
  
  .sound-control-controls .sound-control-slider {
    width: 200px !important;
    flex: none !important;
    flex-shrink: 0;
  }
  
  .sound-control-controls .volume-value {
    min-width: 30px;
    text-align: center;
    font-weight: 600;
    color: var(--text);
    flex-shrink: 0;
  }
  
  /* Settings modal slider and controls styling */
  .settings-modal .sound-control-slider {
    width: 200px !important;
    flex: none !important;
    flex-shrink: 0;
  }
  
  .settings-modal .sound-control-controls {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 12px;
    flex-shrink: 0;
  }
  
  .settings-modal .sound-control-controls .sound-control-slider {
    width: 200px !important;
    flex: none !important;
    flex-shrink: 0;
  }
  
  .settings-modal .sound-control-controls .volume-value {
    min-width: 30px;
    text-align: center;
    font-weight: 600;
    color: var(--text);
    flex-shrink: 0;
  }
  
  /* For rows with just a button (like master mute), center the button */
  .sound-control-row:has(.sound-control-mute) {
    align-items: center;
  }
  
  .sound-control-mute {
    align-self: center;
    min-width: 100px;
  }
  
  /* Settings modal mute button styling */
  .settings-modal .sound-control-row:has(.sound-control-mute) {
    align-items: center;
  }
  
  .settings-modal .sound-control-mute {
    align-self: center;
    min-width: 100px;
  }
  
  /* Theme selector styling for mobile */
  .theme-selector {
    width: 200px !important;
    min-width: 200px !important;
    flex-shrink: 0;
  }
  
  /* Settings modal theme selector controls - right justify the dropdown */
  .settings-modal .sound-control-controls:has(.theme-selector) {
    justify-content: flex-end;
  }
}

/* Medium-small mobile devices */
@media (max-width: 600px) and (min-width: 481px) {
  /* Adjust slider width for medium-small screens */
  .sound-control-slider,
  .sound-control-controls .sound-control-slider,
  .settings-modal .sound-control-slider,
  .settings-modal .sound-control-controls .sound-control-slider {
    width: 180px !important;
    flex: none !important;
  }
  
  /* Theme selector width for medium-small screens */
  .theme-selector {
    width: 180px !important;
    min-width: 180px !important;
  }
}

/* Extra small mobile devices */
@media (max-width: 480px) {
  .sound-control-modal,
  .settings-modal {
    width: 92vw; /* Narrower width to create margins like help guide */
    padding: 20px;
    margin: 16px;
    /* Extra small mobile positioning - start below close button */
    position: absolute;
    top: calc(env(safe-area-inset-top, 0px) + 65px); /* Account for close button height + small padding */
  }
  
  .sound-control-modal h2,
  .settings-modal h2 {
    font-size: 20px;
    margin-bottom: 18px;
  }
  
  .sound-control-container {
    padding: 14px;
    margin-bottom: 14px;
  }
  
  /* Settings modal container styling for extra small mobile */
  .settings-modal .sound-control-container {
    padding: 14px;
    margin-bottom: 14px;
  }
  
  .sound-control-row {
    gap: 10px;
    margin-bottom: 18px;
  }
  
  /* Settings modal row styling for extra small mobile */
  .settings-modal .sound-control-row {
    gap: 10px;
    margin-bottom: 18px;
  }
  
  .sound-control-label {
    font-size: 15px;
  }
  
  /* Settings modal label styling for extra small mobile */
  .settings-modal .sound-control-label {
    font-size: 15px;
  }
  
  .sound-control-emoji {
    font-size: 18px;
  }
  
  /* Settings modal emoji styling for extra small mobile */
  .settings-modal .sound-control-emoji {
    font-size: 18px;
  }
  
  /* Adjust slider width for very small screens */
  .sound-control-slider,
  .sound-control-controls .sound-control-slider,
  .settings-modal .sound-control-slider,
  .settings-modal .sound-control-controls .sound-control-slider {
    width: 150px !important;
    flex: none !important;
  }
  
  /* Theme selector width for very small screens */
  .theme-selector {
    width: 150px !important;
    min-width: 150px !important;
  }
}
</style>
</head>
<body>
  <!-- Probability test results modal (hidden by default) -->
  <div id="probTestModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="probTestTitle">
    <div class="modal prob-test-modal">
      <h3 id="probTestTitle">Probability Distribution Test Results</h3>
      
      <div class="prob-test-results">
        <div id="probTestContent">
          <!-- Test results will be populated here -->
        </div>
      </div>
      
      <button id="probTestClose" class="prob-test-close">Close</button>
    </div>
  </div>

  <div class="topbar">
    <div class="title-section">
      <div class="left-section">
        <button id="addBtn" class="title-btn" title="New Game">➕</button>
        <button id="helpBtn" class="title-btn" title="How to play">❔</button>
      </div>
      <div class="center-section">
        <h1>Stack Merge</h1>
      </div>
      <div class="right-section">
        <button id="soundBtn" class="title-btn" title="Sound Controls">🔊</button>
        <button id="settingsBtn" class="title-btn" title="Settings">⚙️</button>
      </div>
    </div>
  </div>

  <div class="game-info">
    <div class="score-display">
      <div class="score-label">Score</div>
      <div class="score-value" id="scoreDisplay">0</div>
    </div>
    
    <div class="next">
      <div class="label">Next Blocks</div>
      <div class="next-row" id="nextContainer" aria-live="polite"></div>
    </div>
    

    
    <div class="gold-display">
      <div class="gold-label">Gold</div>
      <div class="gold-value" id="goldDisplay">0</div>
    </div>
  </div>
  


  <!-- Game Over Button Overlay -->
  <div id="gameOverButton" class="game-over-button-overlay">
    <div class="game-over-text">Game Over</div>
    <div id="newHighScoreMessage" class="new-high-score-message hidden">🏆 New High Score!</div>
    <div class="largest-merge-info">
              <div class="largest-merge-label">Largest Block:</div>
      <div id="largestMergeBlock" class="largest-merge-block"></div>
    </div>
    <div class="gold-earned-info">
      <div class="gold-earned-label">Total Gold Earned:</div>
      <div id="goldEarnedDisplay" class="gold-earned-amount">
        <div class="gold-emoji">💰</div>
        <div class="gold-text">0</div>
      </div>
    </div>
  </div>

  <!-- New Game Confirmation Modal -->
  <div id="newGameModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="newGameTitle">
    <div class="modal new-game-modal">
      <h2 id="newGameTitle">New Game?</h2>
      <div class="new-game-buttons">
        <button id="confirmNewGameBtn" class="confirm-new-game-btn">Yes</button>
        <button id="cancelNewGameBtn" class="cancel-new-game-btn">No</button>
      </div>
    </div>
  </div>

  <!-- Sound Control Modal -->
  <div id="soundControlModal" class="modal-backdrop help-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="soundControlTitle">
    <div class="modal sound-control-modal">
      <h2 id="soundControlTitle">Sound Controls</h2>
      
      <div class="sound-control-container">
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🔊</span>
            <span>Master Mute</span>
          </div>
          <button id="masterMuteBtn" class="sound-control-mute">Mute</button>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">📦</span>
            <span>Drops</span>
          </div>
          <div class="sound-control-controls">
            <input type="range" id="dropVolumeSlider" class="sound-control-slider" min="0" max="5" step="1">
            <span id="dropVolumeValue" class="volume-value"></span>
          </div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🔗</span>
            <span>Merges</span>
          </div>
          <div class="sound-control-controls">
            <input type="range" id="mergeVolumeSlider" class="sound-control-slider" min="0" max="5" step="1">
            <span id="mergeVolumeValue" class="volume-value"></span>
          </div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">💰</span>
            <span>Gold Coins</span>
          </div>
          <div class="sound-control-controls">
            <input type="range" id="coinVolumeSlider" class="sound-control-slider" min="0" max="5" step="1">
            <span id="coinVolumeValue" class="volume-value"></span>
          </div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">💥</span>
            <span>Bombs</span>
          </div>
          <div class="sound-control-controls">
            <input type="range" id="bombVolumeSlider" class="sound-control-slider" min="0" max="5" step="1">
            <span id="bombVolumeValue" class="volume-value"></span>
          </div>
        </div>
        
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🚀</span>
            <span>Other</span>
          </div>
          <div class="sound-control-controls">
            <input type="range" id="otherVolumeSlider" class="sound-control-slider" min="0" max="5" step="1">
            <span id="otherVolumeValue" class="volume-value"></span>
          </div>
        </div>
      </div>
      
      <button id="soundControlClose" class="help-modal-close-btn" title="Close sound controls">❌ Close</button>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal-backdrop help-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
    <div class="modal sound-control-modal settings-modal">
      <h2 id="settingsTitle">Settings</h2>
      
      <div class="sound-control-container">
        <!-- Theme Settings -->
        <div class="sound-control-row">
          <div class="sound-control-label">
            <span class="sound-control-emoji">🎨</span>
            <span>Theme</span>
          </div>
          <div class="sound-control-controls">
                    <select id="themeSelector" class="theme-selector">
          <option value="jellyfish">Jellyfish</option>
          <option value="alternate">Earth</option>
        </select>
          </div>
        </div>
        

        

      </div>
      
      <button id="settingsClose" class="help-modal-close-btn" title="Close settings">❌ Close</button>
    </div>
  </div>

  <div class="game-container">
    <div class="game" id="game" role="application" aria-label="Stacks"></div>
    
    <!-- Powerup Shop - Grid Layout -->
    <div class="powerup-shop">
      <div class="shop-grid">
        <button id="bombConversionBtn" class="powerup-btn bomb-btn" title="Convert next block to bomb (press again to undo)">
          <span class="powerup-emoji">💣</span>
          <div class="powerup-cost">
            <span class="cost-emoji">💰</span>
            <span class="cost-amount" id="bombCost">25</span>
          </div>
        </button>
        
        <button id="trashButton" class="powerup-btn" title="Remove next block from queue">
          <span class="powerup-emoji">🗑️</span>
          <div class="powerup-cost">
            <span class="cost-emoji">💰</span>
            <span class="cost-amount" id="trashCost">25</span>
          </div>
        </button>
      </div>
    </div>
    
    <!-- Mobile Powerup Shop -->
    <div class="mobile-powerup-shop">
      <div class="mobile-shop-grid">
        <button id="bombConversionBtnMobile" class="powerup-btn bomb-btn" title="Convert next block to bomb (press again to undo)">
          <span class="powerup-emoji">💣</span>
          <div class="powerup-cost">
            <span class="cost-emoji">💰</span>
            <span class="cost-amount" id="bombCostMobile">25</span>
          </div>
        </button>
        
        <button id="trashButtonMobile" class="powerup-btn" title="Remove next block from queue">
          <span class="powerup-emoji">🗑️</span>
          <div class="powerup-cost">
            <span class="cost-emoji">💰</span>
            <span class="cost-amount" id="trashCostMobile">25</span>
          </div>
        </button>
      </div>
    </div>
  </div>
  
  <div class="bottom-actions">
    <button id="debugBtn" class="ai-btn" title="Debug controls">⚙️</button>
  </div>


  <!-- Help modal (hidden by default) -->
  <div id="helpModal" class="modal-backdrop help-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modal help-modal">
      <button id="helpClose" class="help-modal-close-btn" title="Close help guide">❌ Close</button>
      <h2 id="helpTitle">
        <span class="title-text">How to Play</span>
        <button id="showStatsBtn" class="stats-btn" title="Show Player Statistics" style="background: #334155 !important; border: 1px solid #475569 !important; color: var(--text) !important; padding: 10px 20px !important; border-radius: 8px !important; font-family: var(--font-family) !important; font-weight: 500 !important; cursor: pointer !important; margin-left: auto !important; appearance: none !important; -webkit-appearance: none !important; font-size: 16px !important;">📊 My Stats</button>
      </h2>
      
      <div class="help-grid">
        <!-- Basic Controls Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🎮</span>
            <h3>Basic Gameplay</h3>
          </div>
          <div class="help-content">
            <p>Drop the incoming blocks onto stacks to gain score.</p>
            <p>Avoid filling up stacks by merging blocks to create more space.</p>
            <p>Survive as long as possible for a high score!</p>
            <p><strong>Basic Controls:</strong></p>
            <p>Click/Tap one of the four stacks to drop the next block from the queue.</p>
            <p>Click/Tap the bomb button to convert the next block to a bomb.</p>
            <p>Click/Tap the trash can button to remove the next block from the queue.</p>
            <p>Open the Sound Control menu to adjust the volume of the game.</p>
          </div>
        </div>

        <!-- Merging Section -->
        <!-- Basic Merging Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🔗</span>
            <h3>Merging Blocks</h3>
          </div>
          <div class="help-content">
            <p>When two blocks with the same value are stacked, they merge into one bigger block.</p>
            <div class="merge-example" style="display: flex; gap: 80px; justify-content: center;">
              <div style="display: flex; align-items: center; gap: 12px;">
                <div class="merge-before">
                  <div class="merge-blocks">
                    <div class="merge-block" data-value="1">1</div>
                    <div class="merge-block" data-value="1">1</div>
                  </div>
                </div>
                <div class="merge-arrow">→</div>
                <div class="merge-after">
                  <div class="merge-blocks">
                    <div class="merge-block" data-value="2">2</div>
                  </div>
                </div>
              </div>
              
              <div style="display: flex; align-items: center; gap: 12px;">
                <div class="merge-before">
                  <div class="merge-blocks">
                    <div class="merge-block" data-value="2">2</div>
                    <div class="merge-block" data-value="2">2</div>
                  </div>
                </div>
                <div class="merge-arrow">→</div>
                <div class="merge-after">
                  <div class="merge-blocks">
                    <div class="merge-block" data-value="4">4</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Bombs Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">💣</span>
            <h3>Bombs</h3>
          </div>
          <div class="help-content">
            <p>When a bomb block merges with a block of the same value, it explodes and destroys the entire stack!</p>
            <p>Bombs will appear in the queue naturally, but you can also buy them with gold.</p>
            <div class="merge-example">
              <div class="merge-before">
                <div class="merge-blocks">
                  <div class="merge-block" data-value="2">2</div>
                  <div class="merge-block bomb-block">
                    <div class="bomb-content">
                      <div class="bomb-emoji">💣</div>
                      <div class="bomb-text">2</div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="merge-arrow">→</div>
              <div class="merge-after">
                <div class="merge-blocks">
                  <div class="merge-block bomb-block">
                    <div class="bomb-content">
                      <div class="bomb-emoji">💣</div>
                      <div class="bomb-text">4</div>
                    </div>
                  </div>
                </div>
              </div>
              <div style="display: flex; align-items: center; margin-left: 20px;">
                <span style="font-size: 24px; font-weight: bold; color: #f8fafc;">=</span>
                <span style="font-size: 18px; font-weight: bold; color: #ef4444; margin-left: 24px;">Stack Destroyed</span>
              </div>
            </div>
            

            <div style="display: flex; justify-content: center; margin: 16px 0;">
              <div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                <button class="powerup-btn bomb-btn" style="pointer-events: none; min-width: 60px; min-height: 60px; padding: 0 8px;">
                  <span class="powerup-emoji" style="font-size: 24px;">💣</span>
                  <div class="powerup-cost">
                    <span class="cost-emoji">💰</span>
                    <span class="cost-amount">25</span>
                  </div>
                </button>
                <span style="color: #f8fafc; font-size: 14px; text-align: center;">Converts next block to bomb</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Trash Can Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🗑️</span>
            <h3>Trash Can</h3>
          </div>
          <div class="help-content">
            <p>The trash can power-up allows you to remove the next block from the queue.</p>
            <div style="display: flex; justify-content: center; margin: 16px 0;">
              <div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                <button class="powerup-btn" style="pointer-events: none; min-width: 60px; min-height: 60px; padding: 0 8px;">
                  <span class="powerup-emoji" style="font-size: 24px;">🗑️</span>
                  <div class="powerup-cost">
                    <span class="cost-emoji">💰</span>
                    <span class="cost-amount">25</span>
                  </div>
                </button>
                <span style="color: #f8fafc; font-size: 14px; text-align: center;">Removes next block</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Gold Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">💰</span>
            <h3>Gold</h3>
          </div>
          <div class="help-content">
            <p><strong>Earn gold by merging blocks!</strong></p>
            <p>Each additional merge in a cascade earns additional gold.</p>
            <p>Use gold to buy power-ups, but use them strategically as power-ups double in cost each time they are used.</p>
          </div>
        </div>

        <!-- Stage System Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🚀</span>
            <h3>Stage Progression</h3>
          </div>
          <div class="help-content">
            <p>Merge two 512 blocks to create a 1024 block and gain a gold multiplier of 10x.</p>
            <p>Merging two 1024 blocks will increase the multiplier to 100x.</p>
            <p>Each additional block size up will increase your multiplier by 10x.</p>
            <div class="merge-example" style="justify-content: center; gap: 40px; padding: 20px;">
              <div style="display: flex; flex-direction: column; gap: 20px; align-items: center; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div style="margin: 0; justify-self: end;">
                    <div style="display: flex; align-items: center; justify-content: center;">
                      <div class="next-stage-block" data-value="1024" style="width: 100px; height: 42px; font-size: 22px; border-radius: 9px; display: flex; align-items: center; justify-content: center; font-weight: 600; box-shadow: 0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family);">1024</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div class="gold-display" style="margin: 0; justify-self: start;">
                    <div class="gold-value" style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 8px 16px; border-radius: 9px; font-weight: 600; font-size: 18px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div class="gold-emoji" style="position: absolute; top: -10px; left: -10px; font-size: 24px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div class="gold-text" style="position: relative; z-index: 2; font-size: 18px; font-weight: 600; line-height: 1; color: #000;">1.5k</div>
                      <div class="stage-multiplier-badge" style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 11px; font-weight: 700; padding: 3px 5px; border-radius: 8px; border: 2px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 20px; text-align: center;">10x</div>
                    </div>
                  </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div style="margin: 0; justify-self: end;">
                    <div style="display: flex; align-items: center; justify-content: center;">
                      <div class="next-stage-block" data-value="2048" style="width: 100px; height: 42px; font-size: 22px; border-radius: 9px; display: flex; align-items: center; justify-content: center; font-weight: 600; box-shadow: 0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family);">2048</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div class="gold-display" style="margin: 0; justify-self: start;">
                    <div class="gold-value" style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 8px 16px; border-radius: 9px; font-weight: 600; font-size: 18px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div class="gold-emoji" style="position: absolute; top: -10px; left: -10px; font-size: 24px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div class="gold-text" style="position: relative; z-index: 2; font-size: 18px; font-weight: 600; line-height: 1; color: #000;">15.5k</div>
                      <div class="stage-multiplier-badge" style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 11px; font-weight: 700; padding: 3px 5px; border-radius: 8px; border: 2px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 20px; text-align: center;">100x</div>
                    </div>
                  </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div style="margin: 0; justify-self: end;">
                    <div style="display: flex; align-items: center; justify-content: center;">
                      <div class="next-stage-block" data-value="4096" style="width: 100px; height: 42px; font-size: 22px; border-radius: 9px; display: flex; align-items: center; justify-content: center; font-weight: 600; box-shadow: 0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family);">4096</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div class="gold-display" style="margin: 0; justify-self: start;">
                    <div class="gold-value" style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 8px 16px; border-radius: 9px; font-weight: 600; font-size: 18px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div class="gold-emoji" style="position: absolute; top: -10px; left: -10px; font-size: 24px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div class="gold-text" style="position: relative; z-index: 2; font-size: 18px; font-weight: 600; line-height: 1; color: #000;">555.5k</div>
                      <div class="stage-multiplier-badge" style="position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 11px; font-weight: 700; padding: 3px 5px; border-radius: 8px; border: 2px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 20px; text-align: center;">1000x</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Sound Controls Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🔊</span>
            <h3>Sound Controls</h3>
          </div>
          <div class="help-content">
            <p>Customize your audio experience with the sound control menu.</p>
            <p><strong>Volume Slider:</strong> Adjust the overall volume from 0% (muted) to 100% (full volume).</p>
            <p><strong>Mute Toggle:</strong> Quickly mute or unmute all game sounds with a single click.</p>
            <p><strong>Sound Effects:</strong> The game includes various sound effects for merging blocks, collecting gold, using power-ups, and more.</p>
            <p>Access the sound controls by clicking the speaker icon in the top bar.</p>
          </div>
        </div>


      </div>



      <div class="actions" style="justify-content: flex-start;">
        <button id="resetDataBtn" class="ai-btn" style="background-color: #dc2626; color: white;" title="Clear all game data and cookies">Clear All Data</button>
      </div>
    </div>
  </div>

  <!-- Player Statistics Modal (hidden by default) -->
  <div id="statsModal" class="modal-backdrop stats-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="statsTitle">
    <div class="modal stats-modal">
      <h2 id="statsTitle">Player Statistics</h2>
      
      <div class="stats-content">
        <div class="stat-line">
          <span class="stat-label">🏆 All Time High Score:</span>
          <span class="stat-value" id="statsHighScore">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">💰 Lifetime Gold Earned:</span>
          <span class="stat-value" id="statsLifetimeGold">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">📦 Total Blocks Dropped:</span>
          <span class="stat-value" id="statsTotalBlocksDropped">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">💣 Total Bombs Exploded:</span>
          <span class="stat-value" id="statsTotalBombsExploded">0</span>
        </div>
        
        <div class="stat-line">
          <span class="stat-label">🗑️ Total Blocks Trashed:</span>
          <span class="stat-value" id="statsTotalBlocksTrashed">0</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Debug pane (hidden by default) -->
  <div id="debugPane" class="debug-pane">
    <button class="close-btn" id="debugClose" title="Close debug pane">×</button>
    <h3>Debug Controls</h3>
    
    <div class="section">
      <div class="section-title">Game Speed</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugSpeedSlider">Speed:</label>
          <input type="range" id="debugSpeedSlider" min="0" max="4" value="2" step="1">
          <div class="value-display" id="debugSpeedLabel">Medium</div>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Probability Curve</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugDecaySlider">Decay Factor:</label>
          <input type="range" id="debugDecaySlider" min="0.1" max="0.9" value="0.7" step="0.05">
          <div class="value-display" id="debugDecayLabel">0.70</div>
        </div>
        <div class="control-row">
          <button id="debugUpdateProbBtn" class="button">Update Probabilities</button>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Theme Settings</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugThemeSelector">Theme:</label>
                      <select id="debugThemeSelector" class="theme-selector">
              <option value="jellyfish">Jellyfish</option>
              <option value="alternate">Earth</option>
            </select>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Sound Settings</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugVolumeSlider">Volume:</label>
          <input type="range" id="debugVolumeSlider" min="0" max="100" value="30" step="5">
          <div class="value-display" id="debugVolumeLabel">30%</div>
        </div>
        <div class="control-row">
          <label for="debugMuteToggle">Mute:</label>
          <input type="checkbox" id="debugMuteToggle">
          <div class="value-display" id="debugMuteStatus">No</div>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Custom Block Dropper</div>
      <div class="controls">
        <div class="control-row">
          <label for="bombToggle">Bomb:</label>
          <input type="checkbox" id="bombToggle">
          <div class="value-display" id="bombStatus">No</div>
        </div>
        <div class="block-grid">
          <div class="block-item no-block" data-value="none">No Block</div>
          <div class="block-item" data-value="1">1</div>
          <div class="block-item" data-value="2">2</div>
          <div class="block-item" data-value="4">4</div>
          <div class="block-item" data-value="8">8</div>
          <div class="block-item" data-value="16">16</div>
          <div class="block-item" data-value="32">32</div>
          <div class="block-item" data-value="64">64</div>
          <div class="block-item" data-value="128">128</div>
          <div class="block-item" data-value="256">256</div>
          <div class="block-item" data-value="512">512</div>
          <div class="block-item" data-value="1024">1024</div>
          <div class="block-item" data-value="2048">2048</div>
          <div class="block-item" data-value="4096">4096</div>
          <div class="block-item" data-value="8192">8192</div>
          <div class="block-item" data-value="16384">16.4k</div>
        </div>
        <div class="selected-block-info">
          <button id="cascadeTestBtn" class="button primary">Cascade Test</button>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Game State</div>
      <div class="controls">
        <table class="debug-stats-table">
          <tr><td>Score:</td><td id="debugScore">0</td></tr>
          <tr><td>Gold:</td><td id="debugGold">0</td></tr>
          <tr><td>Stacks:</td><td id="debugStacks">4</td></tr>
          <tr><td>Capacity:</td><td id="debugCapacity">10</td></tr>
          <tr><td>Target:</td><td id="debugTarget">1024</td></tr>
          <tr><td>Max Block:</td><td id="debugMaxBlock">512</td></tr>
          <tr><td>Blocks Dropped:</td><td id="debugBlocksDropped">0</td></tr>
                      <tr><td>Total Blocks Dropped:</td><td id="debugTotalBlocksDropped">0</td></tr>
            <tr><td>Total Bombs Exploded:</td><td id="debugTotalBombsExploded">0</td></tr>
            <tr><td>Total Blocks Trashed:</td><td id="debugTotalBlocksTrashed">0</td></tr>
            <tr><td>Bomb Status:</td><td id="debugBombStatus">Disabled</td></tr>
          <tr><td>Stage:</td><td id="debugStage">1</td></tr>
        </table>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Current Probabilities</div>
      <div class="controls">
        <div id="debugProbabilities" style="font-size: 12px; font-family: monospace; max-height: 200px; overflow-y: auto; background: var(--bg); padding: 8px; border-radius: 4px; border: 1px solid #475569;">
          <!-- Probabilities will be populated here -->
        </div>
        <div class="control-row" style="margin-top: 12px;">
          <button id="testProbBtn" class="button">Test Probabilities</button>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Test Features</div>
      <div class="controls">
        <div class="control-row">
          <button id="testPersonalBestBtn" class="button primary">Test Personal Best Message</button>
        </div>
        <div class="control-row">
          <button id="testGameOverBtn" class="button primary">Test Game Over Screen</button>
        <button id="testUnlockThemeBtn" class="button primary">Test Theme Unlock</button>
        <button id="testLockThemeBtn" class="button primary">Test Theme Lock</button>
        </div>
      </div>
    </div>
    
    <div class="section bottom-buttons">
      <div class="controls">
        <div class="button-row">
          <button id="debugAiToggle" class="button primary">Auto Play: Off</button>
          <button id="grantScoreBtn" class="button primary">Grant 1000 Score</button>
<button id="grantGoldBtn" class="button primary">Grant 1000 Gold</button>
        </div>
      </div>
    </div>
  </div>

<script>
// Environment Detection
const isLocalhost = (() => {
  const hostname = window.location.hostname;
  const protocol = window.location.protocol;
  const port = window.location.port;
  
  // Check for localhost variations
  const localhostPatterns = [
    'localhost',
    '127.0.0.1',
    '::1',
    '0.0.0.0'
  ];
  
  // Check for common development ports
  const devPorts = ['3000', '8000', '8080', '5000', '5173', '4173', '3001'];
  
  // Check for file protocol (local file)
  const isFileProtocol = protocol === 'file:';
  
  // Check if it's localhost or development environment
  const isLocal = localhostPatterns.includes(hostname) || 
                  devPorts.includes(port) || 
                  isFileProtocol ||
                  hostname.includes('.local') ||
                  hostname.includes('.test');
  
  // Environment detection complete
  
  // Add environment indicator to page title in development
  if (isLocal) {
    document.title = `[DEV] ${document.title}`;
    
    // Enable scrolling in development mode for debug access
    document.body.classList.add('development-mode');
  }
  
  return isLocal;
})();

// Utility functions for environment detection
const isDevelopment = () => isLocalhost;
const isProduction = () => !isLocalhost;
const getEnvironment = () => isLocalhost ? 'development' : 'production';

// Sound Manager for Stack Merge Game - Web Audio API Implementation
class SoundManager {
  constructor() {
    this.isMuted = false;
    // Always use cork sounds for merges
    this.volume = 0.3; // Default volume (30%)
    this.initialized = false; // Will be set to true after Web Audio API initialization
    
    // Individual sound type volumes (0-5 scale, converted to 0.0-1.0 internally)
    this.soundVolumes = {
      drop: 3,      // Drop sounds
      merge: 3,     // Merge sounds
      coin: 3,      // Gold coin sounds
      bomb: 3,      // Bomb explosion sounds
      other: 3      // Other sounds (stage up, etc.)
    };
    
    // Web Audio API components
    this.audioContext = null;
    this.audioBuffers = {};
    this.audioUnlocked = false;
    
    // Track initialization state
    this.initializationPromise = null;
    
    // Debug localStorage to check for corrupted settings
    this.debugLocalStorage();
    
    // Initialize Web Audio API system
    this.initializeWebAudioSystem();
  }
  

  

  
  // Initialize Web Audio API system
  async initializeWebAudioSystem() {
    try {
      
      // Create audio context
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Define all sound files that need to be loaded
      this.audioFiles = {
        drop: 'sounds/click2.wav',
        bomb: 'sounds/bomb.mp3',
        stageUp: 'sounds/stage_up.mp3',
        stageProgression: 'sounds/stageprogression.mp3',
        newGame: 'sounds/newgame.mp3',
        gameOver: 'sounds/gameover.mp3',
        purchase: 'sounds/purchase.wav',
        personalBest: 'sounds/newrecord.mp3',
        themeUnlock: 'sounds/themeunlock.mp3'
      };
      
      // Cork sounds for merges
      for (let i = 0; i <= 9; i++) {
        this.audioFiles[`cork${i}`] = `sounds/cork${i}.wav`;
      }
      
      // Coin sounds
      for (let i = 1; i <= 7; i++) {
        this.audioFiles[`coin${i}`] = `sounds/coin${i}.wav`;
      }
      

      
      // Start loading audio buffers in background
      this.preloadAudioBuffers();
      
    } catch (error) {
      this.audioFiles = {};
    }
  }

  // Preload all audio files as buffers
  async preloadAudioBuffers() {
    const loadPromises = [];
    
    for (const [soundKey, filePath] of Object.entries(this.audioFiles)) {
      loadPromises.push(this.loadAudioBuffer(soundKey, filePath));
    }
    
    try {
      await Promise.all(loadPromises);
      this.initialized = true;
    } catch (error) {
      this.initialized = true; // Still mark as initialized to allow the game to continue
    }
  }

  // Load individual audio buffer
  async loadAudioBuffer(soundKey, filePath) {
    try {
      const response = await fetch(filePath);
      if (!response.ok) throw new Error(`Failed to fetch ${filePath}`);
      
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
      
      this.audioBuffers[soundKey] = audioBuffer;
      
    } catch (error) {
      // Silent error handling
    }
  }

  // Universal audio unlock method using Web Audio API (works on all devices including iOS)
  async unlockAudio() {
    if (this.audioUnlocked) {
      return Promise.resolve();
    }


    
    try {
      // Initialize Web Audio if not already done
      if (!this.audioContext) {
        await this.initializeWebAudioSystem();
      }
      
      // Resume audio context if suspended
      if (this.audioContext && this.audioContext.state === 'suspended') {
        let attempt = 1;
        
        while (this.audioContext.state === 'suspended' && attempt <= 1000) {
          try {
            const resumePromise = this.audioContext.resume();
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Timeout')), 1);
            });
            
            await Promise.race([resumePromise, timeoutPromise]);
            
            if (this.audioContext.state === 'running') break;
          } catch (error) {
            // Silent continue
          }
          
          attempt++;
        }
      }
      
      this.audioUnlocked = true;
      return Promise.resolve();
      
    } catch (error) {
      this.audioUnlocked = true; // Mark as unlocked anyway to prevent infinite retry
      return Promise.resolve();
    }
  }

  // Debug popup helper for iOS testing (disabled for normal gameplay)
  showDebugPopup(message) {
    // Silent debug helper
  }

  // Helper method to safely play audio with proper promise handling
  safePlayAudio(audio) {
    const playPromise = audio.play();
    if (playPromise) {
      return playPromise.then(() => {
        // Audio played successfully
      }).catch((error) => {
        throw error;
      });
    }
    // Return resolved promise for older browsers
    return Promise.resolve();
  }

  // Check if audio can be played on this device
  canPlayAudio() {
    return this.initialized && !this.isMuted && this.audioUnlocked;
  }
  
  // Debug localStorage to check for corrupted settings
  debugLocalStorage() {
    try {
      // Check if localStorage is available
      if (typeof localStorage !== 'undefined') {
        
        // Check for corrupted sound settings
        const soundSettings = localStorage.getItem('stackMerge_soundSettings');
        if (soundSettings) {
          try {
            const parsed = JSON.parse(soundSettings);
            
            // Check for suspicious values
            if (parsed.isMuted === true) {
              // Sound is muted
            }
            if (parsed.volume === 0) {
              // Master volume is 0
            }
            if (parsed.soundVolumes) {
              Object.entries(parsed.soundVolumes).forEach(([type, vol]) => {
                if (vol === 0) {
                  // Volume is 0
                }
              });
            }
          } catch (parseError) {
            // Clear corrupted data
            localStorage.removeItem('stackMerge_soundSettings');
          }
        } else {
          // No sound settings found
        }
      } else {
        // localStorage not available
      }
    } catch (error) {
      // Silent error handling
    }
  }
  
  // Simple, reliable audio system that works on all devices
  // Play sound using Web Audio API
  async playWebAudio(soundKey, volumeType = 'other') {
    if (!this.audioContext || !this.audioBuffers[soundKey]) {
      return false;
    }
    
    try {
      // Resume audio context if suspended
      if (this.audioContext.state === 'suspended') {
        await this.audioContext.resume();
        if (this.audioContext.state === 'suspended') return false;
      }
      
      if (this.audioContext.state !== 'running') return false;
      
      // Create audio nodes
      const source = this.audioContext.createBufferSource();
      const gainNode = this.audioContext.createGain();
      
      // Set up audio graph
      source.buffer = this.audioBuffers[soundKey];
      source.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      // Set volume based on type and settings
      const volume = this.getActualVolume(volumeType);
      gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
      
      // Play the sound
      source.start(0);
      
      return true;
    } catch (error) {
      return false;
    }
  }
  
  // Enhanced method to play any sound with Web Audio API fallback
  async playSound(soundKey, volumeType = 'other') {
    if (!this.canPlayAudio()) {
      return Promise.reject('Audio not available');
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      await this.unlockAudio();
    }
    
    // Try Web Audio API first
    const webAudioSuccess = await this.playWebAudio(soundKey, volumeType);
    if (webAudioSuccess) {
      return Promise.resolve();
    }
    
    // Fallback to traditional Audio element for compatibility
    if (this.audioFiles && this.audioFiles[soundKey]) {
      try {
        const audio = new Audio(this.audioFiles[soundKey]);
        audio.volume = this.getActualVolume(volumeType);
        return this.safePlayAudio(audio);
      } catch (error) {
        return Promise.reject(`Fallback audio failed: ${error.message}`);
      }
    }
    
    return Promise.reject(`Sound ${soundKey} not found`);
  }
  

  
  // Play the drop sound effect - simple and reliable
  playDropSound(blockValue = 1) {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playDropSound(blockValue));
      return;
    }
    
    // Use the simple playSound method
    this.playSound('drop', 'drop').catch(error => {
      // Silent error handling
    });
  }
  
  // Generate a peaceful, raindrop-like merge sound effect with cascade progression
  playMergeSound(blockValue = 1) {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playMergeSound(blockValue));
      return;
    }
    
    try {
      // Get the current merge count for cascade sounds
      const mergeCount = this.getCurrentMergeCount();
      
      // Determine which cork sound to play based on cascade position
      let corkSoundKey;
      if (mergeCount <= 1) {
        corkSoundKey = 'cork0'; // First merge
      } else if (mergeCount <= 10) {
        corkSoundKey = `cork${mergeCount - 1}`; // cork1 through cork9
      } else {
        corkSoundKey = 'cork9'; // Any remaining merges use cork9
      }
      
      // Use simple playSound method
      this.playSound(corkSoundKey, 'merge').catch(error => {
        // Silent error handling
      });
    } catch (error) {
      // Silent fail - no console spam
    }
  }
  

  

  


  // Set master volume (0.0 to 1.0)
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(1, volume));
    this.saveSoundSettings();
  }
  
  // Toggle mute state
  toggleMute() {
    this.isMuted = !this.isMuted;
    this.saveSoundSettings();
    return this.isMuted;
  }
  
  // Get current mute state
  getMuteState() {
    return this.isMuted;
  }
  
  // Get current volume
  getVolume() {
    return this.volume;
  }
  

  
  // Get current merge sound type preference (always cork sounds now)
  getMergeSoundType() {
    return true; // Always return true for cork sounds
  }
  
  // Set individual sound type volume (0-5 scale)
  setSoundVolume(soundType, volume) {
    if (this.soundVolumes.hasOwnProperty(soundType)) {
      const oldVolume = this.soundVolumes[soundType];
      this.soundVolumes[soundType] = Math.max(0, Math.min(5, Math.round(volume)));
      this.saveSoundSettings();
    }
  }
  
  // Get individual sound type volume (0-5 scale)
  getSoundVolume(soundType) {
    // Check if the sound type exists and has a value (including 0)
    if (this.soundVolumes.hasOwnProperty(soundType)) {
      return this.soundVolumes[soundType];
    }
    // Only return default 3 if the sound type doesn't exist at all
    return 3;
  }
  
  // Get all sound volumes
  getAllSoundVolumes() {
    return { ...this.soundVolumes };
  }
  
  // Set all sound volumes at once
  setAllSoundVolumes(volumes) {
    Object.keys(volumes).forEach(soundType => {
      if (this.soundVolumes.hasOwnProperty(soundType)) {
        const oldVolume = this.soundVolumes[soundType];
        const newVolume = Math.max(0, Math.min(5, Math.round(volumes[soundType])));
        this.soundVolumes[soundType] = newVolume;
      }
    });
  }
  
  // Convert volume scale (0-5) to actual volume (0.0-2.0 for drop/merge, 0.0-1.0 for others)
  getActualVolume(soundType) {
    // If the sound type has a specific volume, use it
    if (this.soundVolumes.hasOwnProperty(soundType)) {
      const volume = this.soundVolumes[soundType];
      let actualVolume;
      
      if (soundType === 'merge') {
        // Enhanced volume scaling for merge sounds: 0 = mute, 1 = quiet, 5 = very loud
        // This gives merge sounds much more presence while keeping the same user control
        // Map 0-5 to 0-1 with a curve that emphasizes higher volumes
        actualVolume = volume === 0 ? 0 : Math.pow(volume / 5, 0.7); // Curved mapping for more presence
      } else {
        // Standard 5-level scaling for all other sounds (drop, coin, bomb, other): 0 = mute, 1 = very quiet, 5 = loud
        // Map 0-5 to 0-1 linearly
        actualVolume = volume === 0 ? 0 : volume / 5;
      }
      
      return actualVolume;
    }
    
    // If no specific volume is set, fall back to "Other" volume
    const fallbackVolume = this.soundVolumes.other || 3;
    let fallbackActual;
    
    fallbackActual = fallbackVolume === 0 ? 0 : fallbackVolume / 5;
    
    return fallbackActual;
  }
  
  // Save sound settings to localStorage
  saveSoundSettings() {
    try {
      const settings = {
        isMuted: this.isMuted,
        volume: this.volume,
        soundVolumes: this.soundVolumes,
        timestamp: Date.now()
      };
      localStorage.setItem('stackMerge_soundSettings', JSON.stringify(settings));
    } catch (error) {
      // Silent error handling
    }
  }
  
  // Load sound settings from localStorage
  loadSoundSettings() {
    try {
      const saved = localStorage.getItem('stackMerge_soundSettings');
      if (saved) {
        const settings = JSON.parse(saved);
        
        // Load settings with validation
        if (typeof settings.isMuted === 'boolean') this.isMuted = settings.isMuted;
        if (typeof settings.volume === 'number') this.volume = Math.max(0, Math.min(1, settings.volume));

        
        // Load individual sound volumes
        if (settings.soundVolumes && typeof settings.soundVolumes === 'object') {
          Object.keys(settings.soundVolumes).forEach(soundType => {
            if (this.soundVolumes.hasOwnProperty(soundType)) {
              const vol = settings.soundVolumes[soundType];
              if (typeof vol === 'number' && vol >= 0 && vol <= 5) {
                this.soundVolumes[soundType] = Math.round(vol);
              }
            }
          });
        }
        
        return true;
      }
    } catch (error) {
      // If loading fails, reset to defaults and clear corrupted data
      this.resetAudioSettings();
    }
    return false;
  }
  
  // Reset audio settings to defaults (useful for fixing corrupted settings)
  resetAudioSettings() {
    // Reset to default values
    this.isMuted = false;
    this.volume = 0.3;

    this.soundVolumes = {
      drop: 3,
      merge: 3,
      coin: 3,
      bomb: 3,
      other: 3
    };
    
    // Clear corrupted localStorage data
    try {
      localStorage.removeItem('stackMerge_soundSettings');
    } catch (error) {
      // Silent error handling
    }
    
    // Save fresh default settings
    this.saveSoundSettings();
  }
  

  
  // Play a random coin sound effect when gold is earned
  playCoinSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playCoinSound());
      return;
    }
    
    try {
      // Randomly select one of the 7 coin sounds
      const coinNumber = Math.floor(Math.random() * 7) + 1;
      const coinKey = `coin${coinNumber}`;
      
      // Use the simple playSound method
      this.playSound(coinKey, 'coin').catch(error => {
        // Silent error handling
      });
    } catch (error) {
      // Silent error handling
    }
  }
  

  

  




  // Load and play the new game sound effect
  playNewGameSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playNewGameSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('newGame', 'other').catch(error => {
      // Silent error handling
    });
  }

  // Load and play the stage progression sound effect
  playStageProgressionSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playStageProgressionSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('stageProgression', 'other').catch(error => {
      // Silent error handling
    });
  }

  // Load and play the game over sound effect
  playGameOverSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playGameOverSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('gameOver', 'other').catch(error => {
      // Silent error handling
    });
  }

  // Load and play the bomb explosion sound effect
  playBombSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playBombSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('bomb', 'bomb').catch(error => {
      // Silent error handling
    });
  }







  // Play purchase sound effect
  playPurchaseSound() {
    if (!this.canPlayAudio()) {
      return;
    }
    
    // Ensure audio is unlocked first
    if (!this.audioUnlocked) {
      this.unlockAudio().then(() => this.playPurchaseSound());
      return;
    }
    
    // Use the simple playSound method
    this.playSound('purchase', 'other').catch(error => {
      // Silent error handling
    });
  }

  // Merge count tracking for cascade effects - COMPLETELY SEPARATE FROM AUDIO
  getCurrentMergeCount() {
    return this._currentMergeCount || 0;
  }

  setCurrentMergeCount(count) {
    this._currentMergeCount = count;
  }

  // Debug function for coin sound status - COMPLETELY SEPARATE FROM AUDIO
  getCoinSoundStatus() {
    return {
      loaded: true,
      count: 1,
      expected: 1
    };
  }
  
  // Check if all sounds are preloaded and ready for playback
  areSoundsPreloaded() {
    if (!this.audioBuffers) return false;
    
    const requiredSounds = [
      'drop', 'cork0', 'cork1', 'cork2', 'cork3', 'cork4', 'cork5', 'cork6', 'cork7', 'cork8', 'cork9',
      'coin1', 'coin2', 'coin3', 'coin4', 'coin5', 'coin6', 'coin7',
      'bomb', 'stageUp', 'stageProgression', 'newGame', 'gameOver', 'purchase'
    ];
    
    return requiredSounds.every(soundKey => 
      this.audioBuffers[soundKey] && this.audioBuffers[soundKey] instanceof AudioBuffer
    );
  }
  
  // Get preloading status for debugging
  getPreloadStatus() {
    if (!this.audioBuffers) return { status: 'not_initialized', loaded: 0, total: 0 };
    
    const requiredSounds = [
      'drop', 'cork0', 'cork1', 'cork2', 'cork3', 'cork4', 'cork5', 'cork6', 'cork7', 'cork8', 'cork9',
      'coin1', 'coin2', 'coin3', 'coin4', 'coin5', 'coin6', 'coin7',
      'bomb', 'stageUp', 'stageProgression', 'newGame', 'gameOver', 'purchase'
    ];
    
    const loadedSounds = requiredSounds.filter(soundKey => 
      this.audioBuffers[soundKey] && this.audioBuffers[soundKey] instanceof AudioBuffer
    );
    
    return {
      status: loadedSounds.length === requiredSounds.length ? 'fully_loaded' : 'partially_loaded',
      loaded: loadedSounds.length,
      total: requiredSounds.length,
      bufferStatus: requiredSounds.reduce((acc, soundKey) => {
        if (this.audioBuffers[soundKey]) {
          acc[soundKey] = 'loaded';
        } else {
          acc[soundKey] = 'missing';
        }
        return acc;
      }, {})
    };
  }
  
  // Force reload all sounds (useful for troubleshooting)
  reloadAllSounds() {
    this.audioBuffers = {};
    this.initialized = false;
    this.initializeWebAudioSystem();
  }
  
  // Wait for all sounds to be ready (returns a promise)
  waitForSoundsReady() {
    return new Promise((resolve) => {
      if (this.areSoundsPreloaded()) {
        resolve();
        return;
      }
      
      // Check every 100ms until sounds are ready
      const checkInterval = setInterval(() => {
        if (this.areSoundsPreloaded()) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
      
      // Timeout after 10 seconds
      setTimeout(() => {
        clearInterval(checkInterval);
        resolve();
      }, 10000);
    });
  }
  
  // Get preloading progress as a percentage
  getPreloadProgress() {
    if (!this.audioBuffers) return 0;
    
    const requiredSounds = [
      'drop', 'cork0', 'cork1', 'cork2', 'cork3', 'cork4', 'cork5', 'cork6', 'cork7', 'cork8', 'cork9',
      'coin1', 'coin2', 'coin3', 'coin4', 'coin5', 'coin6', 'coin7',
      'bomb', 'stageUp', 'stageProgression', 'newGame', 'gameOver', 'purchase'
    ];
    
    const loadedSounds = requiredSounds.filter(soundKey => 
      this.audioBuffers[soundKey] && this.audioBuffers[soundKey] instanceof AudioBuffer
    );
    
    return Math.round((loadedSounds.length / requiredSounds.length) * 100);
  }
  
  // Check if a specific sound buffer is ready for playback
  isSoundReady(soundKey) {
    return this.audioBuffers && 
           this.audioBuffers[soundKey] && 
           this.audioBuffers[soundKey] instanceof AudioBuffer;
  }
  
  // Get the number of sound buffers currently loaded
  getLoadedSoundCount() {
    if (!this.audioBuffers) return 0;
    
    const requiredSounds = [
      'drop', 'cork0', 'cork1', 'cork2', 'cork3', 'cork4', 'cork5', 'cork6', 'cork7', 'cork8', 'cork9',
      'coin1', 'coin2', 'coin3', 'coin4', 'coin5', 'coin6', 'coin7',
      'bomb', 'stageUp', 'stageProgression', 'newGame', 'gameOver', 'purchase'
    ];
    
    return requiredSounds.filter(soundKey => this.isSoundReady(soundKey)).length;
  }
  
  // Get comprehensive sound system status
  getSoundSystemStatus() {
    return {
      initialized: this.initialized,
      muted: this.isMuted,
      masterVolume: this.volume,
      soundVolumes: this.soundVolumes,
      preloadProgress: this.getPreloadProgress(),
      loadedCount: this.getLoadedSoundCount(),
      totalSounds: 23, // Total number of required sounds
      ready: this.areSoundsPreloaded(),
      webAudioContext: this.audioContext ? this.audioContext.state : 'not initialized',
      audioUnlocked: this.audioUnlocked,
      buffersLoaded: Object.keys(this.audioBuffers || {}).length
    };
  }
}

// Theme Manager for Stack Merge Game
class ThemeManager {
  constructor() {
    this.currentTheme = 'jellyfish'; // Default theme
    this.availableThemes = ['jellyfish', 'alternate'];
    
    // Theme unlock requirements
    this.themeUnlockRequirements = {
      'jellyfish': { unlocked: true, requirement: 'Default theme' },
      'alternate': { unlocked: false, requirement: 'Score 5000+ points' }
    };
    
    // Load saved theme and unlock status from localStorage (but don't apply it yet)
    this.loadTheme();
    
          // Check if we need to force reset unlocks (from clear all data operation)
    try {
      const forceReset = localStorage.getItem('stackMerge_forceResetUnlocks');
      if (forceReset === 'true') {
        localStorage.removeItem('stackMerge_forceResetUnlocks');
        // Don't load unlock status, keep defaults
      } else {
        // Only load unlock status if not prevented by clear operation
        if (!window.preventThemeUnlockLoad) {
          this.loadUnlockStatus();
        } else {
          window.preventThemeUnlockLoad = false; // Reset the flag
        }
      }
    } catch (e) {
      // Fall back to normal loading
      if (!window.preventThemeUnlockLoad) {
        this.loadUnlockStatus();
      }
    }
    
    // Don't apply theme in constructor - will be applied after game initialization
  }
  
  // Get current theme
  getCurrentTheme() {
    return this.currentTheme;
  }
  
  // Get available themes
  getAvailableThemes() {
    return this.availableThemes;
  }
  
  // Apply a specific theme
  applyTheme(themeName) {
    if (!this.availableThemes.includes(themeName)) {
      themeName = 'jellyfish';
    }
    
    // Check if theme is unlocked
    if (!this.isThemeUnlocked(themeName)) {
      return false;
    }
    
    // Remove all theme classes from body
    document.body.classList.remove('theme-alternate');
    
    // Add the selected theme class
    if (themeName === 'alternate') {
      document.body.classList.add('theme-alternate');
    }
    
    this.currentTheme = themeName;
    
    // Save theme preference
    this.saveTheme();
    
    // Re-rendering game to apply new theme colors...
    if (typeof render === 'function') {
      render();
    }
    
      // Re-rendering next queue to apply new theme colors...
  if (typeof renderNext === 'function') {
    renderNext();
  }
  
  // Update debug custom dropper block colors
  updateDebugBlockColors();
  
  return true;
  }
  
  // Save theme to localStorage
  saveTheme() {
    try {
      localStorage.setItem('stackMerge_theme', this.currentTheme);
    } catch (error) {
      // Silent error handling
    }
  }
  
  // Load theme from localStorage
  loadTheme() {
    try {
      const savedTheme = localStorage.getItem('stackMerge_theme');
      if (savedTheme && this.availableThemes.includes(savedTheme)) {
        this.currentTheme = savedTheme;
      } else {
        this.currentTheme = 'jellyfish';
      }
    } catch (error) {
      this.currentTheme = 'jellyfish';
    }
  }
  
  // Initialize theme after game is ready
  initializeTheme() {
    this.applyTheme(this.currentTheme);
  }
  
  // Reset theme to default
  resetTheme() {
    this.applyTheme('jellyfish');
  }
  
  // Check if a theme is unlocked
  isThemeUnlocked(themeName) {
    return this.themeUnlockRequirements[themeName]?.unlocked || false;
  }
  
  // Get unlock requirement for a theme
  getThemeRequirement(themeName) {
    return this.themeUnlockRequirements[themeName]?.requirement || 'Unknown requirement';
  }
  
  // Unlock a theme
  unlockTheme(themeName) {
    if (this.themeUnlockRequirements[themeName]) {
      this.themeUnlockRequirements[themeName].unlocked = true;
      this.saveUnlockStatus();
      return true;
    }
    return false;
  }
  
  // Get all unlocked themes
  getUnlockedThemes() {
    return this.availableThemes.filter(theme => this.isThemeUnlocked(theme));
  }
  
  // Save unlock status to localStorage
  saveUnlockStatus() {
    try {
      const unlockData = {};
      for (const [theme, data] of Object.entries(this.themeUnlockRequirements)) {
        unlockData[theme] = { unlocked: data.unlocked, requirement: data.requirement };
      }
      localStorage.setItem('stackMerge_themeUnlocks', JSON.stringify(unlockData));
    } catch (error) {
      // Silent error handling
    }
  }
  
  // Load unlock status from localStorage
  loadUnlockStatus() {
    try {
      const unlockData = localStorage.getItem('stackMerge_themeUnlocks');
      if (unlockData) {
        const savedUnlocks = JSON.parse(unlockData);
        // Merge saved unlocks with current requirements
        for (const [theme, data] of Object.entries(savedUnlocks)) {
          if (this.themeUnlockRequirements[theme]) {
            this.themeUnlockRequirements[theme].unlocked = data.unlocked;
          }
        }
      }
    } catch (error) {
      // Silent error handling
    }
  }
}



// Function to update theme selectors with unlock status
function updateThemeSelectors() {
  const themeSelectors = ['themeSelector', 'debugThemeSelector'];
  
  themeSelectors.forEach(selectorId => {
    const selector = document.getElementById(selectorId);
    if (selector) {
      // Clear existing options
      selector.innerHTML = '';
      
      // Add themes with unlock status
      themeManager.availableThemes.forEach(theme => {
        const option = document.createElement('option');
        option.value = theme;
        
        if (themeManager.isThemeUnlocked(theme)) {
          option.textContent = theme === 'jellyfish' ? 'Jellyfish' : 'Earth';
          option.disabled = false;
        } else {
          option.textContent = `${theme === 'jellyfish' ? 'Jellyfish' : 'Earth'} (🔒 ${themeManager.getThemeRequirement(theme)})`;
          option.disabled = true;
        }
        
        selector.appendChild(option);
      });
      
      // Set current theme
      selector.value = themeManager.getCurrentTheme();
    }
  });
}

// Function to update debug custom dropper block colors based on current theme
function updateDebugBlockColors() {
  const currentTheme = themeManager ? themeManager.getCurrentTheme() : 'jellyfish';
  
  // Update all block-item elements in the debug pane
  const debugBlocks = document.querySelectorAll('.debug-pane .block-item[data-value]');
  debugBlocks.forEach(block => {
    const value = block.getAttribute('data-value');
    
    // Skip the "no-block" option
    if (value === 'none') return;
    
    const numValue = parseInt(value);
    if (!isNaN(numValue)) {
      // Apply theme colors using the same functions as the game
      block.style.background = colorFor(numValue);
      block.style.color = getTextColorFor(numValue);
    }
  });
  
  // Also update the largest merge block in the game over screen if it exists
  const largestMergeBlock = document.getElementById('largestMergeBlock');
  if (largestMergeBlock && largestMergeBlock.hasAttribute('data-value')) {
    const value = largestMergeBlock.getAttribute('data-value');
    const numValue = parseInt(value);
    if (!isNaN(numValue)) {
      // Apply theme colors using the same functions as the game
      largestMergeBlock.style.background = colorFor(numValue);
      largestMergeBlock.style.color = getTextColorFor(numValue);
    }
  }
}

// Initialize sound manager
const soundManager = new SoundManager();

// Initialize theme manager
const themeManager = new ThemeManager();

// Load saved sound settings
soundManager.loadSoundSettings();

// weights and probabilities - will be dynamically updated based on stage
let weights = [1, 2]; // Start with 1 and 2, unlock others as player progresses
let probabilities = [0.5, 0.5]; // Equal chance for 1 and 2 initially

// localStorage-based save system
const SAVE_KEY = 'stackMerge_save';

// Update notification system
let lastSeenUpdateTimestamp = 0; // Track when user last saw updates
let preventTimestampRestore = false; // Flag to prevent timestamp restoration after clearing

// Help button state storage
const HELP_BUTTON_KEY = 'stackMerge_helpClicked';

// Save game state to localStorage
function saveGameState() {
  try {
    
    const gameState = {
      poles: poles,
      score: score || 0,
      gold: gold || 0,
      goldEarnedThisGame: goldEarnedThisGame || 0,
      lifetimeGoldEarned: lifetimeGoldEarned || 0,
      blocksDropped: blocksDropped || 0,
      totalBlocksDropped: totalBlocksDropped || 0,
      totalBombsExploded: totalBombsExploded || 0,
      totalBlocksTrashed: totalBlocksTrashed || 0,
      currentTargetBlockSize: currentTargetBlockSize || STARTING_BLOCK_SIZE,
      currentStage: currentStage || 1,
      weights: weights || [1, 2],
      probabilities: probabilities || [0.5, 0.5],
      nextQueue: nextQueue || [getRandomPiece(), getRandomPiece(), getRandomPiece()],
      bombConversionCost: bombConversionCost || 25,
      trashButtonCost: trashButtonCost || 25,
      bombConversionPresses: bombConversionPresses || 0,
      trashButtonPresses: trashButtonPresses || 0,
      bombSelected: bombSelected || false,
      previousBombCost: previousBombCost || bombConversionCost,

      soundVolumes: soundManager.getAllSoundVolumes(),
      isMuted: soundManager.getMuteState(),
      currentTheme: themeManager.getCurrentTheme(),
      themeUnlocks: themeManager.themeUnlockRequirements,
      currentActiveDecayFactor: currentActiveDecayFactor,
      lastSeenUpdateTimestamp: lastSeenUpdateTimestamp || 0,
      highScore: window.highScore || 0,
      totalGames: window.totalGames || 0,
      hasShownPersonalBest: hasShownPersonalBest || false,
      timestamp: Date.now()
    };
    
    const saveData = JSON.stringify(gameState);
    
    // Save to localStorage
    localStorage.setItem(SAVE_KEY, saveData);
  } catch (error) {
    // Silent error handling
  }
}

// Restore game state from loaded data
function restoreGameState(gameState) {
  try {
    
    // Validate the loaded data
    if (!gameState.poles || !Array.isArray(gameState.poles) || gameState.poles.length !== 4) {
      return false;
    }
    
    // Check if save is too old (more than 30 days)
    const saveAge = Date.now() - gameState.timestamp;
    const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 days in milliseconds
    if (saveAge > maxAge) {
      clearGameSave();
      return false;
    }
    
    // Restore game state
    const oldPoles = [...poles];
    const oldScore = score;
    const oldGold = gold;
    
    poles = gameState.poles;
    score = gameState.score || 0;
    gold = gameState.gold || 0;
    goldEarnedThisGame = gameState.goldEarnedThisGame || 0;
    lifetimeGoldEarned = gameState.lifetimeGoldEarned || 0;
    blocksDropped = gameState.blocksDropped || 0;
    totalBlocksDropped = gameState.totalBlocksDropped || 0;
    totalBombsExploded = gameState.totalBombsExploded || 0;
    totalBlocksTrashed = gameState.totalBlocksTrashed || 0;
    
    // Restore high score from saved state
    window.highScore = gameState.highScore || 0;
    
    // Restore total games counter from saved state
    window.totalGames = gameState.totalGames || 0;
    
    // Restore personal best flag from saved state
    hasShownPersonalBest = gameState.hasShownPersonalBest || false;
    
        // Restore gold tracking variables (with fallbacks for old saves)
    goldEarnedThisGame = gameState.goldEarnedThisGame || 0;
    lifetimeGoldEarned = gameState.lifetimeGoldEarned || 0;
    
    // Update statistics modal if it's open
    if (statsModal && !statsModal.classList.contains('hidden')) {
      updateStatsModal();
    }
    
    currentTargetBlockSize = gameState.currentTargetBlockSize || STARTING_BLOCK_SIZE;
    currentStage = gameState.currentStage || 1;
    weights = gameState.weights || [1, 2];
    probabilities = gameState.probabilities || [0.5, 0.5];
    nextQueue = gameState.nextQueue || [getRandomPiece(), getRandomPiece(), getRandomPiece()];
    
    // Restore the current active decay factor
    currentActiveDecayFactor = gameState.currentActiveDecayFactor || PROBABILITY_DECAY_FACTOR;
    
    // Restore button costs from saved state
    const oldBombCost = bombConversionCost;
    const oldTrashCost = trashButtonCost;
    bombConversionCost = gameState.bombConversionCost || 25;
    trashButtonCost = gameState.trashButtonCost || 25;
    bombConversionPresses = gameState.bombConversionPresses || 0;
    trashButtonPresses = gameState.trashButtonPresses || 0;
    
    // Restore bomb selection state from saved state
    bombSelected = gameState.bombSelected || false;
    previousBombCost = gameState.previousBombCost || bombConversionCost;
    

    
    // Restore sound volumes from saved state
    if (gameState.soundVolumes && typeof gameState.soundVolumes === 'object') {
      soundManager.setAllSoundVolumes(gameState.soundVolumes);
    }
    
    // Restore master mute state from saved state
    if (gameState.isMuted !== undefined) {
      soundManager.isMuted = gameState.isMuted;
    }
    
    // Restore theme from saved state
    if (gameState.currentTheme && themeManager.getAvailableThemes().includes(gameState.currentTheme)) {
      themeManager.applyTheme(gameState.currentTheme);
    }
    
    // Restore theme unlock status from saved state (unless prevented by force reset)
    if (gameState.themeUnlocks && typeof gameState.themeUnlocks === 'object' && !window.preventThemeUnlockLoad) {
      for (const [theme, data] of Object.entries(gameState.themeUnlocks)) {
        if (themeManager.themeUnlockRequirements[theme]) {
          themeManager.themeUnlockRequirements[theme].unlocked = data.unlocked;
        }
      }
    } else if (window.preventThemeUnlockLoad) {
      // Skipped theme unlock restoration due to force reset
    }
    
    // Update theme selectors after restoring unlock status
    if (typeof updateThemeSelectors === 'function') {
      updateThemeSelectors();
    }
    
    // Restore last seen update timestamp (unless prevented by clear operation)
    if (!preventTimestampRestore) {
      lastSeenUpdateTimestamp = gameState.lastSeenUpdateTimestamp || 0;
    } else {
      preventTimestampRestore = false; // Reset the flag
    }
    

    
    // Update sound button to reflect restored mute state
    const soundBtn = document.getElementById('soundBtn');
    if (soundBtn) {
      const isMuted = soundManager.getMuteState();
      soundBtn.textContent = isMuted ? '🔇' : '🔊';
      soundBtn.title = 'Sound Controls';
    }
    
    // Update cost displays after restoring game state
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostEl) {
      trashCostEl.textContent = formatNumber(trashButtonCost);
    }
    if (bombCostElMobile) {
      bombCostElMobile.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostElMobile) {
      trashCostElMobile.textContent = formatNumber(trashButtonCost);
    }
    
    // Update button states to reflect restored bomb selection state
    updateBombConversionButtonState();
    
    return true;
  } catch (error) {
    return false;
  }
}



// Load game state from localStorage
function loadGameState() {
  try {
    // Check if we need to force reset unlocks (from clear all data operation)
    try {
      const forceReset = localStorage.getItem('stackMerge_forceResetUnlocks');
      if (forceReset === 'true') {
        localStorage.removeItem('stackMerge_forceResetUnlocks');
        return false; // Don't load any game state, start fresh
      }
          } catch (e) {
        // Silent error handling
      }
    
    const saveData = localStorage.getItem(SAVE_KEY);
    if (saveData) {
      const gameState = JSON.parse(saveData);
      return restoreGameState(gameState);
    } else {
      return false;
    }
  } catch (error) {
    return false;
  }
}

// Update notification system functions
async function fetchUpdates() {
  try {
    const response = await fetch('updates.txt?' + Date.now()); // Add cache-busting
    if (!response.ok) {
      return [];
    }
    
    const text = await response.text();
    const lines = text.split('\n');
    const updates = [];
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      // Skip empty lines and comments
      if (!trimmedLine || trimmedLine.startsWith('#')) continue;
      
      const parts = trimmedLine.split('|');
      if (parts.length === 3) {
        const timestamp = parseInt(parts[0]);
        const title = parts[1];
        const message = parts[2];
        
        if (!isNaN(timestamp)) {
          updates.push({ timestamp, title, message });
        }
      }
    }
    
    // Sort updates by timestamp (newest first)
    updates.sort((a, b) => b.timestamp - a.timestamp);
    return updates;
  } catch (error) {
    return [];
  }
}

function checkForNewUpdates(updates) {
  // If this is a first-time user (lastSeenUpdateTimestamp is 0), only show the most recent update
  if (lastSeenUpdateTimestamp === 0 && updates.length > 0) {
    return [updates[0]]; // Only return the most recent update
  }
  
  // Find updates newer than the last seen timestamp
  const newUpdates = updates.filter(update => update.timestamp > lastSeenUpdateTimestamp);
  
  return newUpdates;
}

function showUpdateModal(updates) {
  if (updates.length === 0) return;
  
  // Get the newest update to show
  const latestUpdate = updates[0];
  
  // Create modal HTML
  const modalHtml = `
    <div class="modal-backdrop" id="updateModalBackdrop">
      <div class="modal update-modal">
        <h2>Stack Merge Updates</h2>
        <div class="update-content">
          <h3>${latestUpdate.title}</h3>
          <p>${latestUpdate.message}</p>
          ${updates.length > 1 ? `<p><em>+ ${updates.length - 1} more update${updates.length > 2 ? 's' : ''} since your last visit</em></p>` : ''}
        </div>
        <div class="actions">
          <button onclick="closeUpdateModal()" class="update-got-it-btn">Got it!</button>
        </div>
      </div>
    </div>
  `;
  
  // Add modal to page
  document.body.insertAdjacentHTML('beforeend', modalHtml);
  
  // Update the last seen timestamp to the latest update's timestamp
  lastSeenUpdateTimestamp = latestUpdate.timestamp;
  
  // Save the updated timestamp
  saveGameState();
}

function closeUpdateModal() {
  const backdrop = document.getElementById('updateModalBackdrop');
  if (backdrop) {
    backdrop.remove();
  }
}

// Test function for debugging the update system
async function testUpdateSystem() {
  const updates = await fetchUpdates();
  
  const newUpdates = checkForNewUpdates(updates);
  
  if (newUpdates.length > 0) {
    showUpdateModal(newUpdates);
  }
}

// Function to reset update timestamp for testing
function resetUpdateTimestamp() {
  lastSeenUpdateTimestamp = 0;
  saveGameState();
}

// Function to completely clear all game data (cookies AND localStorage)
function clearAllGameData() {
  // Reset the game to a fresh state before clearing data
  // This ensures we don't accidentally save any in-progress game state
  try {
    resetGame(true);
  } catch (error) {
    // Silent error handling
  }
  
  // Clear cookies - use multiple methods to ensure they're cleared
  try {
    // Clear main save cookie and its chunks
    const cookies = document.cookie.split(';');
    cookies.forEach(cookie => {
      const cookieName = cookie.split('=')[0].trim();
      if (cookieName.startsWith('stackMerge_')) {
        // Try multiple cookie clearing methods
        document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/`;
        document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=${window.location.hostname}`;
        document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=.${window.location.hostname}`;
        document.cookie = `${cookieName}=; max-age=0; path=/`;
        document.cookie = `${cookieName}=; max-age=0; path=/; domain=${window.location.hostname}`;
        document.cookie = `${cookieName}=; max-age=0; path=/; domain=.${window.location.hostname}`;
      }
    });
  } catch (e) {
    // Silent error handling
  }
  
  // Clear localStorage
  try {
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('stackMerge_')) {
        keysToRemove.push(key);
      }
    }
    
    keysToRemove.forEach(key => {
      localStorage.removeItem(key);
    });
    
    // Also specifically clear theme unlock data to ensure it's reset
    localStorage.removeItem('stackMerge_themeUnlocks');
  } catch (e) {
    // Silent error handling
  }
  
  // Reset the useLocalStorage flag
  useLocalStorage = false;
  
  // Reset the update timestamp variable
  lastSeenUpdateTimestamp = 0;
  
  // Set flag to prevent timestamp restoration
  preventTimestampRestore = true;
  
  // Reset the high score
  window.highScore = 0;
  
  // Reset the total games counter
  window.totalGames = 0;
  
  // Reset lifetime gold earned
  lifetimeGoldEarned = 0;
  
  // Reset total blocks dropped count
  totalBlocksDropped = 0;
  
  // Reset total bombs exploded count
  totalBombsExploded = 0;
  
  // Reset total blocks trashed count
  totalBlocksTrashed = 0;
  
  // Reset other important game state variables
  hasShownPersonalBest = false;
  bombConversionCost = 25; // Reset to default cost
  trashButtonCost = 25; // Reset to default cost
  bombConversionPresses = 0;
  trashButtonPresses = 0;
  bombSelected = false;
  previousBombCost = 25;
  currentActiveDecayFactor = PROBABILITY_DECAY_FACTOR; // Reset to default decay factor
  
  // Reset sound settings to defaults
  if (soundManager) {
    try {
      soundManager.resetAudioSettings();
    } catch (e) {
      // Silent error handling
    }
  }
  
  // Set flag to prevent theme unlock loading after clear
  window.preventThemeUnlockLoad = true;
  
  // Set a persistent flag in localStorage to ensure unlock status is reset on next load
  try {
    localStorage.setItem('stackMerge_forceResetUnlocks', 'true');
  } catch (e) {
    // Silent error handling
  }
  
  // Reset theme unlock status to defaults
  if (themeManager) {
    themeManager.themeUnlockRequirements = {
      'jellyfish': { unlocked: true, requirement: 'Default theme' },
      'alternate': { unlocked: false, requirement: 'Score 5000+ points' }
    };
    // Don't save unlock status during clear - let the force reset flag handle it
    // themeManager.saveUnlockStatus();
    themeManager.applyTheme('jellyfish'); // Reset to default theme
  }
  
  // Force clear any remaining unlock data from localStorage
  try {
    localStorage.removeItem('stackMerge_themeUnlocks');
    localStorage.removeItem('stackMerge_theme');
  } catch (e) {
    // Silent error handling
  }
  
  // Completely reset the ThemeManager to ensure fresh state
  if (themeManager) {
    // Force reset the unlock requirements
    themeManager.themeUnlockRequirements = {
      'jellyfish': { unlocked: true, requirement: 'Default theme' },
      'alternate': { unlocked: false, requirement: 'Score 5000+ points' }
    };
    
    // Don't save unlock status during clear - let the force reset flag handle it
    // themeManager.saveUnlockStatus();
    
    // Force apply default theme
    themeManager.currentTheme = 'jellyfish';
    themeManager.applyTheme('jellyfish');
  }
  
  // Remove settings button glow effect
  const settingsBtn = document.getElementById('settingsBtn');
  if (settingsBtn) {
    settingsBtn.classList.remove('settings-glow');
  }
  
  // Reset game state variables to defaults
  score = 0;
  gold = 0;
  goldEarnedThisGame = 0;
  blocksDropped = 0;
  placing = false;
  lastPlacementTime = 0;
  currentTargetBlockSize = STARTING_BLOCK_SIZE;
  currentStackCapacity = MAX_HEIGHT;
  currentStage = 1;
  lastGoldAmount = 0;
  
  // Reset weights and probabilities to defaults
  weights = [1, 2];
  probabilities = [0.5, 0.5];
  
  // Reset next queue
  nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
  
  // Reset poles to empty
  poles = [[],[],[],[]];
  
  // Reset debug-related variables to defaults
  currentSpeed = 2; // Reset to Medium speed
  customBlockMode = false;
  customBlockSize = null;
  customBlockBomb = false;
  
  // Reset debug UI elements to defaults
  if (bombToggle) bombToggle.checked = false;
  
  // Update debug pane to reflect cleared state
  if (typeof updateDebugPane === 'function') {
    updateDebugPane();
  }
  
  // Update theme selectors to reflect reset unlock status
  if (typeof updateThemeSelectors === 'function') {
    // Add a small delay to ensure DOM elements are ready
    setTimeout(() => {
      updateThemeSelectors();
      
      // Force another update after a longer delay to ensure everything is properly set
      setTimeout(() => {
        updateThemeSelectors();
      }, 500);
    }, 100);
  }
  

  
      // Also clear any saved game state that might restore the timestamp
    try {
      // Force clear any existing game state
      const gameState = {
        lastSeenUpdateTimestamp: 0,
        timestamp: Date.now()
      };
      
      // Save this "cleared" state to overwrite any existing data
      localStorage.setItem(SAVE_KEY, JSON.stringify(gameState));
    } catch (e) {
      // Silent error handling
    }
    
    // Force clear the main game save data to ensure unlock status is not restored
    try {
      localStorage.removeItem(SAVE_KEY);
    } catch (e) {
      // Silent error handling
    }
}

// Function to check current storage state
function checkStorageState() {
  // Check cookies
  const cookies = document.cookie.split(';');
  const stackMergeCookies = cookies.filter(cookie => 
    cookie.trim().split('=')[0].startsWith('stackMerge_')
  );
  
  // Check localStorage
  const localStorageKeys = [];
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('stackMerge_')) {
        localStorageKeys.push(key);
      }
    }
  } catch (e) {
    // Silent error handling
  }
}

// Help button storage functions
function setHelpButtonClicked() {
  try {
    localStorage.setItem(HELP_BUTTON_KEY, 'true');
  } catch (error) {
    // Silent error handling
  }
}

function hasHelpButtonBeenClicked() {
  try {
    return localStorage.getItem(HELP_BUTTON_KEY) === 'true';
  } catch (error) {
    return false;
  }
}

// Clear saved game data
function clearGameSave() {
  try {
    // Clear localStorage save data
    localStorage.removeItem(SAVE_KEY);
  } catch (error) {
    // Silent error handling
  }
}

// Auto-save game state periodically and on important events
function setupAutoSave() {
  // Test cookie functionality first
  
  // Try to set a simple test cookie
  document.cookie = 'test_cookie=hello';
  
  // Check if test cookie was set
  const testCookie = document.cookie.includes('test_cookie');
  
  if (!testCookie) {
    // Check if it's a local file issue
    if (window.location.protocol === 'file:') {
      // Local file protocol detected - cookies are blocked by browser security
    }
    
    // Automatically switch to localStorage
    useLocalStorage = true;
    
    // Test localStorage functionality
    try {
      localStorage.setItem('test_storage', 'hello');
      const testValue = localStorage.getItem('test_storage');
      if (testValue === 'hello') {
        localStorage.removeItem('test_storage');
      }
    } catch (e) {
      // Silent error handling
    }
  } else {
    // Basic cookie functionality working
    
    // Clean up test cookie
    document.cookie = 'test_cookie=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
  }
  
  // Auto-save every 30 seconds during gameplay
  setInterval(() => {
    if (score > 0 || gold > 0) { // Only save if there's actual progress
      saveGameState();
    }
  }, 30000);
  
  // Save on page unload/visibility change
  window.addEventListener('beforeunload', () => {
    saveGameState();
  });
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      saveGameState();
    }
  });
}

// Number formatting utility function
function formatNumber(num) {
  if (num < 1000) {
    return num.toString();
  } else if (num < 1000000) {
    return (num / 1000).toFixed(1) + 'k';
  } else if (num < 1000000000) {
    return (num / 1000000).toFixed(1) + 'm';
  } else if (num < 1000000000000) {
    return (num / 1000000000).toFixed(1) + 'b';
  } else if (num < 1000000000000000) {
    return (num / 1000000000000).toFixed(1) + 't';
  } else if (num < 1000000000000000000) {
    return (num / 1000000000000000).toFixed(1) + 'q';
  } else {
    return (num / 1000000000000000000).toFixed(1) + 'Q';
  }
}

// Multiplier formatting utility function
function formatMultiplier(num) {
  if (num < 100000) {
    return num.toString() + ' x';
  } else {
    // Use scientific notation for 100,000 and above without + sign
    const exp = Math.floor(Math.log10(num));
    const mantissa = (num / Math.pow(10, exp)).toFixed(1);
    return mantissa + 'e' + exp + ' x';
  }
}

// Centralized display update functions
function updateScoreDisplay() {
  const scoreDisplay = document.querySelector('.score-value');
  if (scoreDisplay) {
    scoreDisplay.innerHTML = `<div class="score-star">⭐</div><div class="score-text">${score}</div>`;
  }
  // Update debug score display with exact value
  if (debugScore) {
    debugScore.textContent = score;
  }
  
  // Check for new personal best during gameplay
  const previousHighScore = window.highScore || 0;
  
  if (score > previousHighScore && score > 0) {
    // Always update high score when current score exceeds it
    window.highScore = score;
    
    // Update statistics modal if it's open
    if (statsModal && !statsModal.classList.contains('hidden')) {
      updateStatsModal();
    }
    
    // Only show personal best message once per game AND if this isn't the user's first game
    if (!hasShownPersonalBest && window.totalGames > 0) {
      hasShownPersonalBest = true;
      
      // Show the personal best animation
      showPersonalBest();
      
      // Show the personal best animation
      showPersonalBest();
    } else if (!hasShownPersonalBest && window.totalGames === 0) {
      // First game ever - don't show personal best message
      hasShownPersonalBest = true; // Still mark as shown to prevent showing later in this game
    } else {
      // High score updated during gameplay
    }
  }
  
  // Auto-save when score changes
  if (score > 0) {
    saveGameState();
  }
}

function updateGoldDisplay() {
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
    const oldMultiplier = goldDisplay.querySelector('.stage-multiplier-badge')?.textContent;
    const newMultiplier = formatMultiplier(stageMultiplier);
    
    // Only show badge for stage 2 and higher
    const badgeHTML = currentStage >= 2 ? `<div class="stage-multiplier-badge" id="stageMultiplierBadge">${newMultiplier}</div>` : '';
    
    goldDisplay.innerHTML = `
      <div class="gold-emoji">💰</div>
      <div class="gold-text">${formatNumber(gold)}</div>
      ${badgeHTML}
    `;
    
    // Add pulse animation for stage progression if multiplier changed and badge exists
    if (oldMultiplier && oldMultiplier !== newMultiplier && currentStage >= 2) {
      const badge = goldDisplay.querySelector('.stage-multiplier-badge');
      if (badge) {
        badge.classList.add('pulse');
        setTimeout(() => {
          badge.classList.remove('pulse');
        }, 600);
      }
    }
  }
  
  // Update debug gold display with exact value
  if (debugGold) {
    debugGold.textContent = gold;
  }
  
  // Auto-save when gold changes
  if (gold > 0) {
    saveGameState();
  }
}
const MAX_HEIGHT = 10;
const BOMB_CHANCE = 0.01; // 1% chance for bombs
const BOMB_DELAY_BLOCKS = 50; // No bombs for first 50 blocks
const STARTING_BLOCK_SIZE = 512; // Starting block size to merge for new stacks
const PROBABILITY_DECAY_FACTOR = 0.7; // Each block is 70% as likely as the previous one
// 
// PROBABILITY SYSTEM EXPLANATION:
// 
// The game uses a hybrid probability system:
// 
// FOUNDATION BLOCKS (equal probability):
// - Block 1: 100% base probability
// - Block 2: 100% base probability  
// - Block 4: 100% base probability

// DECAY BLOCKS (exponential decay):
// - Block 8: 60% base probability (0.6^1)
// - Block 16: 36% base probability (0.6^2)
// - Block 32: 21.6% base probability (0.6^3)
// - Block 64: 12.96% base probability (0.6^4)
// - And so on...
//
// These base probabilities are then normalized to sum to 100%.
// This creates a stable early game foundation while maintaining
// exponential rarity for higher-tier blocks.

// Initialize the current active decay factor
let currentActiveDecayFactor = PROBABILITY_DECAY_FACTOR;

function getRandomWeight(){
  // Validate probabilities before selecting
  if (!validateProbabilityDistribution()) {
    const randomIndex = Math.floor(Math.random() * weights.length);
    return weights[randomIndex];
  }
  
  let r = Math.random();
  let cum = 0;
  
  for(let i=0;i<probabilities.length;i++){
    cum += probabilities[i];
    if (r < cum) {
      return weights[i];
    }
  }
  
  // Fallback - this should rarely happen if probabilities are correct
  return weights[probabilities.length-1];
}

function getRandomPiece(){
  // Prevent bombs from spawning for the first 50 blocks
  const canSpawnBomb = blocksDropped >= BOMB_DELAY_BLOCKS;
  const bombChance = canSpawnBomb ? BOMB_CHANCE : 0;
  
  return { w: getRandomWeight(), bomb: Math.random() < bombChance };
}

let poles = [[],[],[],[]];
let score = 0;
let gold = 0; // Track accumulated gold
let goldEarnedThisGame = 0; // Track gold earned in current game
let lifetimeGoldEarned = 0; // Track total gold earned across all games
let totalBlocksDropped = 0; // Track total blocks dropped across all games
let totalBombsExploded = 0; // Track total bombs exploded across all games
let totalBlocksTrashed = 0; // Track total blocks trashed across all games

// Initialize high score tracking
window.highScore = window.highScore || 0;
// Initialize total games counter
window.totalGames = window.totalGames || 0;
let hasShownPersonalBest = false; // Track if we've shown personal best this game
let blocksDropped = 0; // Track total blocks dropped for bomb delay
let placing = false; // block multiple rapid placements while animating
let lastPlacementTime = 0; // track when placement started for timeout safety
let currentTargetBlockSize = STARTING_BLOCK_SIZE; // Current block size needed to unlock new stack
let currentStackCapacity = MAX_HEIGHT; // Current maximum height for each stack (no longer reduced per stage)
let currentStage = 1; // Current stage (1 = starting, 2 = after first stack unlock, etc.)

// Bomb conversion button state
let bombConversionCost = 25;
let bombConversionPresses = 0; // Number of times button has been pressed
let lastGoldAmount = 0; // Track last gold amount to prevent unnecessary updates
let bombSelected = false; // Track if a bomb is currently selected but not yet placed
let previousBombCost = 25; // Store the previous bomb cost before conversion

// Trash button state
let trashButtonCost = 25;
let trashButtonPresses = 0; // Number of times button has been pressed

// Initialize next queue (probabilities will be set up after functions are defined)
let nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];

// Emergency reset keyboard shortcut (Ctrl+R) - will be set up after gameDiv is defined



function checkForNewStack() {
  // Stage progression without adding new stacks
  // IMPORTANT: This function should NEVER modify the poles array
  // Poles should remain at exactly 4 permanently
  
  // Safety check: ensure we still have exactly 4 poles
  if (poles.length !== 4) {
    poles = [[],[],[],[]];
  }
  
  // Increment stage counter for gold multiplier
  currentStage++;
  // Double the target block size for the next unlock
  currentTargetBlockSize *= 2;
  // Don't call updateBlockRange() here - let the merge system handle block unlocking
  const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
  
  // Save game state after stage progression
  saveGameState();
}

function checkForNewBlockSize(mergedSize) {
  // Check if this merge unlocks a new block size for future drops
  // The merged size should be available as a droppable piece
  if (!weights.includes(mergedSize)) {
    weights.push(mergedSize);
    
    // Check if this was a stage-triggering block
    if (mergedSize === currentTargetBlockSize * 2) {
      // This was a stage progression block
    } else {
      // This was a regular merge unlock
    }
    
    // Implement a better probability distribution system
    // Lower tier blocks should remain more common, higher tiers progressively rarer
    updateProbabilityDistribution();
    
    // Save game state after unlocking new block size
    saveGameState();
  }
}

function updateProbabilityDistribution() {
  try {
    // Call the custom version with the current active decay factor
    updateProbabilityDistributionCustom(currentActiveDecayFactor);
  } catch (error) {
    throw error; // Re-throw to be caught by the caller
  }
}

function updateProbabilityDistributionCustom(decayFactor) {
  try {
    // Create a hybrid probability system with foundation blocks and exponential decay
    // Foundation blocks (1, 2, 4) get equal probabilities for stable early game
    // Higher blocks (8+) follow an exponential decay curve for progression
    
    const numBlocks = weights.length;
    
    if (numBlocks === 0) {
      return;
    }
    
    // Sort weights to ensure they're in ascending order for proper curve calculation
    const sortedWeights = [...weights].sort((a, b) => a - b);
    const sortedIndices = sortedWeights.map(w => weights.indexOf(w));
    
    // Calculate base probabilities using exponential decay
    const baseProbabilities = [];
    
    for (let i = 0; i < numBlocks; i++) {
      const blockSize = sortedWeights[i];
      
      if (i < 3) {
        // First three blocks (1, 2, 4) get equal, high probabilities
        // This creates a stable foundation for the early game
        baseProbabilities.push(1.0);
      } else {
        // Starting from block 8 (index 3), apply exponential decay
        // Each subsequent block is progressively rarer
        const decayPosition = i - 2; // Start decay from position 1 (after the foundation blocks)
        const baseProbability = Math.pow(decayFactor, decayPosition);
        baseProbabilities.push(baseProbability);
      }
    }
    
    // Normalize probabilities to sum to 1.0
    const totalProbability = baseProbabilities.reduce((sum, p) => sum + p, 0);
    
    if (totalProbability === 0) {
      probabilities = new Array(numBlocks).fill(1.0 / numBlocks);
    } else {
      // Map the normalized probabilities back to the original weights order
      const normalizedProbs = baseProbabilities.map(p => p / totalProbability);
      probabilities = new Array(numBlocks);
      
      // Place probabilities back in original order
      sortedIndices.forEach((originalIndex, sortedIndex) => {
        probabilities[originalIndex] = normalizedProbs[sortedIndex];
      });
    }
    
    // Verify probabilities sum to 1.0 (with small floating point tolerance)
    const actualSum = probabilities.reduce((sum, p) => sum + p, 0);
    if (Math.abs(actualSum - 1.0) > 0.0001) {
      // Force normalization
      const correctedSum = probabilities.reduce((sum, p) => sum + p, 0);
      probabilities = probabilities.map(p => p / correctedSum);
    }
    
    // Final validation
    validateProbabilityDistribution();
    
    // Log the current state for debugging
    logProbabilityState();
    
    // Update the debug display
    updateDebugProbabilitiesDisplay();
  } catch (error) {
    console.error('❌ Error in updateProbabilityDistributionCustom:', error);
    console.error('Error stack:', error.stack);
    throw error; // Re-throw to be caught by the caller
  }
}

function validateProbabilityDistribution() {
  // Validate that probabilities are mathematically correct
  if (!probabilities || probabilities.length === 0) {
    console.error('Probabilities array is empty or undefined');
    return false;
  }
  
  if (probabilities.length !== weights.length) {
    console.error(`Mismatch: ${probabilities.length} probabilities vs ${weights.length} weights`);
    return false;
  }
  
  // Check for negative probabilities
  const negativeProbs = probabilities.filter(p => p < 0);
  if (negativeProbs.length > 0) {
    console.error('Found negative probabilities:', negativeProbs);
    return false;
  }
  
  // Check that probabilities sum to 1.0 (with tolerance for floating point errors)
  const sum = probabilities.reduce((s, p) => s + p, 0);
  if (Math.abs(sum - 1.0) > 0.0001) {
    return false;
  }
  
  // Check that all probabilities are finite numbers
  const invalidProbs = probabilities.filter(p => !isFinite(p));
  if (invalidProbs.length > 0) {
    return false;
  }
  
  return true;
}

// updateBlockRange function removed - block unlocking now handled entirely by checkForNewBlockSize





function showGoldEarned(amount) {
  // Create the gold earned display element
  const goldEl = document.createElement('div');
  goldEl.className = 'gold-earned';
  
  // Debug: Check if formatNumber is available and working
  
  goldEl.textContent = `+${formatNumber(amount)}`;
  
  // Position it at a specific point with text centered on that point
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    const rect = goldDisplay.getBoundingClientRect();
    
    // First, add the element to the DOM temporarily to measure its width
    document.body.appendChild(goldEl);
    const textWidth = goldEl.offsetWidth;
    
    // Calculate the desired position (2px right of gold display right edge)
    let desiredLeft = rect.right + 2;
    
    // Check if the text would be cut off by the right edge of the screen
    const screenRight = window.innerWidth;
    // Since text starts at left edge, the right edge is at desiredLeft + textWidth
    const textRightEdge = desiredLeft + textWidth;
    
    // If text would be cut off, adjust position to the left
    if (textRightEdge > screenRight - 10) { // Leave 10px margin from screen edge
      desiredLeft = screenRight - 10 - textWidth;
    }
    
    // Ensure we don't go too far left (keep it within reasonable bounds)
    const minLeft = Math.max(0, rect.left - 20); // Don't go more than 20px left of the gold display, and never go off-screen left
    if (desiredLeft < minLeft) {
      desiredLeft = minLeft;
    }
    

    
    // Position the element so its left edge starts at desiredLeft
    goldEl.style.left = desiredLeft + 'px';
    goldEl.style.top = (rect.top + 5) + 'px';
  } else {
    // Fallback positioning if gold display not found
    goldEl.style.left = '50%';
    goldEl.style.top = '50%';
    goldEl.style.transform = 'translate(-50%, -50%)';
  }
  
  // Add pulse animation to the gold count
  if (goldDisplay) {
    goldDisplay.classList.add('pulse');
    setTimeout(() => {
      goldDisplay.classList.remove('pulse');
    }, 300);
  }
  
  // Remove after animation completes
  setTimeout(() => {
    if (goldEl.parentNode) {
      goldEl.parentNode.removeChild(goldEl);
    }
  }, 1200);
}

function showPersonalBest() {
  // Create the personal best display element
  const personalBestEl = document.createElement('div');
  personalBestEl.className = 'personal-best';
  personalBestEl.textContent = 'New Record!';
  
  // Position it centered above the score display
  const scoreDisplay = document.querySelector('.score-value');
  if (scoreDisplay) {
    const rect = scoreDisplay.getBoundingClientRect();
    personalBestEl.style.left = (rect.left + rect.width / 2) + 'px';
    personalBestEl.style.top = (rect.top - 40) + 'px'; // Position 40px above the score display
    personalBestEl.style.textAlign = 'center';
  } else {
    // Fallback positioning if score display not found
    personalBestEl.style.left = '50%';
    personalBestEl.style.top = '30%';
  }
  
  document.body.appendChild(personalBestEl);
  
  // Play the personal best sound effect
  if (soundManager && soundManager.canPlayAudio()) {
    soundManager.playSound('personalBest', 'other').catch(error => {
      // Silent error handling
    });
  }
  
  // Add pulse animation to the score display
  if (scoreDisplay) {
    scoreDisplay.classList.add('pulse');
    setTimeout(() => {
      scoreDisplay.classList.remove('pulse');
    }, 300);
  }
  
  // Remove after animation completes (increased from 1.5s to 3s)
  setTimeout(() => {
    if (personalBestEl.parentNode) {
      personalBestEl.parentNode.removeChild(personalBestEl);
    }
  }, 3000);
}

function handleBombConversion() {
  // Check if there's a next block to work with
  if (nextQueue.length === 0) {
    return;
  }
  
  const currentBlock = nextQueue[0];
  
  // If a bomb is already selected, allow undoing the selection
  if (bombSelected && currentBlock.bomb) {
    // Undo bomb selection
    currentBlock.bomb = false;
    // Note: No gold to refund since payment hasn't been made yet
    bombConversionCost = previousBombCost; // Restore previous cost
    bombSelected = false;
    
    // No need to update gold display since no gold was deducted
    
    // Re-render to show the regular block
    renderNext();
    
    // Update button cost display
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (bombCostElMobile) {
      bombCostElMobile.textContent = formatNumber(bombConversionCost);
    }
    
    // Update button state and appearance
    updateBombConversionButtonState();
    
    // Save game state after undoing bomb selection
    saveGameState();
    return;
  }
  
  // Check if the next block is already a bomb (either natural or from previous conversion)
  if (currentBlock.bomb) {
    // Show feedback that the block is already a bomb
    bombConversionBtn.classList.add('pulse');
    setTimeout(() => bombConversionBtn.classList.remove('pulse'), 300);
    if (bombConversionBtnMobile) {
      bombConversionBtnMobile.classList.add('pulse');
      setTimeout(() => bombConversionBtnMobile.classList.remove('pulse'), 300);
    }
    return;
  }
  
  // Check if player has enough gold for new bomb conversion
  if (gold < bombConversionCost) {
    // Show feedback that they don't have enough gold
    bombConversionBtn.classList.add('pulse');
    setTimeout(() => bombConversionBtn.classList.remove('pulse'), 300);
    if (bombConversionBtnMobile) {
      bombConversionBtnMobile.classList.add('pulse');
      setTimeout(() => bombConversionBtnMobile.classList.remove('pulse'), 300);
    }
    return;
  }
  
  // Store the current cost before converting
  previousBombCost = bombConversionCost;
  
  // Convert the current next block to a bomb (don't deduct gold yet)
  // Gold will be deducted when the bomb block is actually placed
  if (currentBlock) {
    currentBlock.bomb = true;
    bombSelected = true; // Mark that a bomb is selected
    // Update gold display
    updateGoldDisplay();
    const goldDisplay = document.querySelector('.gold-value');
    if (goldDisplay) {
      goldDisplay.classList.add('pulse');
      setTimeout(() => {
        goldDisplay.classList.remove('pulse');
      }, 300);
    }
    
    // Re-render to show the bomb
    renderNext();
    
    // Also re-render the main game to ensure pole placement logic is updated
    // This ensures that if bomb status affects any placement decisions, they're properly reflected
    render();
    
    // Note: Cost will increase when the bomb block is actually placed, not when selected
    // Update button state
    updateBombConversionButtonState();
    
    // Save game state after bomb conversion and cost increase
    saveGameState();
  }
}

function handleTrashButton() {
  // Check if player has enough gold
  if (gold < trashButtonCost) {
    // Show feedback that they don't have enough gold
    trashButton.classList.add('pulse');
    setTimeout(() => trashButton.classList.remove('pulse'), 300);
    if (trashButtonMobile) {
      trashButtonMobile.classList.add('pulse');
      setTimeout(() => trashButtonMobile.classList.remove('pulse'), 300);
    }
    return;
  }
  
  // Check if there's a next block to remove
  if (nextQueue.length === 0) {
    return;
  }
  
  // Deduct gold
  gold -= trashButtonCost;
  
  // Play purchase sound for the trash button usage
  soundManager.playPurchaseSound();
  
  // Remove the current next block from the queue
  const removedBlock = nextQueue.shift();
  
  // Track total blocks trashed
  totalBlocksTrashed++;
  
  // Add a new random block to the end of the queue to maintain 3 blocks
  nextQueue.push(getRandomPiece());
  
  // Update gold display
  updateGoldDisplay();
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    goldDisplay.classList.add('pulse');
    setTimeout(() => {
      goldDisplay.classList.remove('pulse');
    }, 300);
  }
  
  // Play the same animation as placing a block, but don't place it
  animateNextQueueAdvance(true).then(() => {
    // After the queue animation completes, re-render to update pole placement logic
    // This ensures that the new next block can be properly evaluated for placement
    render();
  }); // true = queue already modified
  
  // Increment press count and double the cost
  trashButtonCost *= 2;
  
  // Update button cost display
  const trashCostEl = document.getElementById('trashCost');
  if (trashCostEl) {
    trashCostEl.textContent = formatNumber(trashButtonCost);
  }
  if (trashCostElMobile) {
    trashCostElMobile.textContent = formatNumber(trashButtonCost);
  }
  
  // Update button state (cost changed, so force update)
  updateTrashButtonState();
  
  // Save game state after using trash button and cost increase
  saveGameState();
}

function updateBombConversionButtonState() {
  // Always update when called since we call this strategically
  
  if (bombConversionBtn) {
    // If a bomb is selected, the button should always be enabled for undo
    if (bombSelected) {
      bombConversionBtn.disabled = false;
      bombConversionBtn.classList.remove('affordable');
      bombConversionBtn.classList.add('undo-mode');
      bombConversionBtn.title = "Press again to undo bomb selection";
      const emojiEl = bombConversionBtn.querySelector('.powerup-emoji');
      if (emojiEl) emojiEl.textContent = "↩️";
    } else {
      // Check if the next block is already a bomb (either natural or from previous conversion)
      const nextBlockIsBomb = nextQueue.length > 0 && nextQueue[0].bomb;
      
      if (nextBlockIsBomb) {
        // Next block is already a bomb, disable the button
        bombConversionBtn.disabled = true;
        bombConversionBtn.classList.remove('affordable');
        bombConversionBtn.classList.remove('undo-mode');
        bombConversionBtn.title = "Next block is already a bomb";
        const emojiEl = bombConversionBtn.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "💣";
      } else {
        // Next block is not a bomb, check if player has enough gold
        const hasEnoughGold = gold >= bombConversionCost;
        bombConversionBtn.disabled = !hasEnoughGold;
        
        // Update visual styling based on affordability
        // Red border (default): when gold < cost (disabled)
        // White border (affordable): when gold >= cost (enabled)
        if (hasEnoughGold) {
          bombConversionBtn.classList.add('affordable');
        } else {
          bombConversionBtn.classList.remove('affordable');
        }
        bombConversionBtn.classList.remove('undo-mode');
        bombConversionBtn.title = "Convert next block to bomb (press again to undo)";
        const emojiEl = bombConversionBtn.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "💣";
      }
    }
    
    // Update the tracked gold amount
    lastGoldAmount = gold;
  }
  
  // Also update mobile button if it exists
  if (bombConversionBtnMobile) {
    // If a bomb is selected, the button should always be enabled for undo
    if (bombSelected) {
      bombConversionBtnMobile.disabled = false;
      bombConversionBtnMobile.classList.remove('affordable');
      bombConversionBtnMobile.classList.add('undo-mode');
      bombConversionBtnMobile.title = "Press again to undo bomb selection";
      const emojiEl = bombConversionBtnMobile.querySelector('.powerup-emoji');
      if (emojiEl) emojiEl.textContent = "↩️";
    } else {
      // Check if the next block is already a bomb (either natural or from previous conversion)
      const nextBlockIsBomb = nextQueue.length > 0 && nextQueue[0].bomb;
      
      if (nextBlockIsBomb) {
        // Next block is already a bomb, disable the button
        bombConversionBtnMobile.disabled = true;
        bombConversionBtnMobile.classList.remove('affordable');
        bombConversionBtnMobile.classList.remove('undo-mode');
        bombConversionBtnMobile.title = "Next block is already a bomb";
        const emojiEl = bombConversionBtnMobile.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "💣";
      } else {
        // Next block is not a bomb, check if player has enough gold
        const hasEnoughGold = gold >= bombConversionCost;
        bombConversionBtnMobile.disabled = !hasEnoughGold;
        
        if (hasEnoughGold) {
          bombConversionBtnMobile.classList.add('affordable');
        } else {
          bombConversionBtnMobile.classList.remove('affordable');
        }
        bombConversionBtnMobile.classList.remove('undo-mode');
        bombConversionBtnMobile.title = "Convert next block to bomb (press again to undo)";
        const emojiEl = bombConversionBtnMobile.querySelector('.powerup-emoji');
        if (emojiEl) emojiEl.textContent = "💣";
      }
    }
  }
}

function updateTrashButtonState() {
  // Always update when called since we call this strategically
  
  if (trashButton) {
    const hasEnoughGold = gold >= trashButtonCost;
    trashButton.disabled = !hasEnoughGold;
    
    // Update visual styling based on affordability
    // Red border (default): when gold < cost (disabled)
    // White border (affordable): when gold >= cost (enabled)
    if (hasEnoughGold) {
      trashButton.classList.add('affordable');
    } else {
      trashButton.classList.remove('affordable');
    }
    
    // Update the tracked gold amount
    lastGoldAmount = gold;
  }
  
  // Also update mobile button if it exists
  if (trashButtonMobile) {
    const hasEnoughGold = gold >= trashButtonCost;
    trashButtonMobile.disabled = !hasEnoughGold;
    
    if (hasEnoughGold) {
      trashButtonMobile.classList.add('affordable');
    } else {
      trashButtonMobile.classList.remove('affordable');
    }
  }
}

// More targeted update function for when we know gold has changed
// Use this instead of updateBombConversionButtonState() when gold changes during gameplay
function updateBombButtonIfGoldChanged() {
  updateBombConversionButtonState();
}

// More targeted update function for trash button when we know gold has changed
function updateTrashButtonIfGoldChanged() {
  updateTrashButtonState();
}

// AI state
let aiEnabled = false;
let aiInterval = null;
const AI_DELAY_MS = 500;

// Speed control state
let currentSpeed = 2; // 0-4, default 2 (Medium): 0=Very Slow, 1=Slow, 2=Medium, 3=Fast, 4=Blazing

// Debug pane state
let debugPane = null;
let debugClose = null;
let bombToggle = null;
let bombStatus = null;
let debugScore = null;
let debugGold = null;
let debugStacks = null;
let debugCapacity = null;
let debugTarget = null;
let debugMaxBlock = null;
  let debugBlocksDropped = null;
  let debugTotalBlocksDropped = null;
  let debugTotalBombsExploded = null;
  let debugTotalBlocksTrashed = null;
  let debugBombStatus = null;
  let debugStage = null;
let debugAiToggle = null;
let debugSpeedSlider = null;
let debugSpeedLabel = null;
let customBlockMode = false;
let customBlockSize = null;
let customBlockBomb = false;

// DOM refs
const gameDiv = document.getElementById('game');
const nextContainer = document.getElementById('nextContainer');
const scoreEl = document.getElementById('scoreDisplay');
const goldEl = document.getElementById('goldDisplay');

const helpBtn = document.getElementById('helpBtn');
const helpModal = document.getElementById('helpModal');
const helpClose = document.getElementById('helpClose');

// Bomb conversion button DOM refs
const bombConversionBtn = document.getElementById('bombConversionBtn');
const bombCostEl = document.getElementById('bombCost');

// Trash button DOM refs
const trashButton = document.getElementById('trashButton');
const trashCostEl = document.getElementById('trashCost');

// Mobile button DOM refs
const bombConversionBtnMobile = document.getElementById('bombConversionBtnMobile');
const bombCostElMobile = document.getElementById('bombCostMobile');
const trashButtonMobile = document.getElementById('trashButtonMobile');
const trashCostElMobile = document.getElementById('trashCostMobile');

// Button element status for debugging

// Debug pane DOM refs
debugPane = document.getElementById('debugPane');
debugClose = document.getElementById('debugClose');
bombToggle = document.getElementById('bombToggle');
bombStatus = document.getElementById('bombStatus');
debugScore = document.getElementById('debugScore');
debugGold = document.getElementById('debugGold');
debugStacks = document.getElementById('debugStacks');
debugCapacity = document.getElementById('debugCapacity');
debugTarget = document.getElementById('debugTarget');
debugMaxBlock = document.getElementById('debugMaxBlock');
              debugBlocksDropped = document.getElementById('debugBlocksDropped');
        debugTotalBlocksDropped = document.getElementById('debugTotalBlocksDropped');
        debugTotalBombsExploded = document.getElementById('debugTotalBombsExploded');
        debugTotalBlocksTrashed = document.getElementById('debugTotalBlocksTrashed');
        debugBombStatus = document.getElementById('debugBombStatus');
        debugStage = document.getElementById('debugStage');
const grantGoldBtn = document.getElementById('grantGoldBtn');
const grantScoreBtn = document.getElementById('grantScoreBtn');

// Debug auto-play DOM refs
debugAiToggle = document.getElementById('debugAiToggle');
debugSpeedSlider = document.getElementById('debugSpeedSlider');
debugSpeedLabel = document.getElementById('debugSpeedLabel');
// Emergency reset keyboard shortcut (Ctrl+R)
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 'r') {
    e.preventDefault();
    placing = false; // Force reset placing state
    
    // Re-enable hover effects and pointer events on all poles
    if (gameDiv && gameDiv.children) {
      const allPoles = Array.from(gameDiv.children);
      allPoles.forEach(poleDiv => {
        poleDiv.style.pointerEvents = '';
        poleDiv.classList.remove('no-hover');
      });
    }
    
    resetGame(true);
  }
});





// Function to update help guide examples with current theme colors
function updateHelpGuideColors() {
  // Update merge examples
  const mergeExamples = document.querySelectorAll('.merge-example .merge-block');
  mergeExamples.forEach(block => {
    const dataValue = block.getAttribute('data-value');
    if (dataValue) {
      const numValue = parseInt(dataValue);
      if (!isNaN(numValue)) {
        block.style.background = colorFor(numValue);
        block.style.color = getTextColorFor(numValue);
      }
    }
  });
  
  // Update stage progression examples
  const stageBlocks = document.querySelectorAll('.next-stage-block');
  stageBlocks.forEach(block => {
    const text = block.textContent;
    const numValue = parseInt(text);
    if (!isNaN(numValue)) {
      block.style.background = colorFor(numValue);
      block.style.color = getTextColorFor(numValue);
    }
  });
}

// Help modal wiring
function openHelp(){ 
  helpModal.classList.remove('hidden'); 
  
  // Update help guide colors with current theme
  setTimeout(() => {
    updateHelpGuideColors();
  }, 100); // Small delay to ensure modal is fully rendered
  
  // Dynamically position the help modal content below the close button on mobile
  const helpModalContent = document.querySelector('.help-modal');
  const closeButton = document.getElementById('helpClose');
  
  if (helpModalContent && closeButton && window.innerWidth <= 768) {
    // Use a small delay to ensure the modal is fully rendered before calculating position
    setTimeout(() => {
      positionHelpModalMobile();
    }, 50);
  } else if (helpModalContent) {
    // Position for desktop with delay to ensure rendering
    setTimeout(() => {
      positionHelpModalDesktop();
    }, 50);
  }
  
  // Save that the help button has been clicked and remove the glow
  setHelpButtonClicked();
  helpBtn.classList.remove('help-glow');
}

// Function to calculate safe viewport dimensions for mobile
function calculateSafeViewport() {
  // Get the actual viewport dimensions
  const visualViewport = window.visualViewport || window;
  
  // Get safe area insets (iOS specific)
  const safeAreaTop = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sat') || '0');
  const safeAreaBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sab') || '0');
  
  // Calculate the actual safe viewport
  const safeTop = Math.max(safeAreaTop, 0);
  const safeBottom = Math.max(safeAreaBottom, 0);
  
  // Use visualViewport.height for more accurate mobile viewport
  const viewportHeight = visualViewport.height || window.innerHeight;
  const safeHeight = viewportHeight - safeTop - safeBottom;
  
  return {
    top: safeTop,
    bottom: safeBottom,
    height: safeHeight,
    viewportHeight: viewportHeight,
    width: visualViewport.width || window.innerWidth
  };
}

// Function to position help modal on mobile with proper safe viewport handling
function positionHelpModalMobile() {
  const helpModalContent = document.querySelector('.help-modal');
  const closeButton = document.getElementById('helpClose');
  
  if (!helpModalContent || !closeButton) return;
  
  const safeViewport = calculateSafeViewport();
  
  // Position close button at the top of safe area with some padding
  const closeButtonTop = safeViewport.top + 20;
  closeButton.style.top = `${closeButtonTop}px`;
  
  // Calculate close button dimensions
  const closeButtonRect = closeButton.getBoundingClientRect();
  const closeButtonHeight = closeButtonRect.height;
  
  // Position help modal below close button with spacing
  const modalTop = closeButtonTop + closeButtonHeight + 20;
  helpModalContent.style.top = `${modalTop}px`;
  
  // Calculate maximum height for the modal to fit within safe viewport
  const availableHeight = safeViewport.height - (modalTop - safeViewport.top) - 40;
  helpModalContent.style.maxHeight = `${availableHeight}px`;
  
  // Reset padding to normal
  helpModalContent.style.paddingTop = '20px';
  
  // Mobile help modal positioned
}

// Function to position help modal on desktop
function positionHelpModalDesktop() {
  const helpModalContent = document.querySelector('.help-modal');
  const closeButton = document.getElementById('helpClose');
  
  if (!helpModalContent || !closeButton) return;
  
  // On desktop, we need to position the modal content below the close button
  // The close button is positioned with fixed positioning, so we calculate its position
  const closeButtonRect = closeButton.getBoundingClientRect();
  const closeButtonBottom = closeButtonRect.bottom;
  
  // Position the modal content below the close button with spacing
  const modalTop = closeButtonBottom + 20;
  helpModalContent.style.top = `${modalTop}px`;
  
  // Calculate maximum height to ensure content fits within viewport
  const availableHeight = window.innerHeight - modalTop - 80; // 80px bottom margin for desktop spacing
  helpModalContent.style.maxHeight = `${availableHeight}px`;
  
  // Reset other positioning properties
  helpModalContent.style.paddingTop = '20px';
  
  // Desktop help modal positioned below close button
}

// Function to reposition help modal content when needed
function repositionHelpModal() {
  const helpModalContent = document.querySelector('.help-modal');
  if (helpModalContent && !helpModalContent.classList.contains('hidden')) {
    if (window.innerWidth <= 768) {
      positionHelpModalMobile();
    } else {
      positionHelpModalDesktop();
    }
  }
}

// Add event listeners for viewport changes and device rotation
window.addEventListener('resize', repositionHelpModal);

// Listen for visual viewport changes (important for mobile browsers)
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', repositionHelpModal);
}

// Listen for orientation changes
window.addEventListener('orientationchange', () => {
  setTimeout(repositionHelpModal, 100); // Delay to allow orientation change to complete
});
function closeHelp(){ helpModal.classList.add('hidden'); }
if (helpBtn) {
  helpBtn.addEventListener('click', () => {

    openHelp();
  });
}

if (helpClose) {
  helpClose.addEventListener('click', closeHelp);
}

// Reset Local Data button event listener
const resetDataBtn = document.getElementById('resetDataBtn');
if (resetDataBtn) {
  resetDataBtn.addEventListener('click', () => {
    if (confirm('Are you sure you want to clear all data? This will delete all player statistics and settings.')) {
      clearAllGameData();
      closeHelp(); // Close the help modal
      
      // Show update modal after a brief delay
      setTimeout(() => {
        testUpdateSystem();
      }, 500);
    }
  });
}

if (helpModal) {
  helpModal.addEventListener('click', (e) => { if (e.target === helpModal) closeHelp(); });
}

// Statistics modal DOM refs and functionality
const showStatsBtn = document.getElementById('showStatsBtn');
const statsModal = document.getElementById('statsModal');

// Function to update statistics modal
function updateStatsModal() {
  const statsHighScore = document.getElementById('statsHighScore');
  const statsLifetimeGold = document.getElementById('statsLifetimeGold');
  const statsTotalBlocksDropped = document.getElementById('statsTotalBlocksDropped');
  const statsTotalBombsExploded = document.getElementById('statsTotalBombsExploded');
  const statsTotalBlocksTrashed = document.getElementById('statsTotalBlocksTrashed');
  
  if (statsHighScore) {
    statsHighScore.textContent = window.highScore || 0;
  }
  
  if (statsLifetimeGold) {
    statsLifetimeGold.textContent = formatNumber(lifetimeGoldEarned || 0);
  }
  
  if (statsTotalBlocksDropped) {
    statsTotalBlocksDropped.textContent = formatNumber(totalBlocksDropped || 0);
  }
  
  if (statsTotalBombsExploded) {
    statsTotalBombsExploded.textContent = formatNumber(totalBombsExploded || 0);
  }
  
  if (statsTotalBlocksTrashed) {
    statsTotalBlocksTrashed.textContent = formatNumber(totalBlocksTrashed || 0);
  }
}

// Function to open statistics modal
function openStats() {
  statsModal.classList.remove('hidden');
  updateStatsModal();
}

// Function to close statistics modal
function closeStats() {
  statsModal.classList.add('hidden');
}

// Statistics modal event listeners
if (showStatsBtn) {
  showStatsBtn.addEventListener('click', openStats);
}

if (statsModal) {
  statsModal.addEventListener('click', (e) => { if (e.target === statsModal) closeStats(); });
}

// Sound button event listener
if (soundBtn) {
        soundBtn.addEventListener('click', () => {

        openSoundControlModal();
      });
} else {
  console.log('⚠️ Sound button not found');
}

// Settings button event listener
const settingsBtn = document.getElementById('settingsBtn');
if (settingsBtn) {
  settingsBtn.addEventListener('click', () => {
    // Remove the glow effect when settings is opened
    settingsBtn.classList.remove('settings-glow');
    openSettingsModal();
  });
}



// Set initial sound button state
if (soundBtn) {
  const isMuted = soundManager.getMuteState();
  soundBtn.textContent = isMuted ? '🔇' : '🔊';
  soundBtn.title = 'Sound Controls';
}
window.addEventListener('keydown', (e) => { 
  if (e.key === 'Escape' && helpModal && !helpModal.classList.contains('hidden')) {
    closeHelp();
  }
});

// Bomb conversion button event listener
if (bombConversionBtn) {
  bombConversionBtn.addEventListener('click', () => {

    handleBombConversion();
  });
} else {
  console.error('❌ Bomb conversion button not found!');
}

// Trash button event listener
if (trashButton) {
  trashButton.addEventListener('click', () => {

    handleTrashButton();
  });
} else {
  console.error('❌ Trash button not found!');
}

// Mobile button event listeners
if (bombConversionBtnMobile) {
  bombConversionBtnMobile.addEventListener('click', () => {

    handleBombConversion();
  });
} else {
  console.error('❌ Mobile bomb conversion button not found!');
}

if (trashButtonMobile) {
  trashButtonMobile.addEventListener('click', () => {

    handleTrashButton();
  });
} else {
  console.error('❌ Mobile trash button not found!');
}

// Game over popup - any click anywhere closes it
const gameOverButton = document.getElementById('gameOverButton');
if (gameOverButton) {
  // Add click listener to the document to close game over popup on any click
  document.addEventListener('click', () => {
    if (gameOverButton.classList.contains('show')) {
      gameOverButton.classList.remove('show');
    }
  });
}

// Global user interaction detection for universal audio compatibility
document.addEventListener('click', () => {
  if (soundManager && !soundManager.audioUnlocked) {
    soundManager.unlockAudio();
  }
});

// Touch event detection for mobile devices
document.addEventListener('touchstart', () => {
  if (soundManager && !soundManager.audioUnlocked) {
    soundManager.unlockAudio();
  }
}, { passive: true });

// Add button event listener for new game
const addBtn = document.getElementById('addBtn');
if (addBtn) {
  addBtn.addEventListener('click', () => {

    openNewGameModal();
  });
}

// New game modal button event listeners
const confirmNewGameBtn = document.getElementById('confirmNewGameBtn');
if (confirmNewGameBtn) {
  confirmNewGameBtn.addEventListener('click', () => {

    handleNewGameConfirmation();
  });
}

const cancelNewGameBtn = document.getElementById('cancelNewGameBtn');
if (cancelNewGameBtn) {
  cancelNewGameBtn.addEventListener('click', handleNewGameCancel);
}

// Close new game modal when clicking outside
const newGameModal = document.getElementById('newGameModal');
if (newGameModal) {
  newGameModal.addEventListener('click', (e) => {
    if (e.target === newGameModal) {
      closeNewGameModal();
    }
  });
}

// Close new game modal with Escape key
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && newGameModal && !newGameModal.classList.contains('hidden')) {
    closeNewGameModal();
  }
});

// Settings Modal Functions
function openSettingsModal() {
  const modal = document.getElementById('settingsModal');
  if (modal) {
    modal.classList.remove('hidden');
    
    // Force update theme selectors when settings modal is opened
    if (typeof updateThemeSelectors === 'function') {
      setTimeout(() => {
        updateThemeSelectors();
      }, 50);
    }
  }
}

function closeSettingsModal() {
  const modal = document.getElementById('settingsModal');
  if (modal) {
    modal.classList.add('hidden');
  }
  
  // Remove the glow effect when settings is closed
  const settingsBtn = document.getElementById('settingsBtn');
  if (settingsBtn) {
    settingsBtn.classList.remove('settings-glow');
  }
}

function initializeSettingsModal() {
  // Settings close button
  const closeBtn = document.getElementById('settingsClose');
  if (closeBtn) {
    closeBtn.addEventListener('click', closeSettingsModal);
  }
  
  // Close modal when clicking outside
  const modal = document.getElementById('settingsModal');
  if (modal) {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeSettingsModal();
      }
    });
  }
  
  // Close modal with Escape key
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal && !modal.classList.contains('hidden')) {
      closeSettingsModal();
    }
  });
  
  // Theme selector
  const themeSelector = document.getElementById('themeSelector');
  if (themeSelector) {
    // Set initial value
    themeSelector.value = themeManager.getCurrentTheme();
    
    // Add change event listener
    themeSelector.addEventListener('change', (e) => {
      const selectedTheme = e.target.value;
      
      // Check if theme is unlocked
      if (!themeManager.isThemeUnlocked(selectedTheme)) {
        // Show locked theme message
        showLockedThemeMessage(selectedTheme, themeManager.getThemeRequirement(selectedTheme));
        // Reset selector to current theme
        e.target.value = themeManager.getCurrentTheme();
        return;
      }
      
      const success = themeManager.applyTheme(selectedTheme);
      if (success) {
        // Update help guide colors if help modal is open
        if (helpModal && !helpModal.classList.contains('hidden')) {
          updateHelpGuideColors();
        }
      }
    });
  }
  


}



// Sound Control Modal Functions
function openSoundControlModal() {
  const modal = document.getElementById('soundControlModal');
  if (modal) {
    // Update UI with current sound settings
    updateSoundControlUI();
    
    modal.classList.remove('hidden');
  }
}

function closeSoundControlModal() {
  const modal = document.getElementById('soundControlModal');
  if (modal) {
    modal.classList.add('hidden');
  }
}

function updateSoundControlUI() {
  // Update master mute button
  const masterMuteBtn = document.getElementById('masterMuteBtn');
  if (masterMuteBtn) {
    const isMuted = soundManager.getMuteState();
    masterMuteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
    masterMuteBtn.classList.toggle('muted', isMuted);
  }
  
  // Update volume sliders and values using the dedicated function
  updateVolumeSliders();
}

function initializeSoundControlModal() {
  // Master mute button
  const masterMuteBtn = document.getElementById('masterMuteBtn');
  if (masterMuteBtn) {
    // Initialize master mute button state
    const isMuted = soundManager.isMuted;
    masterMuteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
    masterMuteBtn.classList.toggle('muted', isMuted);
    
    masterMuteBtn.addEventListener('click', () => {

      const isMuted = soundManager.toggleMute();
      masterMuteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
      masterMuteBtn.classList.toggle('muted', isMuted);
      
      // Update sound button in title bar
      const soundBtn = document.getElementById('soundBtn');
      if (soundBtn) {
        soundBtn.textContent = isMuted ? '🔇' : '🔊';
        soundBtn.title = 'Sound Controls';
      }
      
      // Save game state to cookies to persist the mute change
      saveGameState();
    });
  }
  
  // Volume sliders
  const soundTypes = ['drop', 'merge', 'coin', 'bomb', 'other'];
  soundTypes.forEach(soundType => {
    const slider = document.getElementById(`${soundType}VolumeSlider`);
    const value = document.getElementById(`${soundType}VolumeValue`);
    
    if (slider && value) {
      // Initialize slider and value display with current volume from sound manager
      const currentVolume = soundManager.getSoundVolume(soundType);
      slider.value = currentVolume;
      value.textContent = currentVolume;
      
      slider.addEventListener('input', (e) => {

        const newVolume = parseInt(e.target.value);
        soundManager.setSoundVolume(soundType, newVolume);
        value.textContent = newVolume;
        
        // Save game state to cookies to persist the volume change
        saveGameState();
      });
      
      // Play test sound only when slider is released (change event)
      slider.addEventListener('change', (e) => {
        const finalVolume = parseInt(e.target.value);
        

        
        // Test the volume change only when slider is released
        testVolumeChange(soundType, finalVolume);
      });
    }
  });
  
  // Close button
  const closeBtn = document.getElementById('soundControlClose');
  if (closeBtn) {
    closeBtn.addEventListener('click', closeSoundControlModal);
  }
  

  

  
  // Close modal when clicking outside
  const modal = document.getElementById('soundControlModal');
  if (modal) {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeSoundControlModal();
      }
    });
  }
  
  // Close modal with Escape key
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal && !modal.classList.contains('hidden')) {
      closeSoundControlModal();
    }
  });
}

// Function to update volume sliders with current values
function updateVolumeSliders() {
  const soundTypes = ['drop', 'merge', 'coin', 'bomb', 'other'];
  soundTypes.forEach(soundType => {
    const slider = document.getElementById(`${soundType}VolumeSlider`);
    const value = document.getElementById(`${soundType}VolumeValue`);
    
    if (slider && value) {
      const currentVolume = soundManager.getSoundVolume(soundType);
      slider.value = currentVolume;
      value.textContent = currentVolume;
    } else {
      console.warn(`⚠️ Missing elements for ${soundType}: slider=${!!slider}, value=${!!value}`);
    }
  });
}

// Initialize button states

try {
  updateBombConversionButtonState();
} catch (error) {
  console.error('❌ Error initializing bomb conversion button state:', error);
}

try {
  updateTrashButtonState();
} catch (error) {
  console.error('❌ Error initializing trash button state:', error);
}

// Initialize cost displays
if (bombCostEl) {
  bombCostEl.textContent = formatNumber(bombConversionCost);
}
if (trashCostEl) {
  trashCostEl.textContent = formatNumber(trashButtonCost);
}
if (bombCostElMobile) {
  bombCostElMobile.textContent = formatNumber(bombConversionCost);
}
if (trashCostElMobile) {
  trashCostElMobile.textContent = formatNumber(trashButtonCost);
}

// Debug button wiring
if (debugBtn) {
  debugBtn.addEventListener('click', openDebugPane);
}

// Initialize debug button visibility based on environment
document.addEventListener('DOMContentLoaded', () => {
  const debugBtn = document.getElementById('debugBtn');
  
  if (debugBtn) {
    if (isDevelopment()) {
      debugBtn.style.display = 'block';
    } else {
      debugBtn.style.display = 'none';
    }
  }
  
  // Initialize sound control modal after DOM is loaded
  initializeSoundControlModal();
  
  // Initialize settings modal after DOM is loaded
  initializeSettingsModal();
  
  // Force scroll to top immediately when DOM is ready
  
  // Try to clear any stored scroll position
  try {
    if (window.history && window.history.scrollRestoration) {
      window.history.scrollRestoration = 'manual';
    }
  } catch (e) {
    // Could not disable scroll restoration
  }
  
  window.scrollTo(0, 0);
  if (window.visualViewport) {
    window.visualViewport.scrollTop = 0;
  }
});

// Test function to verify volume changes are working
function testVolumeChange(soundType, volume) {
  // Get the actual volume value that would be used
  const actualVolume = soundManager.getActualVolume(soundType);
  
  // Test playing a sound if the volume is not 0
  if (actualVolume > 0) {
    // Play a test sound based on the sound type
    switch (soundType) {
      case 'drop':
        soundManager.playDropSound(1);
        break;
      case 'merge':
        soundManager.playMergeSound(2);
        break;
      case 'coin':
        soundManager.playCoinSound();
        break;
      case 'bomb':
        soundManager.playBombSound();
        break;
      case 'other':
        soundManager.playStageProgressionSound();
        soundManager.playGameOverSound();
        break;
    }
  }
}



function toggleAI(enable){
  if(enable === aiEnabled) return;
  aiEnabled = enable;
  
  // Update debug pane display if it exists
  if (debugAiToggle) {
    updateDebugAutoPlayDisplay();
  }
  

  
  if(aiEnabled){
    // start AI interval
    if(aiInterval) clearInterval(aiInterval);
    // make an immediate move then interval
    aiStep();
    // Set up the initial interval based on current speed
    const delays = [2000, 1500, 1000, 500, 50];
    const initialDelay = delays[currentSpeed];
    aiInterval = setInterval(aiStep, initialDelay);
  } else {
    if(aiInterval) clearInterval(aiInterval);
    aiInterval = null;
    
    // Reset animation speed to default when auto-play is turned off
    currentSpeed = 2; // Medium
    if (debugSpeedSlider) {
      debugSpeedSlider.value = currentSpeed;
    }
    updateSpeedLabel();
    updateDebugSpeedLabel();
    updateAnimationSpeed();
  }
}

function updateSpeedLabel() {
  if (debugSpeedLabel) {
    const speedLabels = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Blazing'];
    debugSpeedLabel.textContent = speedLabels[currentSpeed];
  }
}

function updateAISpeed() {
  if (!aiEnabled) return;
  
  // Clear existing interval if it exists
  if (aiInterval) {
    clearInterval(aiInterval);
  }
  
  // Calculate new delay based on speed (0-4)
  // Speed 0 = Very Slow (2000ms), Speed 4 = Blazing (50ms)
  const delays = [2000, 1500, 1000, 500, 50];
  const newDelay = delays[currentSpeed];
  
  // Restart interval with new speed
  aiInterval = setInterval(aiStep, newDelay);
}

function updateAnimationSpeed() {
  // Calculate animation multiplier based on speed (0-4)
  // Speed 0 = Very Slow (3x slower), Speed 4 = Blazing (0x - instant, no animations)
  const multipliers = [3, 2, 1, 0.5, 0];
  
  // When speed is 4 (Blazing), set multiplier to 0 to disable animations
  const multiplier = multipliers[currentSpeed];
  
  // Update CSS custom properties for animation durations
  document.documentElement.style.setProperty('--animation-speed', multiplier);
  
  // Apply animation speed to all animated elements for instant animation support
  const animatedElements = document.querySelectorAll('.disc, .next-disc, .pole');
  animatedElements.forEach(el => {
    el.style.setProperty('--animation-speed', multiplier);
  });
}

function updateStackHeight() {
  // Stack height is now fixed at MAX_HEIGHT (10) - no more dynamic reduction
  // Base height varies by screen size for mobile responsiveness
  // Each slot needs: disc height + margin-top
  // 10 slots need: (disc height + margin) × 10 + pole padding
  let baseHeight = 542; // Desktop: 42px disc + 9px margin = 51px per slot, 10 slots = 510px + 32px padding = 542px
  
  // Check if we're on mobile and adjust height accordingly
  if (window.innerWidth <= 480) {
    // Extra small mobile: 26px disc + 4px margin = 30px per slot
    // 10 slots: 30px × 10 = 300px + 16px padding (8px top + 8px bottom) = 316px
    baseHeight = 316;
  } else if (window.innerWidth <= 768) {
    // Regular mobile: 30px disc + 6px margin = 36px per slot  
    // 10 slots: 36px × 10 = 360px + 24px padding (12px top + 12px bottom) = 384px
    baseHeight = 384;
  }
  
  // Update CSS custom property for stack height
  document.documentElement.style.setProperty('--stack-height', baseHeight + 'px');
}

function updateDebugPane() {
  if (debugScore) debugScore.textContent = score;
  if (debugGold) debugGold.textContent = gold;
  if (debugStacks) debugStacks.textContent = poles.length;
  if (debugCapacity) debugCapacity.textContent = currentStackCapacity;
  if (debugTarget) debugTarget.textContent = currentTargetBlockSize * 2;
  if (debugMaxBlock) debugMaxBlock.textContent = Math.max(...weights);
                if (debugBlocksDropped) debugBlocksDropped.textContent = blocksDropped;
        if (debugTotalBlocksDropped) debugTotalBlocksDropped.textContent = totalBlocksDropped;
        if (debugTotalBombsExploded) debugTotalBombsExploded.textContent = totalBombsExploded;
        if (debugTotalBlocksTrashed) debugTotalBlocksTrashed.textContent = totalBlocksTrashed;
  if (debugBombStatus) debugBombStatus.textContent = blocksDropped >= BOMB_DELAY_BLOCKS ? 'Enabled' : 'Disabled';
  if (debugStage) debugStage.textContent = currentStage;
  
  // Update probabilities display
  updateDebugProbabilitiesDisplay();
}



// Debug pane wiring
function openDebugPane(){ 
  debugPane.classList.add('show'); 
  syncDebugControls();
}
function closeDebugPane(){ 
  debugPane.classList.remove('show'); 
  // Keep custom block mode active when debug pane is closed
  // customBlockMode will only be reset when "No Block" is selected
  
  // Debug pane closed, custom block mode remains active
}
debugClose.addEventListener('click', closeDebugPane);
debugPane.addEventListener('click', (e) => { if (e.target === debugPane) closeDebugPane(); });
window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && debugPane.classList.contains('show')) closeDebugPane(); });

// New Game Modal Functions
function openNewGameModal() {
  const newGameModal = document.getElementById('newGameModal');
  if (newGameModal) {
    newGameModal.classList.remove('hidden');
  }
}

function closeNewGameModal() {
  const newGameModal = document.getElementById('newGameModal');
  if (newGameModal) {
    newGameModal.classList.add('hidden');
  }
}

function handleNewGameConfirmation() {
  closeNewGameModal();
  // Play new game sound effect when starting a new game
  soundManager.playNewGameSound();
  resetGame(true);
}

function handleNewGameCancel() {
  closeNewGameModal();
}

function syncDebugControls() {
  // Sync auto-play state
  updateDebugAutoPlayDisplay();
  
  // Sync speed control
  if (debugSpeedSlider) {
    debugSpeedSlider.value = currentSpeed;
  }
  updateDebugSpeedLabel();
  
  // Sync sound controls
  if (debugVolumeSlider) {
    debugVolumeSlider.value = Math.round(soundManager.getVolume() * 100);
  }
  updateDebugVolumeLabel();
  
  if (debugMuteToggle) {
    debugMuteToggle.checked = soundManager.getMuteState();
  }
  updateDebugMuteStatus();
  
  // Sync probability curve controls
  if (debugDecaySlider) {
    // Always show the current active decay factor
    debugDecaySlider.value = currentActiveDecayFactor;
    updateDebugDecayLabel(currentActiveDecayFactor);
  } else {
    updateDebugDecayLabel(currentActiveDecayFactor);
  }
  
  // Update probabilities display
  updateDebugProbabilitiesDisplay();
  
  // Set up event listeners for debug controls (only if they exist)
  if (debugVolumeSlider) {
    // Remove existing listeners to avoid duplicates
    debugVolumeSlider.removeEventListener('input', handleVolumeChange);
    debugVolumeSlider.addEventListener('input', handleVolumeChange);
  }
  
  if (debugMuteToggle) {
    // Remove existing listeners to avoid duplicates
    debugMuteToggle.removeEventListener('change', handleMuteToggle);
    debugMuteToggle.addEventListener('change', handleMuteToggle);
  }
  
  if (debugDecaySlider) {
    // Remove existing listeners to avoid duplicates
    debugDecaySlider.removeEventListener('input', handleDecayChange);
    debugDecaySlider.addEventListener('input', handleDecayChange);
  }
  
  if (debugUpdateProbBtn) {
    // Remove existing listeners to avoid duplicates
    debugUpdateProbBtn.removeEventListener('click', handleUpdateProbabilities);
    debugUpdateProbBtn.addEventListener('click', handleUpdateProbabilities);
  }
  
  // Set up auto-play control event listeners
  if (debugAiToggle) {
    // Remove existing listeners to avoid duplicates
    debugAiToggle.removeEventListener('click', handleAiToggle);
    debugAiToggle.addEventListener('click', handleAiToggle);
  }
  
  if (debugSpeedSlider) {
    // Remove existing listeners to avoid duplicates
    debugSpeedSlider.removeEventListener('input', handleSpeedSlider);
    debugSpeedSlider.addEventListener('input', handleSpeedSlider);
  }
  
  // Set up test personal best button event listener
  const testPersonalBestBtn = document.getElementById('testPersonalBestBtn');
  if (testPersonalBestBtn) {
    // Remove existing listeners to avoid duplicates
    testPersonalBestBtn.removeEventListener('click', handleTestPersonalBest);
    testPersonalBestBtn.addEventListener('click', handleTestPersonalBest);
  }
  
  // Set up test game over button event listener
  const testGameOverBtn = document.getElementById('testGameOverBtn');
  if (testGameOverBtn) {
    // Remove existing listeners to avoid duplicates
    testGameOverBtn.removeEventListener('click', handleTestGameOver);
    testGameOverBtn.addEventListener('click', handleTestGameOver);
  }
  
  // Set up test unlock theme button event listener
  const testUnlockThemeBtn = document.getElementById('testUnlockThemeBtn');
  if (testUnlockThemeBtn) {
    // Remove existing listeners to avoid duplicates
    testUnlockThemeBtn.removeEventListener('click', handleTestUnlockTheme);
    testUnlockThemeBtn.addEventListener('click', handleTestUnlockTheme);
  }
  
  // Set up test lock theme button event listener
  const testLockThemeBtn = document.getElementById('testLockThemeBtn');
  if (testLockThemeBtn) {
    // Remove existing listeners to avoid duplicates
    testLockThemeBtn.removeEventListener('click', handleTestLockTheme);
    testLockThemeBtn.addEventListener('click', handleTestLockTheme);
  }
  
  // Set up debug button event listeners
  if (grantGoldBtn) {
    // Remove existing listeners to avoid duplicates
    grantGoldBtn.removeEventListener('click', handleGrantGold);
    grantGoldBtn.addEventListener('click', handleGrantGold);
  }
  
  if (grantScoreBtn) {
    // Remove existing listeners to avoid duplicates
    grantScoreBtn.removeEventListener('click', handleGrantScore);
    grantScoreBtn.addEventListener('click', handleGrantScore);
  }
  
  const checkCoinStatusBtn = document.getElementById('checkCoinStatusBtn');
  if (checkCoinStatusBtn) {
    // Remove existing listeners to avoid duplicates
    checkCoinStatusBtn.removeEventListener('click', handleCheckCoinStatus);
    checkCoinStatusBtn.addEventListener('click', handleCheckCoinStatus);
  }
  
  // Set up block grid interface event listeners
  document.querySelectorAll('.block-item').forEach(blockItem => {
    // Remove existing listeners to avoid duplicates
    blockItem.removeEventListener('click', () => handleBlockItemClick(blockItem));
    blockItem.addEventListener('click', () => handleBlockItemClick(blockItem));
  });
  
  // Set up bomb toggle event listener
  if (bombToggle) {
    // Remove existing listeners to avoid duplicates
    bombToggle.removeEventListener('change', handleBombToggle);
    bombToggle.addEventListener('change', handleBombToggle);
  }
  
  // Set up debug theme selector event listener
  const debugThemeSelector = document.getElementById('debugThemeSelector');
  if (debugThemeSelector) {
    // Remove existing listeners to avoid duplicates
    debugThemeSelector.removeEventListener('change', handleDebugThemeChange);
    debugThemeSelector.addEventListener('change', handleDebugThemeChange);
    
    // Set initial value
    debugThemeSelector.value = themeManager.getCurrentTheme();
  }
}

// Debug pane controls will be set up in syncDebugControls()

// Debug button event listeners will be set up in syncDebugControls()

// Debug auto-play controls - will be set up in syncDebugControls()

// Event listener handler functions for debug controls
function handleVolumeChange(e) {
  const volume = parseInt(e.target.value) / 100;
  soundManager.setVolume(volume);
  updateDebugVolumeLabel();
}

function handleDebugThemeChange(e) {
  const selectedTheme = e.target.value;
  
  // Check if theme is unlocked
  if (!themeManager.isThemeUnlocked(selectedTheme)) {
    // Show locked theme message
    showLockedThemeMessage(selectedTheme, themeManager.getThemeRequirement(selectedTheme));
    // Reset selector to current theme
    e.target.value = themeManager.getCurrentTheme();
    return;
  }
  
  const success = themeManager.applyTheme(selectedTheme);
  if (success) {
    console.log('🎨 Debug theme changed to:', selectedTheme);
    
    // Update help guide colors if help modal is open
    if (helpModal && !helpModal.classList.contains('hidden')) {
      updateHelpGuideColors();
    }
  }
}

function handleMuteToggle(e) {
  const isMuted = soundManager.toggleMute();
  updateDebugMuteStatus();
  // Update the main sound button to match
  const soundBtn = document.getElementById('soundBtn');
  if (soundBtn) {
    soundBtn.textContent = isMuted ? '🔇' : '🔊';
    soundBtn.title = isMuted ? 'Unmute sound' : 'Mute sound';
  }
}

function handleDecayChange(e) {
  const decayFactor = parseFloat(e.target.value);
  updateDebugDecayLabel(decayFactor);
}

function handleUpdateProbabilities() {
  const decayFactor = parseFloat(debugDecaySlider.value);
  updateProbabilityDistributionWithDecay(decayFactor);
}

function handleAiToggle() {
  toggleAI(!aiEnabled);
  updateDebugAutoPlayDisplay();
}

function handleSpeedSlider(e) {
  currentSpeed = parseInt(e.target.value);
  updateSpeedLabel();
  updateDebugSpeedLabel();
  updateAISpeed();
  updateAnimationSpeed();
}

function handleGrantGold() {
  gold += 1000;
  goldEarnedThisGame += 1000; // Track gold earned in current game
  lifetimeGoldEarned += 1000; // Track lifetime gold earned
  // Update gold display
  updateGoldDisplay();
  
  // Update statistics modal if it's open
  if (statsModal && !statsModal.classList.contains('hidden')) {
    updateStatsModal();
  }
  // Update bomb conversion button state
  updateBombButtonIfGoldChanged();
  // Update trash button state
  updateTrashButtonIfGoldChanged();
  
  // Play coin sound effect for earning gold
  soundManager.playCoinSound();
  
  // Save game state after granting gold
  console.log('🔄 Triggering save after granting gold...');
  saveGameState();
  
  console.log(`Granted 1000 gold. New balance: ${gold}, This Game: ${goldEarnedThisGame}, Lifetime: ${lifetimeGoldEarned}`);
}

function handleGrantScore() {
  score += 1000;
  // Update score display
  updateScoreDisplay();
  
  // Save game state after granting score
  console.log('🔄 Triggering save after granting score...');
  saveGameState();
  
  console.log(`Granted 1000 score. New score: ${score}`);
}

function handleCheckCoinStatus() {
  const status = soundManager.getCoinSoundStatus();
  console.log('🪙 Coin Sound Status:', status);
  
  if (status.loaded && status.count === status.expected) {
    console.log('✅ All coin sounds loaded successfully!');
  } else {
    console.warn('⚠️ Coin sound loading issues detected');
  }
}

function handleTestPersonalBest() {
  console.log('🧪 Testing personal best message...');
  showPersonalBest();
  
  // Automatically close the debug pane after showing the test message
  // This provides a better UX by not keeping the debug pane open after testing
  setTimeout(() => {
    closeDebugPane();
    // Debug pane automatically closed after testing personal best message
  }, 150); // Small delay to ensure the message is visible before closing
}

function handleTestGameOver() {
  console.log('🧪 Testing game over screen...');
  
  // Set some sample data to make the game over screen look realistic
  if (weights && weights.length > 0) {
    const highestBlock = Math.max(...weights);
    console.log(`Setting largest block to: ${highestBlock}`);
  }
  
  // Show the game over screen
  showGameOver();
  
  // Automatically close the debug pane after showing the game over screen
  // This provides a better UX by not keeping the debug pane open during testing
  setTimeout(() => {
    closeDebugPane();
    // Debug pane automatically closed after testing game over screen
  }, 150); // Small delay to ensure the game over screen is visible before closing
}

function handleTestUnlockTheme() {
  console.log('🧪 Testing theme unlock...');
  
  // Test unlocking the Earth theme
  if (themeManager.unlockTheme('alternate')) {
    console.log('✅ Earth theme unlocked successfully');
    
    // Play theme unlock sound
    if (soundManager && soundManager.canPlayAudio()) {
      soundManager.playSound('themeUnlock', 'other').catch(error => {
        console.log('Could not play theme unlock sound:', error);
      });
    }
    
    // Add green glow to settings button to indicate new theme available
    const settingsBtn = document.getElementById('settingsBtn');
    if (settingsBtn) {
      settingsBtn.classList.add('settings-glow');
    }
    
    // Update theme selectors to show the new unlock status
    updateThemeSelectors();
  } else {
    console.log('❌ Failed to unlock Earth theme');
  }
}

function handleTestLockTheme() {
  console.log('🧪 Testing theme lock...');
  
  // Test locking the Earth theme
  if (themeManager.themeUnlockRequirements['alternate']) {
    themeManager.themeUnlockRequirements['alternate'].unlocked = false;
    themeManager.saveUnlockStatus();
    console.log('🔒 Earth theme locked successfully');
    
    // Remove settings button glow effect
    const settingsBtn = document.getElementById('settingsBtn');
    if (settingsBtn) {
      settingsBtn.classList.remove('settings-glow');
    }
    
    // Update theme selectors to show the new lock status
    updateThemeSelectors();
    
    // Show a message
    alert('Earth theme has been locked for testing. You can unlock it again with the Test Theme Unlock button or by scoring 5000+ in a real game.');
  } else {
    console.log('❌ Failed to lock Earth theme');
  }
}

function handleBlockItemClick(blockItem) {
  // Remove previous selection
  document.querySelectorAll('.block-item').forEach(item => item.classList.remove('selected'));
  
  // Select this block
  blockItem.classList.add('selected');
  
  // Check if "No Block" is selected
  if (blockItem.dataset.value === 'none') {
    customBlockSize = null;
    customBlockMode = false;
    console.log('No block selected - using queue');
  } else {
    // Update the custom block size
    const value = parseInt(blockItem.dataset.value);
    customBlockSize = value;
    
    // Enable custom block mode
    customBlockMode = true;
    
    console.log(`Selected block: ${value}`);
    
    // Automatically close the debug pane when a custom block is selected
    // This allows immediate dropping of the selected block
    setTimeout(() => {
      closeDebugPane();
      // Debug pane automatically closed after selecting custom block
    }, 150); // Small delay to ensure the selection is visible before closing
  }
  
  // Re-render to update pole enabling/disabling based on the new custom block
  render();
}

function handleBombToggle(e) {
  customBlockBomb = e.target.checked;
  bombStatus.textContent = customBlockBomb ? 'Yes' : 'No';
  
  // Re-render to update pole enabling/disabling if custom block mode is active
  if (customBlockMode && customBlockSize) {
    render();
  }
}

function updateDebugAutoPlayDisplay() {
  debugAiToggle.textContent = aiEnabled ? 'Auto Play: On' : 'Auto Play: Off';
  debugAiToggle.classList.toggle('active', aiEnabled);
}

function updateDebugSpeedLabel() {
  const speedLabels = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Blazing'];
  debugSpeedLabel.textContent = speedLabels[currentSpeed];
}

function updateDebugVolumeLabel() {
  const volume = Math.round(soundManager.getVolume() * 100);
  debugVolumeLabel.textContent = volume + '%';
}

function updateDebugMuteStatus() {
  const isMuted = soundManager.getMuteState();
  debugMuteStatus.textContent = isMuted ? 'Yes' : 'No';
  

}

function updateDebugDecayLabel(decayFactor) {
  debugDecayLabel.textContent = decayFactor.toFixed(2);
}

function updateDebugProbabilitiesDisplay() {
  const probDiv = document.getElementById('debugProbabilities');
  if (!probDiv) return;
  
  if (!probabilities || probabilities.length === 0) {
    probDiv.innerHTML = '<em>No probabilities available</em>';
    return;
  }
  
  let html = '<div style="margin-bottom: 8px;"><strong>Block | Probability | Cumulative</strong></div>';
  
  let cumulative = 0;
  for (let i = 0; i < weights.length; i++) {
    cumulative += probabilities[i];
    const percentage = (probabilities[i] * 100).toFixed(2);
    const cumulativePercentage = (cumulative * 100).toFixed(2);
    
    // Different styling for foundation vs decay blocks
    const isFoundation = i < 3;
    const blockColor = isFoundation ? '#10B981' : '#0ea5e9'; // Green for foundation, blue for decay
    const bgColor = i % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'transparent';
    const borderStyle = isFoundation ? '2px solid #10B981' : 'none';
    
    html += `<div style="margin: 2px 0; padding: 2px 4px; background: ${bgColor}; border-radius: 2px; border: ${borderStyle};">
      <span style="color: ${blockColor}; font-weight: 600;">${weights[i]}</span> | 
      <span style="color: #10B981;">${percentage}%</span> | 
      <span style="color: #F59E0B;">${cumulativePercentage}%</span>
      ${isFoundation ? ' <span style="color: #10B981; font-size: 10px;">(Foundation)</span>' : ''}
    </div>`;
  }
  
  probDiv.innerHTML = html;
}

function updateProbabilityDistributionWithDecay(decayFactor) {
  // Update the current active decay factor
  currentActiveDecayFactor = decayFactor;
  
  console.log(`Updating probability distribution with decay factor: ${decayFactor}`);
  
  // Recalculate probabilities with the new decay factor
  updateProbabilityDistributionCustom(decayFactor);
  
  // Log the change
  console.log(`Probability distribution updated with decay factor: ${decayFactor}`);
  
  // Update the debug display
  updateDebugDecayLabel(decayFactor);
  
  // Update the slider to reflect the current active setting
  if (debugDecaySlider) {
    debugDecaySlider.value = decayFactor;
  }
}

function colorFor(w){
  // Get current theme
  const currentTheme = themeManager ? themeManager.getCurrentTheme() : 'jellyfish';
  
  if (currentTheme === 'alternate') {
    // Vibrant, clearly differentiated colors for each block value
    const alternateColors = [
      '#E4DFBB', // warm cream - value 1
      '#7A6658', // medium brown - value 2
      '#6D8C69', // sage green - value 4
      '#0A472C', // dark green - value 8
      '#054A91', // deep blue - value 16
      '#36A1F3', // medium blue - value 32
      '#EF767A', // coral pink - value 64
      '#D9A06E', // light orange - value 128
      '#C9AA30', // golden yellow - value 256
      '#626C66', // gray-green - value 512
      '#434A42', // dark gray-green - value 1024
      '#3B2631', // dark burgundy - value 2048
      '#32021F', // dark burgundy - value 4096
      '#28112B', // very dark purple - value 8192
      '#000000'  // pitch black - value 16384
    ];
    
    const log2w = Math.log2(w);
    const colorIndex = Math.min(Math.floor(log2w), alternateColors.length - 1);
    return alternateColors[colorIndex];
  } else {
    // Default jellyfish theme colors
    const jellyfishColors = [
      '#cfef08', // lime green - value 1 (subtle)
      '#10B981', // emerald-500 - value 2 (soft green)
      '#2563EB', // blue-600 - value 4 (medium blue)
      '#7C3AED', // violet-600 - value 8 (violet - midpoint between blue and dark purple)
      '#581C87', // violet-800 - value 16 (dark purple)
      '#D946EF', // fuchsia-500 - value 32 (bright fuchsia - clearly different from 16)
      '#EC4899', // pink-500 - value 64 (hot pink)
      '#e86758', // red-500 - value 128 (intense red)
      '#F59E0B', // amber-500 - value 256 (bright amber)
      '#ea580c', // orange-600 - value 512 (vibrant orange)
      '#dc2626', // red-600 - value 1024 (bright red)
      '#9d174d', // rose-700 - value 2048 (darker magenta)
      '#7c2d6d',    // darker purple-magenta - value 4096
      '#64748b', // gray - value 8192
      '#fff'     // white - value 16384
    ];
    
    const log2w = Math.log2(w);
    const colorIndex = Math.min(Math.floor(log2w), jellyfishColors.length - 1);
    return jellyfishColors[colorIndex];
  }
}

function labelForPiece(piece){
  if (piece && piece.bomb) {
    // Format bomb text for large numbers (6+ digits)
    const displayValue = piece.w >= 100000 ? formatNumber(piece.w) : piece.w;
    return `<div class="bomb-content"><div class="bomb-emoji">💣</div><div class="bomb-text">${displayValue}</div></div>`;
  }
  // Format regular block text for large numbers (6+ digits)
  return piece.w >= 100000 ? formatNumber(piece.w) : String(piece.w);
}

function getTextColorFor(w){
  // Get current theme
  const currentTheme = themeManager ? themeManager.getCurrentTheme() : 'jellyfish';
  
  if (currentTheme === 'alternate') {
    // For alternate theme, use white text for all blocks except value 1
    return w === 1 ? '#000000' : '#ffffff';
  } else {
    // Default jellyfish theme: black text for lime green block (value 1) and blocks >= 16384, white for others
    return (w === 1 || w >= 16384) ? '#000000' : '#ffffff';
  }
}

function render(){
  // Prevent infinite render loops
  if (window.isRendering) {
    console.warn('Render already in progress, skipping duplicate call');
    return;
  }
  
  // Set rendering flag to prevent safety checks from interfering
  window.isRendering = true;
  
  // build poles
  gameDiv.innerHTML = '';
  
  // Safety check: ensure we only have exactly 4 poles
  if (poles.length !== 4) {
    console.warn(`Warning: Expected 4 poles but found ${poles.length}. Resetting to 4 poles.`);
    poles = [[],[],[],[]];
  }
  

  
  poles.forEach((pole, idx) => {
    const poleDiv = document.createElement('div');
    const isAtCapacity = pole.length >= currentStackCapacity;
    
    // Determine which piece to check against for pole enabling/disabling
    let pieceToCheck;
    if (customBlockMode && customBlockSize) {
      pieceToCheck = { w: customBlockSize, bomb: customBlockBomb };
    } else {
      pieceToCheck = nextQueue[0];
    }
    
    const playable = canPlaceOnPole(pieceToCheck, pole);
    const isDisabled = isAtCapacity && !playable;
    
    poleDiv.className = 'pole' + (isDisabled ? ' full' : '');
    
    // Preserve the no-hover state if we're currently placing
    if (placing) {
      poleDiv.classList.add('no-hover');
      poleDiv.style.pointerEvents = 'none';
    }
    
    // If stack is disabled (full and can't merge), disable interactions
    if (isDisabled) {
      poleDiv.classList.add('no-hover');
      poleDiv.style.pointerEvents = 'none';
      poleDiv.style.cursor = 'not-allowed';
    }
    
    poleDiv.setAttribute('role', 'button');
    poleDiv.tabIndex = isDisabled ? -1 : 0;
    poleDiv.setAttribute('aria-label', `Stack ${idx + 1}, contains ${pole.length} blocks${isAtCapacity ? (playable ? ', merge available' : ', blocked') : ''}`);
    poleDiv.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (!isDisabled) {
          placeOnPole(idx);
        }
      }
    });
    // existing discs (no animation class)
    pole.forEach(p => {
      const d = document.createElement('div');
      d.className = 'disc';
      if (p.bomb) {
        d.innerHTML = labelForPiece(p);
      } else {
        d.textContent = labelForPiece(p);
      }
      d.style.background = p.bomb ? '#000' : colorFor(p.w);
      d.style.color = p.bomb ? '#fff' : getTextColorFor(p.w);
      
      // Add dynamic gold glow effect for white blocks (16384+)
      if (!p.bomb && p.w >= 16384) {
        d.classList.add('white-block-glow');
        
        // Calculate glow intensity based on block value
        const log2Value = Math.log2(p.w);
        const baseLog2 = Math.log2(16384); // 14
        const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
        
        // Set CSS custom properties for dynamic glow
        d.style.setProperty('--glow-intensity', intensityMultiplier.toString());
        d.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
        d.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
        d.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
        d.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
        d.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
      }
      
      poleDiv.appendChild(d);
    });
    
    // Only add click handler if stack is not disabled
    if (!isDisabled) {
      poleDiv.addEventListener('click', () => {
        // Ensure audio is unlocked on first click
        if (soundManager && !soundManager.audioUnlocked) {
          soundManager.unlockAudio();
        }
        
        // Play drop sound IMMEDIATELY on click for iOS compatibility
        // This happens before any game logic, in direct response to user interaction
        if (soundManager && soundManager.canPlayAudio()) {
          const nextPiece = nextQueue[0];
          if (nextPiece) {
            soundManager.playDropSound(nextPiece.w);
          }
        }
        
        placeOnPole(idx);
      });
      
          // Add touch event handling for better mobile experience
      let touchStartTime = 0;
      let touchStartY = 0;
      
      poleDiv.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        touchStartY = e.touches[0].clientY;
        // Prevent default to avoid double-tap zoom on mobile
        e.preventDefault();
        
        // Prime audio context on first touch to ensure instant playback

      }, { passive: false });
      
      poleDiv.addEventListener('touchend', (e) => {
        const touchEndTime = Date.now();
        const touchEndY = e.changedTouches[0].clientY;
        const touchDuration = touchEndTime - touchStartTime;
        const touchDistance = Math.abs(touchEndY - touchStartY);
        
        // Only trigger placement if it's a quick tap (not a swipe) and close to start position
        if (touchDuration < 300 && touchDistance < 20) {
          // Ensure audio is unlocked on first touch
          if (soundManager && !soundManager.audioUnlocked) {
            soundManager.unlockAudio();
          }
          
          // Play drop sound IMMEDIATELY on touch for iOS compatibility
          if (soundManager && soundManager.canPlayAudio()) {
            const nextPiece = nextQueue[0];
            if (nextPiece) {
              soundManager.playDropSound(nextPiece.w);
            }
          }
          
          placeOnPole(idx);
        }
      });
      
      // Clear hover state when touch moves (prevents stuck highlights)
      poleDiv.addEventListener('touchmove', (e) => {
        // If touch moves significantly, don't trigger placement
        const currentY = e.touches[0].clientY;
        if (Math.abs(currentY - touchStartY) > 20) {
          // Touch moved too much, this won't be a valid tap
        }
      });
      
      // Handle touch cancellation
      poleDiv.addEventListener('touchcancel', () => {
        // Touch was cancelled, do nothing
      });
    }
    
    gameDiv.appendChild(poleDiv);
    
    // Apply current animation speed to the new pole
    poleDiv.style.setProperty('--animation-speed', document.documentElement.style.getPropertyValue('--animation-speed'));
  });
  
  // Final safety check: verify we only have 4 pole elements
  const renderedPoles = gameDiv.querySelectorAll('.pole');
  if (renderedPoles.length !== 4) {
    console.warn(`Warning: Rendered ${renderedPoles.length} pole elements instead of 4! Attempting to fix...`);
    
    // Try to fix by re-rendering once more
    if (window.renderRetryCount === undefined) {
      window.renderRetryCount = 1;
    } else if (window.renderRetryCount < 2) {
      window.renderRetryCount++;
    } else {
      // Too many retries, reset and start fresh
      console.error(`Too many render retries (${window.renderRetryCount}), resetting game state`);
      window.renderRetryCount = 0;
      poles = [[],[],[],[]];
      gameDiv.innerHTML = '';
      window.isRendering = false;
      setTimeout(() => render(), 100);
      return;
    }
    
    gameDiv.innerHTML = '';
    // Clear rendering flag before early return
    window.isRendering = false;
    // Force a single re-render with small delay
    setTimeout(() => render(), 50);
    return;
  }
  
  // Reset retry count on successful render
  window.renderRetryCount = 0;
  

  
  // update score display in game info
  updateScoreDisplay();
  
  // update gold display in game info
  updateGoldDisplay();
  
  // Update bomb conversion button state
  updateBombButtonIfGoldChanged();
  // Update trash button state
  updateTrashButtonIfGoldChanged();
  

  
  updateDebugPane();
  
  // Clear rendering flag
  window.isRendering = false;
  
  renderNext();
}

function renderNext(){
  nextContainer.innerHTML = '';
  nextQueue.forEach((p, idx) => {
    const d = document.createElement('div');
    d.className = 'next-disc' + (idx === 0 ? ' current' : '');
    if (p.bomb) {
      d.innerHTML = labelForPiece(p);
    } else {
      d.textContent = labelForPiece(p);
    }
    d.style.background = p.bomb ? '#000' : colorFor(p.w);
    d.style.color = p.bomb ? '#fff' : getTextColorFor(p.w);
    
    // Add dynamic gold glow effect for white blocks (16384+)
    if (!p.bomb && p.w >= 16384) {
      d.classList.add('white-block-glow');
      
      // Calculate glow intensity based on block value
      const log2Value = Math.log2(p.w);
      const baseLog2 = Math.log2(16384); // 14
      const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
      
      // Set CSS custom properties for dynamic glow
      d.style.setProperty('--glow-intensity', intensityMultiplier.toString());
      d.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
      d.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
      d.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
      d.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
      d.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
    }
    
    nextContainer.appendChild(d);
    
    // Apply current animation speed to the new next disc
    d.style.setProperty('--animation-speed', document.documentElement.style.getPropertyValue('--animation-speed'));
  });
}

function placeOnPole(idx){
  if (placing) { 
    return; // Simply ignore clicks during placement instead of queueing
  }
  const pole = poles[idx];
  
  // Check if custom block mode is active
  let nextPiece;
  let wasCustomBlock = false;
  if (customBlockMode && customBlockSize) {
    nextPiece = { w: customBlockSize, bomb: customBlockBomb };
    wasCustomBlock = true;
    // Custom block mode works when a block is selected, regardless of debug pane visibility
  } else {
    nextPiece = nextQueue[0];
  }
  
  // Safety check: ensure this stack can actually accept the piece
  if (!canPlaceOnPole(nextPiece, pole)) {
    return;
  }
  
  // Note: Drop sound is now played immediately in the click/touch handler for iOS compatibility
  
  placing = true;
  lastPlacementTime = Date.now();

  // Disable hover effects on all poles during placement
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = 'none';
    poleDiv.classList.add('no-hover');
    console.log('Added no-hover class to pole:', poleDiv);
    console.log('Pole classes after adding no-hover:', poleDiv.className);
    console.log('Pole computed pointer-events:', window.getComputedStyle(poleDiv).pointerEvents);
  });

  // append an animated disc to the pole DOM, without modifying the data model yet
  const poleDiv = gameDiv.children[idx];
  const animDisc = document.createElement('div');
  animDisc.className = 'disc animate';
  if (nextPiece.bomb) {
    animDisc.innerHTML = labelForPiece(nextPiece);
  } else {
    animDisc.textContent = labelForPiece(nextPiece);
  }
  animDisc.style.background = nextPiece.bomb ? '#000' : colorFor(nextPiece.w);
  animDisc.style.color = nextPiece.bomb ? '#fff' : getTextColorFor(nextPiece.w);
  
  // Add dynamic gold glow effect for white blocks (16384+)
  if (!nextPiece.bomb && nextPiece.w >= 16384) {
    animDisc.classList.add('white-block-glow');
    
    // Calculate glow intensity based on block value
    const log2Value = Math.log2(nextPiece.w);
    const baseLog2 = Math.log2(16384); // 14
    const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
    
    // Set CSS custom properties for dynamic glow
    animDisc.style.setProperty('--glow-intensity', intensityMultiplier.toString());
    animDisc.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
    animDisc.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
    animDisc.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
    animDisc.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
    animDisc.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
  }
  
  // Apply current animation speed to the animated disc
  animDisc.style.setProperty('--animation-speed', document.documentElement.style.getPropertyValue('--animation-speed'));
  
  // Apply current stack height to the animated disc
  animDisc.style.setProperty('--stack-height', document.documentElement.style.getPropertyValue('--stack-height'));
  
  // Let CSS handle the mobile-specific drop animations
  // The CSS media queries will automatically apply the correct animation
  
  poleDiv.appendChild(animDisc);

  // Check if animations are disabled (speed = 0)
  const animationSpeed = parseFloat(document.documentElement.style.getPropertyValue('--animation-speed') || '1');
  const isInstantAnimation = animationSpeed === 0;

  // after drop animation, commit, then animate merge cascade step-by-step
  const handlePlacement = async () => {
    // Add safety timeout to prevent hanging
    const safetyTimeout = setTimeout(() => {
      if (placing) {
        console.error('Placement safety timeout - forcing completion');
        placing = false;
        
        render();
        checkGameOver();
      }
    }, 10000); // 10 second safety timeout
    
    try {
      poles[idx].push(nextPiece);
      
      // Check if this is a purchased bomb that needs payment
      if (bombSelected && nextPiece.bomb) {
        // Deduct gold for the bomb usage
        gold -= bombConversionCost;
        
        // Play purchase sound for the bomb usage
        soundManager.playPurchaseSound();
        
        // Increment press count and double the cost for next time
        bombConversionCost *= 2;
        
        // Update button cost display
        if (bombCostEl) {
          bombCostEl.textContent = formatNumber(bombConversionCost);
        }
        if (bombCostElMobile) {
          bombCostElMobile.textContent = formatNumber(bombConversionCost);
        }
        
        // Reset bomb selection since it's now placed
        bombSelected = false;
        
        // Update gold display
        updateGoldDisplay();
        
        // Update button states
        updateBombConversionButtonState();
        updateBombButtonIfGoldChanged();
        
        console.log(`Bomb placed! Deducted ${bombConversionCost / 2} gold, new cost: ${bombConversionCost}`);
        
        // Save game state after bomb payment
        saveGameState();
      }
      
      // scoring: add only the dropped piece's weight
      score += nextPiece.w;
      updateScoreDisplay();
      
      // Check for theme unlocks
      if (score >= 5000 && !themeManager.isThemeUnlocked('alternate')) {
        if (themeManager.unlockTheme('alternate')) {
          console.log('🎉 Earth theme unlocked! Score:', score);
          
          // Play theme unlock sound
          if (soundManager && soundManager.canPlayAudio()) {
            soundManager.playSound('themeUnlock', 'other').catch(error => {
              console.log('Could not play theme unlock sound:', error);
            });
          }
          
          // Add green glow to settings button to indicate new theme available
          const settingsBtn = document.getElementById('settingsBtn');
          if (settingsBtn) {
            settingsBtn.classList.add('settings-glow');
          }
          
          // Update theme selectors to show the new unlock status
          if (typeof updateThemeSelectors === 'function') {
            // Add a small delay to ensure DOM elements are ready
            setTimeout(() => {
              updateThemeSelectors();
              console.log('🎨 Theme selectors updated after unlock');
            }, 100);
          }
        }
      }
      
      // Save game state after placing a block
      console.log('🔄 Triggering save after block placement...');
      saveGameState();
      
      // Add pulse animation to the score display
      const scoreDisplay = document.querySelector('.score-value');
      if (scoreDisplay) {
        scoreDisplay.classList.add('pulse');
        setTimeout(() => {
          scoreDisplay.classList.remove('pulse');
        }, 300);
      }
      
      // Increment blocks dropped counter (only for regular pieces, not custom debug pieces)
      if (!wasCustomBlock) {
        blocksDropped++;
        totalBlocksDropped++;
      }
      
      // Only advance the queue if we used a regular piece, not a custom one
      if (!wasCustomBlock) {
        // animate next queue: consume current, shift others, append new
        await animateNextQueueAdvance(); // false = queue not yet modified
      }
      
      render();
      try {
        await animateMergeCascade(idx);
        
        // Only set placing to false after merge cascade completes
        placing = false;
        console.log('Placement completed, placing set to false');
      } catch (error) {
        console.error('Merge cascade error:', error);
        // Force reset placing flag on error to prevent game freeze
        placing = false;
        console.log('Placement error - forcing placing to false');
        
        // Re-enable hover effects and pointer events after placing is false
        const allPoles = Array.from(gameDiv.children);
        allPoles.forEach(poleDiv => {
          poleDiv.style.pointerEvents = '';
          poleDiv.classList.remove('no-hover');
          console.log('Removed no-hover class from pole (error):', poleDiv);
        });
      }
      render();
      checkGameOver();
      

      
    } finally {
      clearTimeout(safetyTimeout);
    }
  };

  // If animations are disabled or very fast, execute placement immediately
  if (isInstantAnimation || animationSpeed <= 0.5) {
    console.log(`Fast/instant animation detected (${animationSpeed}), executing placement immediately`);
    // Remove the animated disc since we don't need it
    animDisc.remove();
    // Execute placement logic immediately
    handlePlacement();
  } else {
    // Wait for animation to complete
    console.log(`Normal animation speed (${animationSpeed}), waiting for animationend event`);
    animDisc.addEventListener('animationend', handlePlacement, { once: true });
  }
}

function waitForAnimation(element){
  return new Promise(resolve => {
    // Check if animations are disabled (speed = 0)
    const animationSpeed = element.style.getPropertyValue('--animation-speed') || 
                          document.documentElement.style.getPropertyValue('--animation-speed') || '1';
    const speedValue = parseFloat(animationSpeed);
    
    if (speedValue === 0) {
      console.log('Animations disabled, resolving immediately');
      // Add a small delay to ensure DOM updates are processed
      setTimeout(resolve, 10);
      return;
    }
    
    // For very fast animations (speed <= 0.5), add a small delay to ensure proper timing
    if (speedValue <= 0.5) {
      console.log(`Very fast animation detected (${speedValue}), adding delay`);
      setTimeout(resolve, Math.max(50, speedValue * 100)); // At least 50ms delay
      return;
    }
    
    // CRITICAL FIX: Check if animation is already running BEFORE setting up listeners
    const computedStyle = window.getComputedStyle(element);
    const animationName = computedStyle.animationName;
    const animationDuration = parseFloat(computedStyle.animationDuration) || 0;
    const animationDelay = parseFloat(computedStyle.animationDelay) || 0;
    const totalAnimationTime = (animationDuration + animationDelay) * 1000; // Convert to ms
    
    console.log('Animation check for element:', element, {
      animationName,
      animationDuration: animationDuration + 's',
      animationDelay: animationDelay + 's',
      totalAnimationTime: totalAnimationTime + 'ms',
      computedStyle: {
        transform: computedStyle.transform,
        opacity: computedStyle.opacity,
        filter: computedStyle.filter
      }
    });
    
    if (animationName === 'none') {
      console.log('No animation detected, resolving immediately');
      resolve();
      return;
    }
    
    // Check if animation has already completed by looking at animation state
    // This prevents the race condition where animation finishes before we start listening
    if (totalAnimationTime <= 100) {
      console.log(`Very short animation detected (${totalAnimationTime}ms), resolving immediately`);
      setTimeout(resolve, totalAnimationTime + 10); // Wait for animation to complete + small buffer
      return;
    }
    
    // Add multiple event listeners to catch different animation end events
    const handleAnimationEnd = (event) => {
      console.log('Animation ended for element:', element, 'Event type:', event.type, 'Animation name:', event.animationName);
      resolve();
    };
    
    // Add more comprehensive event listeners
    element.addEventListener('animationend', handleAnimationEnd, { once: true });
    element.addEventListener('webkitAnimationEnd', handleAnimationEnd, { once: true });
    element.addEventListener('mozAnimationEnd', handleAnimationEnd, { once: true });
    element.addEventListener('MSAnimationEnd', handleAnimationEnd, { once: true });
    
    // Also listen for animation iteration and start events for debugging
    element.addEventListener('animationstart', (event) => {
      console.log('Animation started for element:', element, 'Animation name:', event.animationName);
    }, { once: true });
    
    element.addEventListener('animationiteration', (event) => {
      console.log('Animation iteration for element:', element, 'Animation name:', event.animationName);
    }, { once: true });
    
    // Fallback timeout to prevent hanging - use actual animation duration + buffer
    const timeoutDuration = Math.max(1500, totalAnimationTime + 500); // At least 1.5s, or animation time + 500ms buffer
    
    // Add a more robust fallback that checks animation state periodically
    const checkAnimationState = () => {
      const currentStyle = window.getComputedStyle(element);
      const currentAnimationName = currentStyle.animationName;
      
      if (currentAnimationName === 'none') {
        console.log(`Animation state check: ${animationName} completed naturally`);
        resolve();
        return;
      }
      
      // Check if we're past the expected animation time
      const elapsed = Date.now() - startTime;
      if (elapsed >= totalAnimationTime + 100) { // Add 100ms buffer
        console.log(`Animation state check: ${animationName} should be complete after ${elapsed}ms, forcing resolution`);
        resolve();
        return;
      }
      
      // Continue checking
      setTimeout(checkAnimationState, 50); // Check every 50ms
    };
    
    const startTime = Date.now();
    
    // Start the periodic check
    setTimeout(checkAnimationState, 50);
    
    // Traditional timeout fallback as backup
    setTimeout(() => {
      console.log(`Animation timeout fallback triggered for: ${animationName} (after ${timeoutDuration}ms)`);
      resolve();
    }, timeoutDuration);
  });
}

// Function to check if any animations are currently running
function areAnyAnimationsRunning() {
  // Check all poles for running animations
  const allPoles = Array.from(gameDiv.children);
  for (const pole of allPoles) {
    const discs = pole.querySelectorAll('.disc');
    for (const disc of discs) {
      const computedStyle = window.getComputedStyle(disc);
      const animationName = computedStyle.animationName;
      if (animationName !== 'none') {
        console.log('Found running animation on disc:', animationName, disc);
        return true;
      }
    }
  }
  
  // Check next queue for running animations
  const nextItems = nextContainer.querySelectorAll('.next-disc');
  for (const item of nextItems) {
    const computedStyle = window.getComputedStyle(item);
    const animationName = computedStyle.animationName;
    if (animationName !== 'none') {
      console.log('Found running animation on next item:', animationName, item);
      return true;
    }
  }
  
  return false;
}

async function animateMergeCascade(index){
  console.log('Starting merge cascade for pole:', index);
  
  // Reset merge count for new cascade
  soundManager.setCurrentMergeCount(0);
  console.log('🔄 Starting new merge cascade - reset merge count to 0');
  
  // Global timeout to prevent infinite hanging
  const globalTimeout = setTimeout(() => {
    console.error('Merge cascade global timeout - forcing completion');
    throw new Error('Merge cascade timeout');
  }, 5000); // 5 second global timeout
  
  try {
    let iterationCount = 0;
    const maxIterations = 20; // Prevent infinite loops
    let mergeCount = 0; // Track number of merges in this cascade for gold calculation
    
    while (true){
      iterationCount++;
      if (iterationCount > maxIterations) {
        console.error('Merge cascade exceeded max iterations, forcing completion');
        break;
      }
      
      const poleArr = poles[index];
      // find top-first adjacent equal pair
      let pairIndex = -1;
      for (let i = poleArr.length - 1; i > 0; i--) {
        if (poleArr[i] && poleArr[i - 1] && poleArr[i].w === poleArr[i - 1].w) { pairIndex = i; break; }
      }
      if (pairIndex === -1) {
        console.log('No more merges found, breaking');
        break;
      }
    
    console.log('Found merge pair at index:', pairIndex, 'weights:', poleArr[pairIndex].w, poleArr[pairIndex-1].w);

    // animate both discs merging out with enhanced visual effects
    const poleDiv = gameDiv.children[index];
    const discs = poleDiv.querySelectorAll('.disc');
    const topEl = discs[pairIndex];
    const belowEl = discs[pairIndex - 1];
    if (!topEl || !belowEl) break;
    
    try {
      // Add glow effect to both discs before merging
      topEl.classList.add('merging');
      belowEl.classList.add('merging');
      
      // Stagger the merge-out animations slightly for better visual flow
      topEl.classList.add('merge-out');
      await new Promise(resolve => setTimeout(resolve, 25)); // Reduced delay for snappier effect
      belowEl.classList.add('merge-out');
      
      // Small delay to ensure CSS classes are applied and animations start
      await new Promise(resolve => setTimeout(resolve, 10));
      
      // Wait for both animations to complete with error handling
      await Promise.all([
        waitForAnimation(topEl).catch(err => console.log('Top animation error:', err)),
        waitForAnimation(belowEl).catch(err => console.log('Bottom animation error:', err))
      ]);
      
      // Remove glow effects
      topEl.classList.remove('merging');
      belowEl.classList.remove('merging');
    } catch (error) {
      console.log('Merge animation error:', error);
      // Clean up classes in case of error
      topEl.classList.remove('merging', 'merge-out');
      belowEl.classList.remove('merging', 'merge-out');
    }

    // commit merge to data model
    const a = poleArr[pairIndex];
    const b = poleArr[pairIndex - 1];
    const newW = a.w * 2; // weights are equal here
    const isBombMerge = a.bomb || b.bomb;
    poleArr.splice(pairIndex - 1, 2, { w: newW, bomb: isBombMerge });
    
    // Increment merge count for cascade sound effects
    mergeCount++;
    
    // Set the merge count for cascade sound effects
    soundManager.setCurrentMergeCount(mergeCount);
    console.log(`🔗 Cascade merge #${mergeCount}: Setting merge count for sound effects`);
    
    // Play merge sound effect for the newly created block
    soundManager.playMergeSound(newW);
    
    // Earn gold for this merge (increases by 1 for each merge in the cascade, multiplied by current stage)
    const baseGoldEarned = mergeCount;
    // Stage 1: 1x multiplier, Stage 2+: 10x multiplier
    const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
    const goldEarned = baseGoldEarned * stageMultiplier;
    gold += goldEarned;
    goldEarnedThisGame += goldEarned; // Track gold earned in current game
    lifetimeGoldEarned += goldEarned; // Track lifetime gold earned
    updateGoldDisplay();
    
    // Update statistics modal if it's open
    if (statsModal && !statsModal.classList.contains('hidden')) {
      updateStatsModal();
    }
    
    console.log(`Merge ${mergeCount}: Earned ${formatNumber(goldEarned)} gold (${baseGoldEarned} × ${stageMultiplier}x multiplier) (Total: ${formatNumber(gold)}, This Game: ${formatNumber(goldEarnedThisGame)}, Lifetime: ${formatNumber(lifetimeGoldEarned)})`);
    
    // Show gold earned animation
    showGoldEarned(goldEarned);
    
    // Play coin sound effect for earning gold
    soundManager.playCoinSound();
    
    // Update bomb conversion button state
    updateBombButtonIfGoldChanged();
    // Update trash button state
    updateTrashButtonIfGoldChanged();
    
    // Save game state after merge and gold earning
    console.log('🔄 Triggering save after merge...');
    saveGameState();

    if (isBombMerge){
      // Bomb merge - clear the entire stack
      totalBombsExploded++; // Track total bombs exploded
      await animateClearPoleWithFallingBlock(index, pairIndex - 1, newW);
      // after animation, pole is cleared; continue which will break
      continue;
    }
    
      // Check if this merge unlocks a new stack (stage progression)
  if (newW === currentTargetBlockSize * 2){
    console.log(`Stage progression triggered! Merged to ${newW}, target was ${currentTargetBlockSize}`);
    // Check if this merge unlocks a new block size for future drops BEFORE stage progression
    checkForNewBlockSize(newW);
    // Stage progression: keep the merged block, clear the rest of the stack
    await animateStageProgression(index, pairIndex - 1, newW);
    // Check if we should add a new stack
    checkForNewStack();
    // after animation, pole has only the merged block; continue which will break
    continue;
  }

    // Check if this merge unlocks a new block size for future drops
    checkForNewBlockSize(newW);
    
    // re-render and pop-in the new merged disc with enhanced effects
    render();
    const poleDivAfter = gameDiv.children[index];
    const discsAfter = poleDivAfter.querySelectorAll('.disc');
    const mergedEl = discsAfter[pairIndex - 1];
    if (mergedEl){
      try {
        // Add glow effect for the new merged block
        mergedEl.classList.add('merging');
        mergedEl.classList.add('merge-in');
        
        // Small delay to ensure CSS class is applied and animation starts
        await new Promise(resolve => setTimeout(resolve, 10));
        
        await waitForAnimation(mergedEl);
        mergedEl.classList.remove('merge-in');
        mergedEl.classList.remove('merging');
      } catch (error) {
        console.log('Merge-in animation error:', error);
        // Clean up classes in case of error
        mergedEl.classList.remove('merging', 'merge-in');
      }
    }
    
    console.log('Merge iteration completed, checking for more merges...');
    
    // Re-render to ensure DOM is up to date before next iteration
    // Note: This render call is now conditional to prevent excessive rendering
    if (gameDiv.children.length !== 4) {
      console.warn('Pole count mismatch detected, re-rendering...');
      render();
    }
  }
  
  console.log('Merge cascade completed for pole:', index);
  
  // Re-enable hover effects and pointer events after the cascade is complete
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = '';
    poleDiv.classList.remove('no-hover');
    console.log('Re-enabled hover effects for pole:', poleDiv);
  });
  
  } finally {
    clearTimeout(globalTimeout);
  }
}

function checkGameOver(){
  if (!hasAnyMove(nextQueue[0])){
    if (aiEnabled) toggleAI(false);
    showGameOver();
  }
}

function showGameOver(){
  // Play game over sound effect
  soundManager.playGameOverSound();
  
  // Show game over button overlay centered on screen with fade-in effect
  const gameOverButton = document.getElementById('gameOverButton');
  if (gameOverButton) {
    // Small delay to make the fade-in more noticeable
    setTimeout(() => {
      gameOverButton.classList.add('show');
    }, 200);
  }
  
  // Calculate and display the largest merge block
  const largestMergeBlock = document.getElementById('largestMergeBlock');
  if (largestMergeBlock && weights && weights.length > 0) {
    const highestBlock = Math.max(...weights);
    largestMergeBlock.setAttribute('data-value', highestBlock);
    
    // Apply themed colors using the colorFor function, just like regular game blocks
    largestMergeBlock.style.background = colorFor(highestBlock);
    largestMergeBlock.style.color = getTextColorFor(highestBlock);
    
    // Use the same number formatting as regular game blocks
    largestMergeBlock.textContent = highestBlock >= 100000 ? formatNumber(highestBlock) : String(highestBlock);
  }
  
  // Display gold earned in this game
  const goldEarnedDisplay = document.getElementById('goldEarnedDisplay');
  if (goldEarnedDisplay) {
    goldEarnedDisplay.innerHTML = `
      <div class="gold-emoji">💰</div>
      <div class="gold-text">${formatNumber(goldEarnedThisGame)}</div>
    `;
  }
  
  // Add glowing effect to the ➕ button to guide user to start new game
  const addBtn = document.getElementById('addBtn');
  if (addBtn) {
    addBtn.classList.add('game-over-glow');
  }
  
  // Reset bomb selection state when game over is reached
  bombSelected = false;
  
  // Check if this is a new high score
  const previousHighScore = window.highScore || 0;
  const isNewHighScore = score > previousHighScore;
  if (isNewHighScore) {
    window.highScore = score;
    
    // Update statistics modal if it's open
    if (statsModal && !statsModal.classList.contains('hidden')) {
      updateStatsModal();
    }
  }
  
  // Show "New High Score!" message if we achieved a new personal best this game
  console.log('🔍 Game over check - hasShownPersonalBest:', hasShownPersonalBest, 'totalGames:', window.totalGames);
  
  if (hasShownPersonalBest && window.totalGames > 0) {
    const newHighScoreMessage = document.getElementById('newHighScoreMessage');
    if (newHighScoreMessage) {
      newHighScoreMessage.classList.remove('hidden');
    }
    console.log('🏆 NEW HIGH SCORE! Current score:', score, 'Previous best:', previousHighScore, 'Total games:', window.totalGames);
  } else if (hasShownPersonalBest && window.totalGames === 0) {
    console.log('🎮 First game ever - no high score message shown. Score:', score, 'Total games:', window.totalGames);
  } else {
    // Hide the message if no new personal best was achieved
    const newHighScoreMessage = document.getElementById('newHighScoreMessage');
    if (newHighScoreMessage) {
      newHighScoreMessage.classList.add('hidden');
    }
    console.log('ℹ️ No new personal best achieved this game - hiding high score message');
  }
  
  // Note: Pole interactions are no longer disabled to allow players to examine the final state
  
  // Increment total games counter when game ends
  window.totalGames++;
  console.log('🎮 Game ended. Total games played:', window.totalGames);
  

  
  // Save final game state when game over is reached
  console.log('🔄 Triggering final save at game over...');
  saveGameState();
}



function resetGame(isFreshGame = true){
  // Hide game over button overlay
  const gameOverButton = document.getElementById('gameOverButton');
  if (gameOverButton) {
    gameOverButton.classList.remove('show');
  }
  
  // Clear the largest merge block display
  const largestMergeBlock = document.getElementById('largestMergeBlock');
  if (largestMergeBlock) {
    largestMergeBlock.textContent = '';
    largestMergeBlock.removeAttribute('data-value');
    // Reset inline styles to default
    largestMergeBlock.style.background = '';
    largestMergeBlock.style.color = '';
  }
  
  // Clear the gold earned display
  const goldEarnedDisplay = document.getElementById('goldEarnedDisplay');
  if (goldEarnedDisplay) {
    goldEarnedDisplay.innerHTML = `
      <div class="gold-emoji">💰</div>
      <div class="gold-text">0</div>
    `;
  }
  
      // Remove glowing effect from the ➕ button
  const addBtn = document.getElementById('addBtn');
  if (addBtn) {
    addBtn.classList.remove('game-over-glow');
  }
  
  // Remove glowing effect from the settings button
  const settingsBtn = document.getElementById('settingsBtn');
  if (settingsBtn) {
    settingsBtn.classList.remove('settings-glow');
  }
  
  poles = [[],[],[],[]];
  score = 0;
  gold = 0; // Reset gold counter
  goldEarnedThisGame = 0; // Reset gold earned this game counter
  hasShownPersonalBest = false; // Reset personal best flag for new game
  blocksDropped = 0; // Reset blocks dropped counter
  currentTargetBlockSize = STARTING_BLOCK_SIZE; // Reset target block size
  currentStackCapacity = MAX_HEIGHT; // Reset stack capacity
  currentStage = 1; // Reset stage counter
  
  // Only reset button costs if this is a fresh game (not a UI reset)
  if (isFreshGame) {
    // Reset bomb conversion button state
    bombConversionCost = 25;
    bombConversionPresses = 0;
    lastGoldAmount = 0; // Reset tracked gold amount to force button state update
    bombSelected = false; // Reset bomb selection state
    previousBombCost = 25; // Reset previous bomb cost
    
    // Reset trash button state
    trashButtonCost = 25;
    trashButtonPresses = 0;
  }
  
  // Update cost displays after reset (only if costs were actually reset)
  if (isFreshGame) {
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostEl) {
      trashCostEl.textContent = formatNumber(trashButtonCost);
    }
    if (bombCostElMobile) {
      bombCostElMobile.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostElMobile) {
      trashCostElMobile.textContent = formatNumber(trashButtonCost);
    }
  }
  
  // Reset weights and probabilities to initial state
  weights = [1, 2];
  
  // Reset decay factor to default for fresh games
  if (isFreshGame) {
    currentActiveDecayFactor = PROBABILITY_DECAY_FACTOR;
  }
  
  // Let updateProbabilityDistribution calculate the correct initial probabilities
  updateProbabilityDistribution();
  
  nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
  placing = false;
  
  // Re-enable hover effects and pointer events on all poles
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = '';
    poleDiv.classList.remove('no-hover');
  });
  
  // Reset custom block mode
  customBlockMode = false;
  
  // Reset speed to default (Medium)
  currentSpeed = 2;
  updateAnimationSpeed();
  
  updateStackHeight();
  updateScoreDisplay();
  updateGoldDisplay();
  render();
  
  // Clear saved game after reset
  clearGameSave();
}

// ------------------
// AI logic: simplified to focus on core priorities:
// 1. MERGING - If a merge can be made, do it immediately
// 2. CLEAN STACKS - Place blocks on next size up (16 on 32, 8 on 16, etc.)
// 3. NEXT CLOSEST - Place on closest larger size when optimal isn't available
// 4. BOMB STRATEGY - Clean up messy stacks, avoid disrupting valuable ones
// 5. MINIMAL DISRUPTION - Only disrupt when necessary, prefer empty poles
// ------------------
function topOf(pole){
  return pole.length === 0 ? null : pole[pole.length - 1];
}

function canPlaceOnPole(pieceOrWeight, pole){
  const weight = typeof pieceOrWeight === 'number' ? pieceOrWeight : pieceOrWeight.w;
  const top = topOf(pole);
  return pole.length < currentStackCapacity || (top && top.w === weight);
}

function hasAnyMove(pieceOrWeight){
  return poles.some(p => canPlaceOnPole(pieceOrWeight, p));
}

async function animateNextQueueAdvance(queueAlreadyModified = false){
  // add consume animation to current
  const items = nextContainer.querySelectorAll('.next-disc');
  const current = items[0];
  const second = items[1];
  const third = items[2];
  if (current) current.classList.add('consume-out');
  if (second) second.classList.add('shift-left');
  if (third) third.classList.add('shift-left');

  // wait for ALL animations to complete before proceeding
  // Small delay to ensure CSS classes are applied and animations start
  await new Promise(resolve => setTimeout(resolve, 10));
  
  const animations = [];
  if (current) animations.push(waitForAnimation(current));
  if (second) animations.push(waitForAnimation(second));
  if (third) animations.push(waitForAnimation(third));
  
  // Wait for all animations to complete
  await Promise.all(animations);

  // Only update queue data if it hasn't already been modified
  if (!queueAlreadyModified) {
    // Reset bomb selection state when the queue advances (bomb was placed)
    bombSelected = false;
    
    nextQueue.shift();
    nextQueue.push(getRandomPiece());
  }
  
  renderNext();
  
  // Update button states since queue changed
  updateBombButtonIfGoldChanged();
  updateTrashButtonIfGoldChanged();
}

function getElementPageRect(el){
  const r = el.getBoundingClientRect();
  return { left: r.left + window.scrollX, top: r.top + window.scrollY, width: r.width, height: r.height };
}



async function animateStageProgression(index, mergedIndex, weight){
  // Render so the merged block exists in the DOM
  render();
  const poleDiv = gameDiv.children[index];
  const discs = poleDiv.querySelectorAll('.disc');
  const mergedEl = discs[mergedIndex];
  if(!mergedEl){
    poles[index] = [];
    render();
    return;
  }

        // Let the new block behave like a normal merge result first
      mergedEl.classList.add('merge-in');
      
      // Small delay to ensure CSS class is applied and animation starts
      await new Promise(resolve => setTimeout(resolve, 10));
      
      await waitForAnimation(mergedEl);
      mergedEl.classList.remove('merge-in');

  // Now treat the target block like a bomb - make it explode and clear the entire stack
  const allDiscs = Array.from(poleDiv.querySelectorAll('.disc'));
  
  // Check if animations are disabled (speed = 0)
  const animationSpeed = parseFloat(document.documentElement.style.getPropertyValue('--animation-speed') || '1');
  const isInstantAnimation = animationSpeed === 0;
  
  if (isInstantAnimation) {
    // Instant animation - immediately hide all blocks
    allDiscs.forEach(d => {
      d.style.transform = 'scale(0.8)';
      d.style.opacity = '0';
      d.style.filter = 'brightness(0.8) saturate(0.9)';
    });
  } else {
    // Start the explosion from the merged block (target location) and propagate outward in both directions
    const targetIndex = mergedIndex; // The target block location
    
    // First, apply the bomb explosion effect to the target block itself
    const targetDisc = allDiscs[targetIndex];
    if (targetDisc) {
      targetDisc.classList.add('bomb-explosion');
      // Play stage up sound effect for the stage progression
      soundManager.playStageProgressionSound();
    }
    
    // Then apply the shockwave effect to other blocks with decreasing intensity
    for (let i = 0; i < allDiscs.length; i++) {
      if (i === targetIndex) continue; // Skip the target block, it already has explosion effect
      
      const disc = allDiscs[i];
      // Calculate distance from target location for wave propagation
      const distanceFromTarget = Math.abs(i - targetIndex);
      // Add a small delay to create the wave effect, starting from target location
      const delay = distanceFromTarget * 40; // 40ms delay per block distance for the ripple effect (faster)
      
      setTimeout(() => {
        disc.classList.add('bomb-ripple');
        // No more individual sound effects - just visual ripple effect
      }, delay);
    }
    
    // Wait for the entire explosion animation to complete
    const totalAnimationTime = Math.max(...Array.from({length: allDiscs.length}, (_, i) => 
      Math.abs(i - targetIndex) * 40 + 350
    )); // Max delay + 350ms animation duration (faster)
    await new Promise(resolve => setTimeout(resolve, totalAnimationTime));
    
    // Clean up the explosion and ripple classes
    allDiscs.forEach(d => {
      d.classList.remove('bomb-explosion');
      d.classList.remove('bomb-ripple');
    });
  }

  // Clear the entire pole
  poles[index] = [];
  
  // Now create the new target block
  const newBlock = { w: weight, bomb: false };
  poles[index].push(newBlock);
  
  // Re-render to show the cleared stack with the new target block
  render();
}

async function animateClearPoleWithFallingBlock(index, mergedIndex, weight){
  // Render so the merged block exists in the DOM
  render();
  const poleDiv = gameDiv.children[index];
  const discs = poleDiv.querySelectorAll('.disc');
  const mergedEl = discs[mergedIndex];
  if(!mergedEl){
    poles[index] = [];
    render();
    return;
  }

  // Bombs no longer give gold rewards when clearing stacks



  // Let the new block behave like a normal merge result first
  mergedEl.classList.add('merge-in');
  
  // Small delay to ensure CSS class is applied and animation starts
  await new Promise(resolve => setTimeout(resolve, 10));
  
  await waitForAnimation(mergedEl);
  mergedEl.classList.remove('merge-in');

  // Create a shockwave ripple effect that propagates through the stack
  const allDiscs = Array.from(poleDiv.querySelectorAll('.disc'));
  
  // Check if animations are disabled (speed = 0)
  const animationSpeed = parseFloat(document.documentElement.style.getPropertyValue('--animation-speed') || '1');
  const isInstantAnimation = animationSpeed === 0;
  
  if (isInstantAnimation) {
    // Instant animation - immediately hide all blocks
    allDiscs.forEach(d => {
      d.style.transform = 'scale(0.8)';
      d.style.opacity = '0';
      d.style.filter = 'brightness(0.8) saturate(0.9)';
    });
  } else {
    // Start the explosion from the merged block (bomb location) and propagate outward in both directions
    const bombIndex = mergedIndex; // The bomb merge location
    
    // Track total bombs exploded
    totalBombsExploded++;
    
    // First, apply the bomb explosion effect to the bomb block itself
    const bombDisc = allDiscs[bombIndex];
    if (bombDisc) {
      bombDisc.classList.add('bomb-explosion');
      // Play bomb sound effect for the initial bomb explosion
      soundManager.playBombSound();
    }
    
    // Then apply the shockwave effect to other blocks with decreasing intensity
    for (let i = 0; i < allDiscs.length; i++) {
      if (i === bombIndex) continue; // Skip the bomb block, it already has explosion effect
      
      const disc = allDiscs[i];
      // Calculate distance from bomb location for wave propagation
      const distanceFromBomb = Math.abs(i - bombIndex);
      // Add a small delay to create the wave effect, starting from bomb location
      const delay = distanceFromBomb * 40; // 40ms delay per block distance for the ripple effect (faster)
      
      setTimeout(() => {
        disc.classList.add('bomb-ripple');
        // No more individual sound effects - just visual ripple effect
      }, delay);
    }
    
    // Wait for the entire explosion animation to complete
    const totalAnimationTime = Math.max(...Array.from({length: allDiscs.length}, (_, i) => 
      Math.abs(i - bombIndex) * 40 + 350
    )); // Max delay + 350ms animation duration (faster)
    await new Promise(resolve => setTimeout(resolve, totalAnimationTime));
    
    // Clean up the explosion and ripple classes
    allDiscs.forEach(d => {
      d.classList.remove('bomb-explosion');
      d.classList.remove('bomb-ripple');
    });
  }

  // Clear pole and re-render
  poles[index] = [];
  render();
}

function choosePoleFor(pieceOrWeight){
  console.log('choosePoleFor called with:', pieceOrWeight);
  let avail = poles.map((p,i)=> ({p,i})).filter(x=> canPlaceOnPole(pieceOrWeight, x.p));
  console.log('Available poles:', avail);
  if(avail.length === 0) {
    console.log('No available poles found');
    return null;
  }
  
  const piece = typeof pieceOrWeight === 'number' ? { w: pieceOrWeight, bomb: false } : pieceOrWeight;
  const isBomb = piece.bomb;
  
  // Helper function to check if a stack is "messy" (order disrupted)
  function isStackMessy(pole) {
    if (pole.length < 2) return false;
    for (let i = pole.length - 1; i > 0; i--) {
      if (pole[i].w >= pole[i-1].w) return true; // Order is disrupted
    }
    return false;
  }
  
  // Helper function to get stack height
  function getStackHeight(pole) {
    return pole.length;
  }
  
  // Helper function to get total point value of a stack
  function getStackValue(pole) {
    return pole.reduce((sum, disc) => sum + disc.w, 0);
  }
  
  // Helper function to check if placing this piece would create a merge
  function wouldCreateMerge(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w === piece.w;
  }
  
  // Helper function to check if placing this piece would be on a block exactly 1 size above
  function wouldBeOnExactSize(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w === piece.w * 2;
  }
  
  // Helper function to check if placing this piece would be on a larger block (but not exact size)
  function wouldBeOnLargerBlock(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w > piece.w;
  }
  
  // Check for bomb in queue (special case 1.5)
  const hasBombInQueue = nextQueue.some(p => p.bomb);
  const isBombMatch = hasBombInQueue && nextQueue.some(p => p.bomb && p.w === piece.w);
  
  if (!isBomb) {
    // NORMAL BLOCKS LOGIC
    
    // Priority 1: Merges (100% override)
    const mergeOptions = avail.filter(x => wouldCreateMerge(x.p, piece));
    if (mergeOptions.length > 0) {
      return mergeOptions[0].i;
    }
    
    // Priority 1.5: Avoid placing normal blocks on stacks with bombs anywhere in them
    // This prevents cutting off bombs from being able to merge and clear the stack
    const bombAvoidanceOptions = avail.filter(x => {
      if (x.p.length === 0) return true; // Empty stack is fine
      
      // Check if there's a bomb anywhere in the stack
      const hasBombInStack = x.p.some(disc => disc.bomb);
      
      if (hasBombInStack) {
        // If there's a bomb in the stack, only allow placement if:
        // 1. The block is smaller than the bomb it would be placed on, OR
        // 2. We're placing on an empty stack (which shouldn't happen here, but safety check)
        const top = x.p[x.p.length - 1];
        if (top.bomb) {
          // Placing on a bomb - only allow if block is smaller
          return piece.w < top.w;
        } else {
          // Placing above a bomb - this would cut off the bomb, so never allow larger blocks
          return piece.w < top.w;
        }
      }
      
      return true; // No bomb in stack, so placement is fine
    });
    
    // If we have no valid options after bomb avoidance, fall back to all available
    if (bombAvoidanceOptions.length === 0) {
      // This should rarely happen, but if it does, we'll use the original avail list
      console.warn('AI: No bomb-avoidance options available, using fallback');
    } else {
      // Use the filtered options for the rest of the logic
      avail = bombAvoidanceOptions;
    }
    
    // Priority 2: Special case - bomb match in queue
    if (isBombMatch) {
      const messyStacks = avail.filter(x => isStackMessy(x.p));
      if (messyStacks.length > 0) {
        return messyStacks[0].i;
      }
    }
    
    // Priority 3: Place on block exactly 1 size above
    const exactSizeOptions = avail.filter(x => wouldBeOnExactSize(x.p, piece));
    if (exactSizeOptions.length > 0) {
      // Prefer stacks with less height if multiple options
      exactSizeOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
      return exactSizeOptions[0].i;
    }
    
    // Priority 4: Place on larger block (but not exact size)
    const largerBlockOptions = avail.filter(x => wouldBeOnLargerBlock(x.p, piece));
    if (largerBlockOptions.length > 0) {
      // Prefer messy stacks, then by height
      const messyOptions = largerBlockOptions.filter(x => isStackMessy(x.p));
      const cleanOptions = largerBlockOptions.filter(x => !isStackMessy(x.p));
      
      if (messyOptions.length > 0) {
        // Choose messiest stack among messy options
        messyOptions.sort((a, b) => {
          // Count how many order violations each stack has
          const getViolations = (pole) => {
            let violations = 0;
            for (let i = pole.length - 1; i > 0; i--) {
              if (pole[i].w >= pole[i-1].w) violations++;
            }
            return violations;
          };
          return getViolations(b.p) - getViolations(a.p); // More violations = messier
        });
        return messyOptions[0].i;
      } else {
        // All stacks are clean, choose by height
        cleanOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
        return cleanOptions[0].i;
      }
    }
    
    // Priority 5: Place on smaller block or empty stack
    const remainingOptions = avail.filter(x => !wouldBeOnLargerBlock(x.p, piece));
    if (remainingOptions.length > 0) {
      // Prefer messy stacks, then by height
      const messyOptions = remainingOptions.filter(x => isStackMessy(x.p));
      const cleanOptions = remainingOptions.filter(x => !isStackMessy(x.p));
      
      if (messyOptions.length > 0) {
        // Choose messiest stack among messy options
        messyOptions.sort((a, b) => {
          const getViolations = (pole) => {
            let violations = 0;
            for (let i = pole.length - 1; i > 0; i--) {
              if (pole[i].w >= pole[i-1].w) violations++;
            }
            return violations;
          };
          return getViolations(b.p) - getViolations(a.p);
        });
        return messyOptions[0].i;
      } else {
        // All stacks are clean, choose by height
        cleanOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
        return cleanOptions[0].i;
      }
    }
    
  } else {
    // BOMB LOGIC
    
    // Priority 1: Tallest, messiest stack
    const messyStacks = avail.filter(x => isStackMessy(x.p));
    if (messyStacks.length > 0) {
      // Sort by height first, then by messiness
      messyStacks.sort((a, b) => {
        const heightDiff = getStackHeight(b.p) - getStackHeight(a.p);
        if (Math.abs(heightDiff) > 0) return heightDiff;
        
        // If heights are equal, sort by messiness
        const getViolations = (pole) => {
          let violations = 0;
          for (let i = pole.length - 1; i > 0; i--) {
            if (pole[i].w >= pole[i-1].w) violations++;
          }
          return violations;
        };
        return getViolations(b.p) - getViolations(a.p);
      });
      return messyStacks[0].i;
    }
    
    // Priority 2: Must place on clean stack - choose lowest total value
    const cleanStacks = avail.filter(x => !isStackMessy(x.p));
    if (cleanStacks.length > 0) {
      cleanStacks.sort((a, b) => getStackValue(a.p) - getStackValue(b.p));
      return cleanStacks[0].i;
    }
  }
  
  // Fallback: return first available pole
  return avail[0].i;
}

function aiStep(){
  console.log('AI: aiStep called, placing:', placing, 'aiEnabled:', aiEnabled);
  
  if(placing) {
    console.log('AI: Waiting for placement to complete...');
    return;
  }
  
  // Safety check: if placing has been true for too long, reset it
  if (placing && Date.now() - lastPlacementTime > 10000) { // 10 second timeout
    console.warn('AI: Placement timeout detected, resetting placing flag');
    placing = false;
    
    // Re-enable hover effects and pointer events on all poles
    const allPoles = Array.from(gameDiv.children);
    allPoles.forEach(poleDiv => {
      poleDiv.style.pointerEvents = '';
      poleDiv.classList.remove('no-hover');
    });
  }
  
  // if game over, nothing to do
  const pick = choosePoleFor(nextQueue[0]);
  if(pick === null) { 
    console.log('AI: No valid move available, checking game over');
    checkGameOver(); 
    return; 
  }
  
  console.log('AI: Making move on pole', pick, 'with piece', nextQueue[0]);
  placeOnPole(pick);
}





// Initial render will happen after game state loading

// Initialize animation speed and stack height
updateAnimationSpeed();
updateStackHeight();

// Initialize displays with proper formatting
updateScoreDisplay();
updateGoldDisplay();

// Set up auto-save system
console.log('Setting up auto-save system...');
setupAutoSave();
console.log('Auto-save system initialized');

// Safety check: ensure we start with exactly 4 poles
// Only run after a short delay to ensure DOM is ready
setTimeout(() => {
  if (gameDiv && gameDiv.children) {
    ensureCorrectPoleCount();
  }
}, 100);

// Initialize debug pane - Block grid interface
document.addEventListener('DOMContentLoaded', () => {
  // Set initial selection to "No Block" option
  const noBlockOption = document.querySelector('.block-item[data-value="none"]');
  if (noBlockOption) {
    noBlockOption.classList.add('selected');
    customBlockSize = null;
    customBlockMode = false;
  }
  

  
  // Initial render is handled after game state loading
});

if (bombToggle && bombStatus) {
  bombToggle.checked = false;
  bombStatus.textContent = 'No';
  customBlockBomb = false;
}

// Initialize debug auto-play controls
if (debugSpeedSlider) {
  debugSpeedSlider.value = currentSpeed;
}
updateDebugSpeedLabel();
updateAnimationSpeed();

// Initialize bomb conversion button state
updateBombConversionButtonState();

// Handle window resize for mobile responsiveness
window.addEventListener('resize', () => {
  console.log('Window resized to', window.innerWidth, 'x', window.innerHeight, '- updating stack heights');
  updateStackHeight();
});

// GitHub Pages redirect fix - if we're on the wrong page, redirect to the game
(function() {
  // Check if we're on the right page by looking for game elements
  if (!document.getElementById('game')) {
    // We're probably on the README page, redirect to the game
    window.location.href = window.location.href;
  }
})();

// Global safety check to ensure we always have exactly 4 poles
function ensureCorrectPoleCount() {
  // Add cooldown to prevent too frequent checks
  if (window.lastSafetyCheck && Date.now() - window.lastSafetyCheck < 5000) {
    return; // Wait at least 5 seconds between safety checks
  }
  
  // Only run safety checks if the game is properly initialized
  if (!gameDiv || !gameDiv.children) {
    return; // Game not ready yet
  }
  
  // Check if we're currently in the middle of a render operation
  if (window.isRendering) {
    return; // Skip check during render to avoid interference
  }
  
  // Check if the game is still initializing
  if (typeof poles === 'undefined' || poles.length === 0) {
    return; // Game not fully initialized yet
  }
  
  // Check if the game is still in the initial loading phase
  if (window.gameInitializing) {
    return; // Game is still initializing, skip safety checks
  }
  
  if (poles.length !== 4) {
    console.warn(`Warning: Global pole count check found ${poles.length} poles instead of 4! Resetting to 4 poles.`);
    poles = [[],[],[],[]];
    // Force a re-render to fix the display
    render();
    return;
  }
  
  // Only check DOM if we have a valid gameDiv and it's not empty
  if (gameDiv.children.length === 0) {
    // DOM is empty, this might be during initial load - don't trigger re-render
    return;
  }
  
  // Only trigger re-render if we're significantly off (not just 1 element difference)
  // This prevents unnecessary re-renders for minor DOM inconsistencies
  if (gameDiv.children.length < 3 || gameDiv.children.length > 5) {
    console.warn(`Warning: DOM contains ${gameDiv.children.length} pole elements instead of 4! Re-rendering...`);
    render();
  } else if (gameDiv.children.length !== 4) {
    // Log minor inconsistencies but don't trigger re-render
    console.log(`Note: DOM has ${gameDiv.children.length} pole elements (expected 4) - minor inconsistency`);
  }
  
  // Update last safety check timestamp
  window.lastSafetyCheck = Date.now();
}

// Run safety check every 15 seconds (less frequent to reduce interference)
// Start after a delay to ensure game is fully initialized
setTimeout(() => {
  setInterval(ensureCorrectPoleCount, 15000);
}, 2000);

function testProbabilityDistribution() {
  console.log('=== Testing Probability Distribution ===');
  console.log('Current weights:', weights);
  console.log('Current probabilities:', probabilities);
  
  // Simulate 1000 random selections to test distribution
  const results = {};
  const iterations = 1000;
  
  for (let i = 0; i < iterations; i++) {
    const weight = getRandomWeight();
    results[weight] = (results[weight] || 0) + 1;
  }
  
  // Create the results table HTML
  let tableHTML = `
    <table class="prob-test-table">
      <thead>
        <tr>
          <th>Block</th>
          <th>Expected</th>
          <th>Actual</th>
          <th>Difference</th>
        </tr>
      </thead>
      <tbody>
  `;
  
  let totalExpected = 0;
  let totalActual = 0;
  
  for (const weight of weights) {
    const count = results[weight] || 0;
    const actualProb = count / iterations;
    const expectedProb = probabilities[weights.indexOf(weight)];
    const difference = Math.abs(actualProb - expectedProb);
    
    totalExpected += expectedProb;
    totalActual += actualProb;
    
    tableHTML += `
      <tr>
        <td class="block-value">${weight}</td>
        <td class="expected">${(expectedProb * 100).toFixed(2)}%</td>
        <td class="actual">${(actualProb * 100).toFixed(2)}%</td>
        <td class="difference">${(difference * 100).toFixed(2)}%</td>
      </tr>
    `;
    
    // Also log to console for debugging
    console.log(`Block ${weight}: Expected ${(expectedProb * 100).toFixed(2)}%, Got ${(actualProb * 100).toFixed(2)}%, Diff: ${(difference * 100).toFixed(2)}%`);
  }
  
  tableHTML += `
      </tbody>
    </table>
    
    <div class="prob-test-summary">
      <div class="total">Total Probability: ${(totalExpected * 100).toFixed(2)}% (Expected) vs ${(totalActual * 100).toFixed(2)}% (Actual)</div>
    </div>
  `;
  
  // Populate the modal content
  const contentDiv = document.getElementById('probTestContent');
  if (contentDiv) {
    contentDiv.innerHTML = tableHTML;
  }
  
  // Show the modal
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.remove('hidden');
  }
  
  console.log('=== End Test ===');
}

// Modal functionality
function showProbabilityTestModal() {
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.remove('hidden');
  }
}

function hideProbabilityTestModal() {
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.add('hidden');
  }
}

function logProbabilityState() {
  console.log('=== Current Probability State ===');
  console.log(`Total blocks available: ${weights.length}`);
  console.log('Block | Weight | Probability | Cumulative');
  console.log('------|--------|-------------|------------');
  
  let cumulative = 0;
  for (let i = 0; i < weights.length; i++) {
    cumulative += probabilities[i];
    console.log(`${i.toString().padStart(5)} | ${weights[i].toString().padStart(6)} | ${(probabilities[i] * 100).toFixed(2).padStart(11)}% | ${(cumulative * 100).toFixed(2).padStart(10)}%`);
  }
  
  console.log(`Total probability: ${(cumulative * 100).toFixed(2)}%`);
  console.log('=====================================');
}

// Test probabilities button
const testProbBtn = document.getElementById('testProbBtn');
testProbBtn.addEventListener('click', testProbabilityDistribution);





// Cascade test button
const cascadeTestBtn = document.getElementById('cascadeTestBtn');
if (cascadeTestBtn) {
  cascadeTestBtn.addEventListener('click', () => {
  // Clear the first column (pole 0)
  poles[0] = [];
  
  // Create a perfect cascade stack from 512 to 1
  // This will create the largest possible cascade when blocks are dropped
  const cascadeValues = [512, 256, 128, 64, 32, 16, 8, 4, 2, 1];
  
  cascadeValues.forEach(value => {
    poles[0].push({ w: value, bomb: false });
  });
  
  // Re-render the game to show the new stack
  render();
  
  // Automatically place a 1 block at the top to start the cascade
  // We need to temporarily set placing to false to allow the placement
  const originalPlacing = placing;
  placing = false;
  
  // Place the 1 block on top of the stack
  const nextPiece = { w: 1, bomb: false };
  poles[0].push(nextPiece);
  
  // Play drop sound effect
  soundManager.playDropSound(nextPiece.w);
  
  // Re-render to show the new block
  render();
  
  // Trigger the merge cascade automatically
  animateMergeCascade(0).then(() => {
    console.log('✅ Cascade test completed successfully');
  }).catch(error => {
    console.error('❌ Cascade test error:', error);
  });
  
  // Save game state after cascade test setup
  console.log('🔄 Triggering save after cascade test setup...');
  saveGameState();
  
  console.log('Cascade test stack created: 512 → 256 → 128 → 64 → 32 → 16 → 8 → 4 → 2 → 1 → 1 (cascade started)');
  });
} else {
  console.log('⚠️ Cascade test button not found');
}

// Probability test modal close button
const probTestClose = document.getElementById('probTestClose');
if (probTestClose) {
  probTestClose.addEventListener('click', hideProbabilityTestModal);
} else {
  console.log('⚠️ Probability test close button not found');
}

// Close probability test modal when clicking outside
const probTestModal = document.getElementById('probTestModal');
if (probTestModal) {
  probTestModal.addEventListener('click', (e) => {
    if (e.target === probTestModal) {
      hideProbabilityTestModal();
    }
  });
} else {
  console.log('⚠️ Probability test modal not found');
}



// Add keyboard support for probability test modal
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (probTestModal && !probTestModal.classList.contains('hidden')) {
      hideProbabilityTestModal();
    }
  }
});

// Initialize the game after all functions are defined
console.log('🎮 Starting game initialization...');

try {
  // Initialize safe viewport calculation for mobile devices
  console.log('📱 Initializing safe viewport calculation...');
  const initialSafeViewport = calculateSafeViewport();
  console.log('✅ Safe viewport calculated:', initialSafeViewport);
  
  // Set up initial probability distribution for the starting block sizes (1 and 2)
  console.log('📊 Setting up initial probability distribution...');
  updateProbabilityDistribution();
  console.log('✅ Probability distribution initialized');

  // Initialize next queue after probability distribution is set up
  console.log('🔄 Initializing next queue...');
  nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
  console.log('✅ Next queue initialized:', nextQueue);

  console.log('🎮 Game initialized with probability system');
  
  // localStorage is our primary storage method
  console.log('📱 Using localStorage for game data storage');
  
  // Set game initializing flag
  window.gameInitializing = true;
  
  // Now try to load saved game state
  console.log('=== ATTEMPTING TO LOAD SAVED GAME STATE ===');
  const gameLoaded = loadGameState();
  console.log('Load result:', gameLoaded ? 'SUCCESS' : 'FAILED - starting fresh game');
  
  // If no game loaded, ensure unlock status is reset to defaults
  // (but only if we're not in a clear operation)
  if (!gameLoaded && themeManager && !window.preventThemeUnlockLoad) {
    themeManager.themeUnlockRequirements = {
      'jellyfish': { unlocked: true, requirement: 'Default theme' },
      'alternate': { unlocked: false, requirement: 'Score 5000+ points' }
    };
    themeManager.saveUnlockStatus();
  }
  
  // Log final unlock status for debugging
  if (themeManager) {
    console.log('🎨 Final unlock status after initialization:', themeManager.themeUnlockRequirements);
  }
  
  // Force a render after loading (or if loading failed)
  console.log('🔄 Rendering game display...');
  render();
  renderNext();
  console.log('✅ Game display rendered');
  
  // Game is now fully initialized
  window.gameInitializing = false;
  
  // Initialize theme after game is fully rendered
  if (themeManager) {
    themeManager.initializeTheme();
  }
  
  // Update theme selectors to show unlock status
  if (typeof updateThemeSelectors === 'function') {
    updateThemeSelectors();
  }
  
  // Update debug block colors after theme initialization
  if (typeof updateDebugBlockColors === 'function') {
    updateDebugBlockColors();
  }
  
  // Check for game updates after everything is loaded and rendered
  setTimeout(async () => {
    try {
      console.log('📰 Checking for game updates...');
      const updates = await fetchUpdates();
      const newUpdates = checkForNewUpdates(updates);
      
      if (newUpdates.length > 0) {
        console.log('📰 Found new updates, showing modal...');
        showUpdateModal(newUpdates);
      } else {
        console.log('📰 No new updates to show');
      }
    } catch (error) {
      console.error('❌ Failed to check for updates:', error);
    }
  }, 1000); // Delay to ensure UI is fully rendered
  
  // Initialize help button glow for new players
  if (helpBtn) {
    if (!hasHelpButtonBeenClicked()) {
      console.log('🆕 New player detected - adding help button glow');
      helpBtn.classList.add('help-glow');
    } else {
      console.log('👤 Returning player - help button glow disabled');
    }
  } else {
    console.log('⚠️ Help button not found for glow initialization');
  }
  
  // Force scroll to top to prevent phantom scroll issues
  console.log('🔄 Resetting scroll position to top...');
  window.scrollTo(0, 0);
  if (window.visualViewport) {
    window.visualViewport.scrollTop = 0;
  }
  
  // Add window load event listener to ensure scroll stays at top
  window.addEventListener('load', () => {
    console.log('🔄 Window loaded - ensuring scroll position is at top...');
    setTimeout(() => {
      window.scrollTo(0, 0);
      if (window.visualViewport) {
        window.visualViewport.scrollTop = 0;
      }
    }, 100); // Small delay to ensure everything is fully loaded
  });
  
  // Add persistent scroll reset to catch browser restoration
  let scrollResetAttempts = 0;
  const maxScrollResetAttempts = 10;
  
  const persistentScrollReset = () => {
    if (scrollResetAttempts >= maxScrollResetAttempts) return;
    
    const currentScrollY = window.scrollY || 0;
    const currentVisualScrollTop = window.visualViewport ? window.visualViewport.scrollTop : 0;
    
    if (currentScrollY > 0 || currentVisualScrollTop > 0) {
      console.log(`🔄 Scroll reset attempt ${scrollResetAttempts + 1}: Y=${currentScrollY}, visualViewport.scrollTop=${currentVisualScrollTop}`);
      window.scrollTo(0, 0);
      if (window.visualViewport) {
        window.visualViewport.scrollTop = 0;
      }
      scrollResetAttempts++;
      
      // Try again after a short delay
      setTimeout(persistentScrollReset, 200);
    }
  };
  
  // Start persistent scroll reset after a delay
  setTimeout(persistentScrollReset, 500);
  

  
} catch (error) {
  console.error('❌ Error during game initialization:', error);
  console.error('Error stack:', error.stack);
}

</script>
</body>
</html>

