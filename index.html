<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stack Merge</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Quantico:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
  :root{ 
    --bg:#0f172a; 
    --panel:#1e293b; 
    --text:#f8fafc; 
    --font-family: 'Quantico', monospace;
  }
  body { margin:0; font-family: var(--font-family); background:var(--bg); color:var(--text); display:flex; flex-direction:column; align-items:center; }
  .topbar { width:100%; max-width:1200px; display:flex; flex-direction:column; align-items:center; gap:24px; padding:24px 16px 8px; box-sizing:border-box; }
  h1 { margin:0; font-size:36px; font-weight:700; text-align:center; font-family: var(--font-family); }
  
  /* Title section styling */
  .title-section { 
    display: flex; 
    flex-direction: row; 
    align-items: center; 
    gap: 24px; 
  }
  
  /* Title button styling */
  .title-btn {
    background: var(--panel);
    color: var(--text);
    border: 1px solid #475569;
    width: 40px;
    height: 40px;
    border-radius: 8px;
    font-weight: 700;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    font-family: var(--font-family);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  
  .title-btn:hover {
    background: #334155;
    border-color: #64748b;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(0,0,0,0.25);
  }
  
  .title-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
  }
  
  /* Glowing + button after game over */
  .title-btn.game-over-glow {
    box-shadow: 0 0 8px rgba(14, 165, 233, 0.5), 0 0 12px rgba(14, 165, 233, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    animation: breatheGlow 2s ease-in-out infinite;
  }
  
  @keyframes breatheGlow {
    0%, 100% { 
      box-shadow: 0 0 8px rgba(14, 165, 233, 0.5), 0 0 12px rgba(14, 165, 233, 0.3), 0 3px 0 rgba(0,0,0,0.25);
    }
    50% { 
      box-shadow: 0 0 12px rgba(14, 165, 233, 0.7), 0 0 16px rgba(14, 165, 233, 0.5), 0 3px 0 rgba(0,0,0,0.25);
    }
  }
  
  /* Mobile responsive sizing for title buttons */
  @media (max-width: 768px) {
    .title-btn {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      font-size: 16px;
    }
    
    .title-section {
      gap: 16px;
    }
  }
  

  
  /* Controls section styling */
  .controls { display:flex; align-items:center; gap:18px; }

  .game-info { display: flex; justify-content: center; gap: 48px; margin-top: 32px; }
  .score-display { display:flex; flex-direction:column; align-items:center; gap:12px; }
  .score-label { font-size:18px; opacity:0.9; font-family: var(--font-family); }
  .next { display:flex; flex-direction:column; align-items:center; gap:12px; }
  .next .label { font-size:18px; opacity:0.9; font-family: var(--font-family); }
  .next-row { display:flex; align-items:center; gap:12px; }
  .next-disc { width:108px; height:45px; border-radius:9px; display:flex; align-items:center; justify-content:center; font-weight:600; font-size:24px; box-shadow:0 3px 0 rgba(0,0,0,0.25); transition: transform calc(0.18s * var(--animation-speed, 1)) ease; font-family: var(--font-family); transform-origin: center center; }
  .next-disc.current { outline:3px solid #fff; outline-offset:3px; }
  .next-disc.consume-out { animation: nextConsume calc(0.18s * var(--animation-speed, 1)) ease forwards; }
  @keyframes nextConsume {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0.85); opacity: 0; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .next-disc.consume-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.85); opacity: 0; }
  .next-disc.shift-left { transform: translateX(-120px); }
  
  /* Instant animations when speed is 0 (Blazing) */
  .next-disc.shift-left[style*="--animation-speed: 0"] { transform: translateX(-120px); }


  
  /* Score value styling to match other modules */
  .score-value { 
    background: var(--panel); 
    color: var(--text); 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 24px; 
    min-width: 70px; 
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
  }
  
  /* Score star emoji styling as a badge in top left corner */
  .score-star {
    position: absolute;
    top: -12px;
    left: -12px;
    font-size: 28px;
    opacity: 1;
    z-index: 1;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }
  
  .score-text {
    position: relative;
    z-index: 2;
    font-size: 28px;
    font-weight: 600;
    line-height: 1;
    font-family: var(--font-family);
  }

  /* Gold display styling to match score display */
  .gold-display { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 12px; 
  }
  .gold-label { 
    font-size: 18px; 
    opacity: 0.9; 
    font-family: var(--font-family);
  }
  .gold-value { 
    background: #FCD34D; 
    color: #000; 
    padding: 10px 20px; 
    border-radius: 9px; 
    font-weight: 600; 
    font-size: 24px; 
    min-width: 70px; 
    text-align: center;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    position: relative;
    font-family: var(--font-family);
  }
  
  /* Gold emoji styling as a badge in top left corner */
  .gold-emoji {
    position: absolute;
    top: -12px;
    left: -12px;
    font-size: 28px;
    opacity: 1;
    z-index: 1;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }
  
  .gold-text {
    position: relative;
    z-index: 2;
    font-size: 28px !important;
    font-weight: 600;
    line-height: 1;
    font-family: var(--font-family);
  }
  
  /* Stage multiplier badge styling centered on lower edge of gold counter */
  .stage-multiplier-badge {
    position: absolute;
    bottom: -16px;
    left: 50%;
    transform: translateX(-50%);
    background: #dc2626;
    color: white;
    font-size: 12px;
    font-weight: 700;
    padding: 4px 6px;
    border-radius: 8px;
    border: 2px solid var(--bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 1;
    font-family: var(--font-family);
    min-width: 20px;
    text-align: center;
    line-height: 1;
    box-sizing: border-box;
    white-space: nowrap;
  }
  
  /* Stage multiplier badge pulse animation */
  .stage-multiplier-badge.pulse {
    animation: stageBadgePulse 0.6s ease-out;
  }
  
  @keyframes stageBadgePulse {
    0% { transform: translateX(-50%) scale(1); }
    50% { transform: translateX(-50%) scale(1.2); }
    100% { transform: translateX(-50%) scale(1); }
  }
  
  /* Score count pulse animation */
  .score-value.pulse {
    animation: scorePulse 0.3s ease-out;
  }
  
  @keyframes scorePulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  
  /* Gold earned animation */
  .gold-earned {
    position: fixed;
    color: #FCD34D;
    font-weight: 700;
    font-size: 20px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
    z-index: 1000;
    pointer-events: none;
    animation: goldEarned 1.2s ease-out forwards;
  }
  
  @keyframes goldEarned {
    0% {
      opacity: 0;
      transform: translateY(0) scale(0.8);
    }
    15% {
      opacity: 1;
      transform: translateY(-15px) scale(1.2);
    }
    70% {
      opacity: 1;
      transform: translateY(-45px) scale(1.1);
    }
    100% {
      opacity: 0;
      transform: translateY(-65px) scale(1);
    }
  }
  
  /* Gold count pulse animation */
  .gold-value.pulse {
    animation: goldPulse 0.3s ease-out;
  }
  
  @keyframes goldPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }

  /* Bomb conversion button pulse animation */
  .bomb-conversion-btn.pulse {
    animation: bombBtnPulse 0.3s ease-out;
  }
  
  @keyframes bombBtnPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  
  /* Trash button pulse animation */
  .trash-btn.pulse {
    animation: trashBtnPulse 0.3s ease-out;
  }
  
  @keyframes trashBtnPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }

  /* AI button styling to match score-value and interface */
  .ai-btn {
    background: var(--panel);
    color: var(--text);
    border: 1px solid #475569;
    padding: 12px 24px;
    border-radius: 9px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(0,0,0,0.25);
    font-family: var(--font-family);
  }
  .ai-btn:hover {
    background: #334155;
    border-color: #64748b;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(0,0,0,0.25);
  }
  .ai-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
  }
  


  .hidden { display:none !important; }

  /* Help modal */
  .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:1000; }
  .modal { background:var(--panel); color:var(--text); width:min(720px, 92vw); border-radius:16px; padding:24px 28px; box-shadow:0 15px 45px rgba(0,0,0,0.4); font-family: var(--font-family); }
  .modal h2 { margin:0 0 12px; font-size:24px; font-family: var(--font-family); }
  .modal p, .modal li { font-size:16px; line-height:1.5; font-family: var(--font-family); }
  .modal ul { margin:12px 0 0 24px; padding:0; }
  .modal .actions { display:flex; justify-content:flex-end; margin-top:18px; }
  
  /* Mobile responsive sizing for help modal stage progression elements */
  @media (max-width: 768px) {
    /* Make target blocks smaller in help modal */
    .help-modal .next-stage-block[style*="width: 120px"] {
      width: 60px !important;
      height: 28px !important;
      font-size: 14px !important;
    }
    
    /* Make gold displays smaller in help modal */
    .help-modal .gold-value[style*="padding: 10px 20px"] {
      padding: 4px 8px !important;
      font-size: 14px !important;
      min-width: 40px !important;
    }
    
    /* Make gold emojis smaller in help modal */
    .help-modal .gold-emoji[style*="font-size: 28px"] {
      font-size: 16px !important;
      top: -6px !important;
      left: -6px !important;
    }
    
    /* Make gold text smaller in help modal */
    .help-modal .gold-text[style*="font-size: 20px"] {
      font-size: 14px !important;
    }
    
    /* Make stage multiplier badges smaller in help modal */
    .help-modal .stage-multiplier-badge[style*="font-size: 12px"] {
      font-size: 8px !important;
      padding: 1px 3px !important;
      bottom: -8px !important;
      min-width: 14px !important;
    }
    
    /* Reduce gaps in help modal stage progression */
    .help-modal .merge-example[style*="gap: 40px"] {
      gap: 16px !important;
    }
    
    .help-modal [style*="gap: 40px"] {
      gap: 16px !important;
    }
    
    /* Make the stage progression examples more compact on mobile */
    .help-modal [style*="max-width: 600px"] {
      max-width: 90vw !important;
    }
  }

  /* Enhanced Help Modal Styles */
  .help-modal { 
    width: min(900px, 95vw); 
    max-height: 90vh; 
    overflow-y: auto; 
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) */
  .help-modal::-webkit-scrollbar {
    display: none;
  }
  
  .help-grid { 
    display: flex; 
    flex-direction: column; 
    gap: 24px; 
    margin: 24px 0; 
  }
  
  .help-section { 
    background: #334155; 
    border-radius: 12px; 
    padding: 20px; 
    border: 1px solid #475569; 
  }
  
  .help-section-header { 
    display: flex; 
    align-items: center; 
    gap: 12px; 
    margin-bottom: 16px; 
  }
  
  .help-icon { 
    font-size: 24px; 
    opacity: 0.9; 
  }
  
  .help-section h3 { 
    margin: 0; 
    font-size: 18px; 
    font-weight: 600; 
    color: #f8fafc; 
  }
  
  .help-content p { 
    margin: 8px 0; 
    font-size: 14px; 
    line-height: 1.4; 
  }
  
  .help-content p:first-child { 
    margin-top: 0; 
  }
  
  .merge-example { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    gap: 20px; 
    margin: 16px 0; 
    padding: 20px; 
    background: #1e293b; 
    border-radius: 8px; 
    flex-wrap: wrap; 
  }
  
  .merge-before, .merge-after { 
    text-align: center; 
  }
  
  .merge-label { 
    display: block; 
    font-size: 12px; 
    color: #94a3b8; 
    margin-bottom: 8px; 
    font-weight: 500; 
  }
  
  .merge-blocks { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 8px; 
  }
  
  .merge-block { 
    width: 108px; 
    height: 42px; 
    border-radius: 9px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    font-weight: 700; 
    font-size: 24px; 
    box-shadow: 0 3px 0 rgba(0,0,0,0.25); 
    font-family: var(--font-family);
  }
  
  .merge-block.block-1 { 
    background: #cfef08; 
    color: #000; 
  }
  
  .merge-block.block-2 { 
    background: #10B981; 
    color: #fff; 
  }
  
  .merge-block.block-4 { 
    background: #2563EB; 
    color: #fff; 
  }
  
  .merge-block.block-8 { 
    background: #7C3AED; 
    color: #fff; 
  }
  
  .merge-block.block-16 { 
    background: #581C87; 
    color: #fff; 
  }
  
  .merge-block.block-32 { 
    background: #D946EF; 
    color: #fff; 
  }
  
  .merge-block.block-64 { 
    background: #EC4899; 
    color: #fff; 
  }
  
  .merge-block.block-128 { 
    background: #e86758; 
    color: #fff; 
  }
  
  .merge-block.block-256 { 
    background: #F59E0B; 
    color: #fff; 
  }
  
  .merge-block.block-512 { 
    background: #ea580c; 
    color: #fff; 
  }
  
  .merge-block.bomb-block {
    width: 108px;
    height: 42px;
    border-radius: 9px;
    background: #000;
    color: white;
    position: relative;
    overflow: hidden;
  }
  
  .merge-block.bomb-block .bomb-content {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  .merge-block.bomb-block .bomb-emoji {
    position: absolute;
    top: -3px;
    left: -21px;
    font-size: 42px;
    opacity: 1;
    z-index: 1;
  }
  
  .merge-block.bomb-block .bomb-text {
    position: relative;
    z-index: 2;
    font-size: 24px;
    font-weight: 700;
    font-family: var(--font-family);
  }
  
  .merge-block.explosion {
    background: #F59E0B;
    color: white;
    font-size: 32px;
    width: 108px;
    height: 42px;
    border-radius: 9px;
  }
  
  .merge-arrow { 
    font-size: 20px; 
    color: #94a3b8; 
    font-weight: 600; 
  }
  
  .help-footer { 
    text-align: center; 
    margin: 24px 0 16px; 
    padding: 16px; 
    background: #334155; 
    border-radius: 8px; 
    border: 1px solid #475569; 
  }
  
  .help-footer p { 
    margin: 0; 
    font-size: 16px; 
    color: #f8fafc; 
  }

  .game-container {
    display: flex;
    align-items: flex-start;
    margin-top: 32px;
    padding-bottom: 28px;
    justify-content: center;
    position: relative;
  }
  
  .game { 
    display: flex; 
    gap: 24px; 
    justify-content: center; 
    flex-wrap: wrap;
    position: relative;
  }
  
  /* Bomb conversion button styling */
  .bomb-conversion-container {
    position: absolute;
    left: calc(100% + 20px);
    top: 0;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .bomb-conversion-btn {
    background: var(--panel);
    color: var(--text);
    border: 2px solid #DC2626;
    width: 60px;
    height: 60px;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(220, 38, 38, 0.25);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--font-family);
    pointer-events: auto;
  }
  
  .bomb-conversion-btn:hover {
    border: 3px solid #0ea5e9;
    background: #334155;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(220, 38, 38, 0.3);
  }
  
  .bomb-conversion-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(220, 38, 38, 0.25);
  }
  
  .bomb-conversion-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 2px 0 rgba(220, 38, 38, 0.2);
  }
  
  .bomb-conversion-btn.affordable {
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1);
  }
  
  .bomb-conversion-btn.affordable:hover {
    border: 3px solid #0ea5e9;
    background: #334155;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(14, 165, 233, 0.3);
  }
  
  /* Undo mode styling - when a bomb is selected and can be undone */
  .bomb-conversion-btn.undo-mode {
    border: 2px solid #10B981;
    background: #065F46;
    box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25);
    animation: undoModePulse 2s ease-in-out infinite;
  }
  
  .bomb-conversion-btn.undo-mode:hover {
    border: 3px solid #34D399;
    background: #047857;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(16, 185, 129, 0.3);
  }
  
  .bomb-conversion-btn.undo-mode .emoji {
    content: "↩️";
  }
  
  @keyframes undoModePulse {
    0%, 100% { 
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25);
    }
    50% { 
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.4);
    }
  }
  
  .bomb-conversion-btn .emoji {
    font-size: 32px;
    line-height: 1;
  }
  
  .bomb-cost-text {
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: var(--font-family);
  }
  
  .bomb-cost-text .emoji {
    font-size: 24px;
  }
  
  .bomb-cost-text .cost {
    color: #FCD34D;
    font-weight: 700;
    font-size: 20px;
  }
  
  /* Trash button styling */
  .trash-button-container {
    position: absolute;
    left: calc(100% + 20px);
    top: 80px;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .trash-btn {
    background: var(--panel);
    color: var(--text);
    border: 2px solid #DC2626;
    width: 60px;
    height: 60px;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 0 rgba(220, 38, 38, 0.25);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--font-family);
    pointer-events: auto;
  }
  
  .trash-btn:hover {
    border: 3px solid #0ea5e9;
    background: #334155;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(107, 114, 128, 0.3);
  }
  
  .trash-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(107, 114, 128, 0.25);
  }
  
  .trash-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 2px 0 rgba(220, 38, 38, 0.2);
  }
  
  .trash-btn.affordable {
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1);
  }
  
  .trash-btn.affordable:hover {
    border: 3px solid #0ea5e9;
    background: #334155;
    transform: translateY(-1px);
    box-shadow: 0 4px 0 rgba(14, 165, 233, 0.3);
  }
  
  .trash-btn .emoji {
    font-size: 32px;
    line-height: 1;
  }
  
  .trash-cost-text {
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: var(--font-family);
  }
  
  .trash-cost-text .emoji {
    font-size: 24px;
  }
  
  .trash-cost-text .cost {
    color: #FCD34D;
    font-weight: 700;
    font-size: 20px;
  }
  
  .bottom-actions { 
    display: flex; 
    justify-content: center; 
    align-items: center;
    gap: 18px;
    margin-top: 18px; 
  }
  
  /* Next stage display styling */
  .next-stage-container {
    position: absolute;
    right: calc(100% + 20px);
    top: 0;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .next-stage-display { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 12px; 
  }
  .next-stage-label { 
    font-size: 18px; 
    opacity: 0.9; 
    font-family: var(--font-family);
  }
  .next-stage-indicator { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
  }
  .next-stage-block { 
    width: 108px; 
    height: 45px; 
    border-radius: 9px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    font-weight: 600; 
    font-size: 24px; 
    background: #6b7280; /* Default neutral gray */
    color: white; 
    box-shadow: 0 3px 0 rgba(0,0,0,0.25); 
    font-family: var(--font-family);
  }
  
  /* Target block colors for different values - using the same color scheme as blocks */
  .next-stage-block[data-value="1"] { background: #cfef08; color: #000; }
  .next-stage-block[data-value="2"] { background: #10B981; color: #fff; }
  .next-stage-block[data-value="4"] { background: #2563EB; color: #fff; }
  .next-stage-block[data-value="8"] { background: #7C3AED; color: #fff; }
  .next-stage-block[data-value="16"] { background: #581C87; color: #fff; }
  .next-stage-block[data-value="32"] { background: #D946EF; color: #fff; }
  .next-stage-block[data-value="64"] { background: #EC4899; color: #fff; }
  .next-stage-block[data-value="128"] { background: #e86758; color: #fff; }
  .next-stage-block[data-value="256"] { background: #F59E0B; color: #fff; }
  .next-stage-block[data-value="512"] { background: #ea580c; color: #fff; }
  .next-stage-block[data-value="1024"] { background: #dc2626; color: #fff; }
  .next-stage-block[data-value="2048"] { background: #9d174d; color: #fff; }
  .next-stage-block[data-value="4096"] { background: #000; color: #fff; }
  .next-stage-block[data-value="8192"] { background: #64748b; color: #fff; }
  .next-stage-block[data-value="16384"] { background: #fff; color: #000; }
  /* For values above 16384, use white background with black text (same as game blocks) */
  .next-stage-block[data-value^="32768"],
  .next-stage-block[data-value^="65536"],
  .next-stage-block[data-value^="131072"],
  .next-stage-block[data-value^="262144"],
  .next-stage-block[data-value^="524288"],
  .next-stage-block[data-value^="1048576"],
  .next-stage-block[data-value^="2097152"],
  .next-stage-block[data-value^="4194304"],
  .next-stage-block[data-value^="8388608"],
  .next-stage-block[data-value^="16777216"],
  .next-stage-block[data-value^="33554432"],
  .next-stage-block[data-value^="67108864"],
  .next-stage-block[data-value^="134217728"],
  .next-stage-block[data-value^="268435456"],
  .next-stage-block[data-value^="536870912"],
  .next-stage-block[data-value^="1073741824"],
  .next-stage-block[data-value^="2147483648"],
  .next-stage-block[data-value^="4294967296"],
  .next-stage-block[data-value^="8589934592"],
  .next-stage-block[data-value^="17179869184"],
  .next-stage-block[data-value^="34359738368"],
  .next-stage-block[data-value^="68719476736"],
  .next-stage-block[data-value^="137438953472"],
  .next-stage-block[data-value^="274877906944"],
  .next-stage-block[data-value^="549755813888"],
  .next-stage-block[data-value^="1099511627776"],
  .next-stage-block[data-value^="2199023255552"],
  .next-stage-block[data-value^="4398046511104"],
  .next-stage-block[data-value^="8796093022208"],
  .next-stage-block[data-value^="17592186044416"],
  .next-stage-block[data-value^="35184372088832"],
  .next-stage-block[data-value^="70368744177664"],
  .next-stage-block[data-value^="140737488355328"],
  .next-stage-block[data-value^="281474976710656"],
  .next-stage-block[data-value^="562949953421312"],
  .next-stage-block[data-value^="1125899906842624"],
  .next-stage-block[data-value^="2251799813685248"],
  .next-stage-block[data-value^="4503599627370496"],
  .next-stage-block[data-value^="9007199254740992"],
  .next-stage-block[data-value^="18014398509481984"],
  .next-stage-block[data-value^="36028797018963968"],
  .next-stage-block[data-value^="72057594037927936"],
  .next-stage-block[data-value^="144115188075855872"],
  .next-stage-block[data-value^="288230376151711744"],
  .next-stage-block[data-value^="576460752303423488"],
  .next-stage-block[data-value^="1152921504606846976"],
  .next-stage-block[data-value^="2305843009213693952"],
  .next-stage-block[data-value^="4611686018427387904"],
  .next-stage-block[data-value^="9223372036854775808"] {
    background: #fff;
    color: #000;
  }
  
  /* Next block display styling in debug panel */
  .next-block-display {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 6px;
    font-weight: 600;
    font-size: 14px;
    min-width: 40px;
    text-align: center;
    background: #6b7280; /* Default gray for "Queue" */
    color: white;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    border: 1px solid rgba(0,0,0,0.1);
  }
  
  /* Apply block colors based on data attributes */
  .next-block-display[data-value="1"] { background: #cfef08; color: #000; }
  .next-block-display[data-value="2"] { background: #10B981; color: #fff; }
  .next-block-display[data-value="4"] { background: #2563EB; color: #fff; }
  .next-block-display[data-value="8"] { background: #7C3AED; color: #fff; }
  .next-block-display[data-value="16"] { background: #581C87; color: #fff; }
  .next-block-display[data-value="32"] { background: #D946EF; color: #fff; }
  .next-block-display[data-value="64"] { background: #EC4899; color: #fff; }
  .next-block-display[data-value="128"] { background: #e86758; color: #fff; }
  .next-block-display[data-value="256"] { background: #F59E0B; color: #fff; }
  .next-block-display[data-value="512"] { background: #ea580c; color: #fff; }
  .next-block-display[data-value="1024"] { background: #dc2626; color: #fff; }
  .next-block-display[data-value="2048"] { background: #9d174d; color: #fff; }
  .next-block-display[data-value="4096"] { background: #000; color: #fff; }
  .next-block-display[data-value="8192"] { background: #64748b; color: #fff; }
  .next-block-display[data-value="16384"] { background: #fff; color: #000; }
  /* For values above 16384, use white background with black text (same as game blocks) */
  .next-block-display[data-value^="32768"],
  .next-block-display[data-value^="65536"],
  .next-block-display[data-value^="131072"],
  .next-block-display[data-value^="262144"],
  .next-block-display[data-value^="524288"],
  .next-block-display[data-value^="1048576"],
  .next-block-display[data-value^="2097152"],
  .next-block-display[data-value^="4194304"],
  .next-block-display[data-value^="8388608"],
  .next-block-display[data-value^="16777216"],
  .next-block-display[data-value^="33554432"],
  .next-block-display[data-value^="67108864"],
  .next-block-display[data-value^="134217728"],
  .next-block-display[data-value^="268435456"],
  .next-block-display[data-value^="536870912"],
  .next-block-display[data-value^="1073741824"],
  .next-block-display[data-value^="2147483648"],
  .next-block-display[data-value^="4294967296"],
  .next-block-display[data-value^="8589934592"],
  .next-block-display[data-value^="17179869184"],
  .next-block-display[data-value^="34359738368"],
  .next-block-display[data-value^="68719476736"],
  .next-block-display[data-value^="137438953472"],
  .next-block-display[data-value^="274877906944"],
  .next-block-display[data-value^="549755813888"],
  .next-block-display[data-value^="1099511627776"],
  .next-block-display[data-value^="2199023255552"],
  .next-block-display[data-value^="4398046511104"],
  .next-block-display[data-value^="8796093022208"],
  .next-block-display[data-value^="17592186044416"],
  .next-block-display[data-value^="35184372088832"],
  .next-block-display[data-value^="70368744177664"],
  .next-block-display[data-value^="140737488355328"],
  .next-block-display[data-value^="281474976710656"],
  .next-block-display[data-value^="562949953421312"],
  .next-block-display[data-value^="1125899906842624"],
  .next-block-display[data-value^="2251799813685248"],
  .next-block-display[data-value^="4503599627370496"],
  .next-block-display[data-value^="9007199254740992"],
  .next-block-display[data-value^="18014398509481984"],
  .next-block-display[data-value^="36028797018963968"],
  .next-block-display[data-value^="72057594037927936"],
  .next-block-display[data-value^="144115188075855872"],
  .next-block-display[data-value^="288230376151711744"],
  .next-block-display[data-value^="576460752303423488"],
  .next-block-display[data-value^="1152921504606846976"],
  .next-block-display[data-value^="2305843009213693952"],
  .next-block-display[data-value^="4611686018427387904"],
  .next-block-display[data-value^="9223372036854775808"] {
    background: #fff;
    color: #000;
  }
  .pole { position:relative; width:140px; height:var(--stack-height, 525px); background:var(--panel); border-radius:15px; display:flex; flex-direction:column-reverse; align-items:center; padding:16px; box-sizing:border-box; cursor:pointer; transition: all 0.2s ease; z-index: 0; }
  .pole:hover { border: 3px solid #0ea5e9; }
  .pole.full { opacity:0.6; cursor: not-allowed; }
  .pole.full:hover { opacity: 0.6; border: none; }
  .pole.no-hover:hover { border: none !important; opacity: 1 !important; }
  .pole.no-hover { pointer-events: none; }
  /* Touch device optimizations */
  @media (hover: none) and (pointer: coarse) {
    /* On touch devices, completely disable hover effects since they're not useful */
    .pole:hover {
      border: none !important;
      opacity: 1 !important;
    }
    
    /* Reduce transition duration on touch devices for snappier feedback */
    .pole {
      transition: all 0.1s ease;
    }
  }
  .disc { width:108px; height:42px; border-radius:9px; display:flex; align-items:center; justify-content:center; color:white; font-weight:700; font-size:24px; margin-top:9px; box-shadow:0 3px 0 rgba(0,0,0,0.25); font-family: var(--font-family); transform-origin: center center; position: relative; z-index: 1; }
  
  /* Bomb block styling */
  .bomb-content {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  .bomb-emoji {
    position: absolute;
    top: -3px;
    left: -21px;
    font-size: 42px;
    opacity: 1;
    z-index: 1;
  }
  
  .bomb-text {
    position: relative;
    z-index: 2;
    font-size: 24px;
    font-weight: 700;
    font-family: var(--font-family);
  }
  
  /* remove extra gap at the very top of a full pole (topmost disc has no margin) */
  .pole .disc:last-child { margin-top: 0; }

  .disc.animate { 
    animation: drop calc(0.15s * var(--animation-speed, 1)) ease-out;
  }
  @keyframes drop {
    from { transform: translateY(-60px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.animate[style*="--animation-speed: 0"] { animation: none; transform: translateY(0); opacity: 1; }

  /* Enhanced merge animations */
  .disc.merge-out { 
    animation: mergeOut calc(0.15s * var(--animation-speed, 1)) cubic-bezier(0.4, 0, 0.2, 1) forwards;
    filter: brightness(1.1) saturate(1.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.merge-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.7); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes mergeOut {
    0% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
    }
    25% { 
      transform: scale(1.1); 
      opacity: 1; 
      filter: brightness(1.2) saturate(1.3);
    }
    50% { 
      transform: scale(1.15); 
      opacity: 0.9; 
      filter: brightness(1.3) saturate(1.4);
    }
    75% { 
      transform: scale(1.05); 
      opacity: 0.6; 
      filter: brightness(1.1) saturate(1.2);
    }
    100% { 
      transform: scale(0.7); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
    }
  }

  /* Bomb shockwave ripple effect */
  .disc.bomb-ripple {
    animation: bombRipple calc(0.5s * var(--animation-speed, 1)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    filter: brightness(1.3) saturate(1.4);
    box-shadow: 0 0 15px rgba(220, 38, 38, 0.4), 0 0 30px rgba(220, 38, 38, 0.2);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.bomb-ripple[style*="--animation-speed: 0"] { animation: none; transform: scale(0.8) translateY(0); opacity: 0; filter: brightness(0.8) saturate(0.9); }
  @keyframes bombRipple {
    0% { 
      transform: scale(1) translateY(0); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
    15% { 
      transform: scale(1.3) translateY(-8px); 
      opacity: 1; 
      filter: brightness(1.6) saturate(1.8);
      box-shadow: 0 0 20px rgba(220, 38, 38, 0.6), 0 0 40px rgba(220, 38, 38, 0.3);
    }
    35% { 
      transform: scale(1.15) translateY(-4px); 
      opacity: 0.95; 
      filter: brightness(1.4) saturate(1.6);
      box-shadow: 0 0 15px rgba(220, 38, 38, 0.5), 0 0 30px rgba(220, 38, 38, 0.25);
    }
    55% { 
      transform: scale(0.95) translateY(2px); 
      opacity: 0.8; 
      filter: brightness(1.2) saturate(1.4);
      box-shadow: 0 0 10px rgba(220, 38, 38, 0.4), 0 0 20px rgba(220, 38, 38, 0.2);
    }
    75% { 
      transform: scale(0.85) translateY(4px); 
      opacity: 0.5; 
      filter: brightness(1.1) saturate(1.2);
      box-shadow: 0 0 8px rgba(220, 38, 38, 0.3), 0 0 15px rgba(220, 38, 38, 0.15);
    }
    100% { 
      transform: scale(0.8) translateY(0); 
      opacity: 0; 
      filter: brightness(0.8) saturate(0.9);
      box-shadow: 0 0 0px rgba(220, 38, 38, 0);
    }
  }

  .disc.merge-in { 
    animation: mergeIn calc(0.2s * var(--animation-speed, 1)) cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    filter: brightness(1.05) saturate(1.1);
    z-index: 10;
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.merge-in[style*="--animation-speed: 0"] { animation: none; transform: scale(1); opacity: 1; filter: brightness(1) saturate(1); }
  @keyframes mergeIn {
    0% { 
      transform: scale(0.6); 
      opacity: 0; 
      filter: brightness(0.7) saturate(0.8);
    }
    30% { 
      transform: scale(0.85); 
      opacity: 0.7; 
      filter: brightness(0.9) saturate(1);
    }
    60% { 
      transform: scale(1.05); 
      opacity: 0.9; 
      filter: brightness(1.05) saturate(1.1);
    }
    80% { 
      transform: scale(0.98); 
      opacity: 1; 
      filter: brightness(1.02) saturate(1.05);
    }
    100% { 
      transform: scale(1); 
      opacity: 1; 
      filter: brightness(1) saturate(1);
    }
  }

  /* Merge glow effect for visual appeal */
  .disc.merging {
    box-shadow: 0 0 15px rgba(14, 165, 233, 0.4), 0 0 25px rgba(14, 165, 233, 0.2);
    transition: box-shadow 0.1s ease;
    z-index: 5;
  }
  
  /* Enhanced disc transitions for smoother animations */
  .disc {
    transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform, opacity, filter;
  }
  


  /* special clear animation for high-value blocks */
  .disc.clear-out { animation: clearOut calc(0.26s * var(--animation-speed, 1)) ease forwards; }
  @keyframes clearOut {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0.85); opacity: 0; }
  }
  
  /* Instant animations when speed is 0 (Blazing) */
  .disc.clear-out[style*="--animation-speed: 0"] { animation: none; transform: scale(0.85); opacity: 0; }

  /* removed falling/fade styles for simplified clear */



  .controls { margin-top:8px; font-size:13px; color:#ccc; }

  /* Debug pane styling */
  .debug-pane { 
    position: fixed; 
    top: 0; 
    right: 0; 
    height: 100vh; 
    background: var(--panel); 
    color: var(--text); 
    border-left: 3px solid #475569; 
    padding: 20px; 
    z-index: 1002; 
    width: 320px;
    box-shadow: -5px 0 25px rgba(0,0,0,0.4);
    font-family: var(--font-family);
    overflow-y: auto;
    overflow-x: hidden;
    box-sizing: border-box;
    transform: translateX(100%);
    transition: transform 0.3s ease-out;
    display: flex;
    flex-direction: column;
  }
  
  .debug-pane.show {
    transform: translateX(0);
  }
  
  /* Debug pane backdrop overlay */
  .debug-pane::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.3);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease-out;
    z-index: -1;
  }
  
  .debug-pane.show::before {
    opacity: 1;
  }
  

  .debug-pane h3 { margin: 0 0 16px; font-size: 20px; text-align: center; font-family: var(--font-family); }
  .debug-pane .section { margin-bottom: 18px; }
  
  .debug-pane .section:not(.bottom-buttons) {
    flex: 1;
  }
  .debug-pane .section-title { font-weight: 600; margin-bottom: 8px; font-size: 15px; font-family: var(--font-family); }
  .debug-pane .controls { display: flex; flex-direction: column; gap: 12px; }
  .debug-pane .control-row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
  .debug-pane .control-row label { font-size: 14px; min-width: 70px; font-family: var(--font-family); flex-shrink: 0; }
  .debug-pane .control-row input[type="range"] { flex: 1; min-width: 0; accent-color: #0ea5e9; }
  .debug-pane .control-row .value-display { 
    background: var(--bg); 
    padding: 6px 12px; 
    border-radius: 6px; 
    font-size: 13px; 
    min-width: 45px; 
    text-align: center; 
    font-family: var(--font-family);
    flex-shrink: 0;
  }
  .debug-pane .button { 
    background: #334155; 
    color: var(--text); 
    border: 1px solid #475569; 
    padding: 10px 16px; 
    border-radius: 6px; 
    cursor: pointer; 
    font-weight: 600; 
    font-size: 14px;
    transition: background 0.2s;
    font-family: var(--font-family);
    box-sizing: border-box;
  }
  
  .debug-pane .button-row {
    display: flex;
    gap: 8px;
  }
  
  .debug-pane .button-row .button {
    flex: 1;
    min-width: 0;
  }
  
  .debug-pane .bottom-buttons {
    margin-top: auto;
    padding-top: 16px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
  }
  
  /* Block grid styling */
  .block-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
    margin: 12px 0;
  }
  
  .block-item {
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 0 rgba(0,0,0,0.25);
    user-select: none;
  }
  
  .block-item:hover {
    transform: scale(1.05);
    box-shadow: 0 3px 0 rgba(0,0,0,0.3);
  }
  
  .block-item.selected {
    outline: 3px solid #fff;
    outline-offset: 2px;
    transform: scale(1.1);
    box-shadow: 0 4px 0 rgba(0,0,0,0.4);
  }
  
  .block-item[data-value="1"] { background: #cfef08; color: #000; }
  .block-item[data-value="2"] { background: #10B981; color: #fff; }
  .block-item[data-value="4"] { background: #2563EB; color: #fff; }
  .block-item[data-value="8"] { background: #7C3AED; color: #fff; }
  .block-item[data-value="16"] { background: #581C87; color: #fff; }
  .block-item[data-value="32"] { background: #D946EF; color: #fff; }
  .block-item[data-value="64"] { background: #EC4899; color: #fff; }
  .block-item[data-value="128"] { background: #e86758; color: #fff; }
  .block-item[data-value="256"] { background: #F59E0B; color: #fff; }
  .block-item[data-value="512"] { background: #ea580c; color: #fff; }
  .block-item[data-value="1024"] { background: #dc2626; color: #fff; }
  .block-item[data-value="2048"] { background: #9d174d; color: #fff; }
  .block-item[data-value="4096"] { background: #000; color: #fff; }
  .block-item[data-value="8192"] { background: #64748b; color: #fff; }
  .block-item[data-value="16384"] { background: #fff; color: #000; }
  
  /* Dynamic gold glow effect for white blocks (16384+) in the game */
  .disc.white-block-glow {
    --glow-intensity: 1;
    --glow-spread: 8px;
    --glow-opacity: 0.6;
    --border-width: 2px;
    --border-opacity: 0.8;
    --inset-opacity: 0.1;
    
    box-shadow: 
      0 0 calc(var(--glow-spread) * 1) rgba(245, 215, 110, var(--glow-opacity)),
      0 0 calc(var(--glow-spread) * 2) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.67)),
      0 0 calc(var(--glow-spread) * 3) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.33)),
      0 0 calc(var(--glow-spread) * 4) rgba(245, 215, 110, calc(var(--glow-opacity) * 0.17)),
      inset 0 0 calc(var(--glow-spread) * 1) rgba(245, 215, 110, var(--inset-opacity));
    border: var(--border-width) solid rgba(245, 215, 110, var(--border-opacity));
  }
  
  .block-item.no-block {
    background: #64748b;
    color: #fff;
    border: 2px solid #94a3b8;
    font-weight: 600;
  }
  
  .block-item.no-block:hover {
    background: #475569;
    border-color: #cbd5e1;
  }
  
  .block-item.no-block.selected {
    background: #475569;
    border-color: #e2e8f0;
    outline: 3px solid #e2e8f0;
  }
  
  .selected-block-info {
    text-align: center;
    font-size: 13px;
    color: rgba(255, 255, 255, 0.9);
    margin-top: 8px;
    padding: 8px;
    background: var(--bg);
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }
  .debug-pane .button:hover { background: #475569; }
  .debug-pane .button:active { background: #334155; }
  .debug-pane .button.primary { background: #0ea5e9; border-color: #0284c7; }
  .debug-pane .button.primary:hover { background: #0284c7; }
  .debug-pane .button.active { background: #0ea5e9; border-color: #0284c7; }
  .debug-pane .close-btn { 
    position: absolute; 
    top: 8px; 
    right: 12px; 
    background: none; 
    border: none; 
    color: #94a3b8; 
    font-size: 20px; 
    cursor: pointer; 
    padding: 6px; 
    border-radius: 6px;
    font-family: var(--font-family);
  }
  .debug-pane .close-btn:hover { background: #475569; color: var(--text); }
  .debug-pane .status { 
    background: var(--bg); 
    padding: 8px; 
    border-radius: 6px; 
    font-size: 13px; 
    text-align: center;
    border: 1px solid #475569;
    font-family: var(--font-family);
  }
  .debug-pane .status.active { border-color: #10B981; background: rgba(16, 185, 129, 0.1); }
  .debug-pane .status.inactive { border-color: #6B7280; background: rgba(107, 114, 128, 0.1); }
  
  /* Hide debug button by default - will be shown via JavaScript */
  #debugBtn {
    display: none;
  }

  /* Game Over Button Overlay */
  .game-over-button-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: rgba(30, 41, 59, 0.95); /* Semi-transparent panel background */
    backdrop-filter: blur(8px); /* Add subtle blur effect */
    border: 2px solid rgba(255, 255, 255, 0.8); /* Semi-transparent white border */
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1); /* Smooth easing curve for fade-in */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    min-width: 200px;
  }

  .game-over-button-overlay.hiding {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* Fast transition for fade-out */
  }

  .game-over-button-overlay.show {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
  }

  .game-over-text {
    font-size: 24px;
    font-weight: 700;
    color: #ef4444;
    font-family: var(--font-family);
    text-align: center;
    margin: 0;
  }

  .new-game-btn {
    background: #10B981;
    color: white;
    border: none;
    padding: 16px 32px;
    border-radius: 12px;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .new-game-btn:hover {
    background: #059669;
    transform: translateY(-2px);
    box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
  }

  .new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }



  /* New Game Modal Styling */
  .new-game-modal {
    max-width: 300px;
    text-align: center;
  }

  .new-game-modal h2 {
    margin-bottom: 24px;
    color: var(--text);
  }

  .new-game-buttons {
    display: flex;
    gap: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .confirm-new-game-btn {
    background: #10B981;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .confirm-new-game-btn:hover {
    background: #059669;
    transform: translateY(-2px);
    box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
  }

  .confirm-new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

  .cancel-new-game-btn {
    background: #DC2626;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: var(--font-family);
    box-shadow: 0 3px 0 rgba(0, 0, 0, 0.2);
    white-space: nowrap;
  }

  .cancel-new-game-btn:hover {
    background: #b91c1c;
    transform: translateY(-2px);
    box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
  }

  .cancel-new-game-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
  }

/* Debug stats table styling */
.debug-stats-table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 8px;
  font-size: 12px;
  table-layout: fixed;
}

.debug-stats-table td {
  padding: 2px 4px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.debug-stats-table td:first-child {
  font-weight: 500;
  color: rgba(255, 255, 255, 0.7);
  width: 45%;
}

.debug-stats-table td:last-child {
  text-align: right;
  font-weight: 600;
  color: var(--text);
  width: 55%;
}

/* Mobile Responsive Design */
@media (max-width: 768px) {
  /* Adjust topbar for mobile */
  .topbar {
    padding: 16px 12px 8px;
    gap: 16px;
  }
  
  h1 {
    font-size: 28px;
  }
  
  /* Adjust game info layout for mobile */
  .game-info {
    flex-direction: row;
    justify-content: center;
    gap: 32px;
    margin-top: 20px;
    flex-wrap: wrap;
  }
  
  .score-display, .gold-display {
    gap: 8px;
  }
  
  /* Adjust stage multiplier badge for mobile */
  .stage-multiplier-badge {
    font-size: 10px;
    padding: 3px 5px;
    min-width: 18px;
    bottom: -14px;
    left: 50%;
    transform: translateX(-50%);
  }
  
  .next {
    order: 2;
    width: 100%;
    margin-top: 16px;
  }
  
  .score-label, .next .label, .gold-label {
    font-size: 16px;
  }
  
  .score-value, .gold-value {
    font-size: 20px;
    padding: 8px 16px;
    min-width: 60px;
  }
  
  .next-disc {
    width: 80px;
    height: 35px;
    font-size: 18px;
  }
  
  /* Adjust bomb blocks in next queue for mobile */
  .next-disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .next-disc .bomb-text {
    font-size: 18px;
  }
  
  /* Fix next blocks animation for mobile */
  .next-disc.shift-left {
    transform: translateX(-96px); /* Adjusted for mobile next-disc width + gap */
  }
  
  .next-disc.consume-out {
    animation-duration: calc(0.15s * var(--animation-speed, 1)); /* Slightly faster on mobile */
  }
  
  /* Fix drop animation for mobile - override default with higher specificity */
  .game .pole .disc.animate {
    animation: dropMobile calc(0.15s * var(--animation-speed, 1)) ease-out !important;
  }
  
  @keyframes dropMobile {
    from { transform: translateY(-50px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  /* Adjust game container for mobile */
  .game-container {
    margin-top: 20px;
    padding-bottom: 20px;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    display: flex;
  }
  
  .game {
    order: 1;
  }
  
  /* Position next stage and bomb conversion for mobile */
  .next-stage-container {
    display: none; /* Hide next stage display on mobile */
  }
  
  /* Create a mobile button row for bomb and trash buttons */
  .mobile-button-row {
    display: none;
    order: 4;
    margin-top: 16px;
    margin-bottom: 0;
    width: 100%;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
    padding: 0 20px;
    box-sizing: border-box;
    background: transparent;
    border: none;
  }
  
  .bomb-conversion-container {
    position: static;
    order: 4;
    margin-top: 16px;
    margin-bottom: 0;
  }
  
  /* Position trash button for mobile */
  .trash-button-container {
    position: static;
    order: 5;
    margin-top: 16px;
    margin-bottom: 0;
  }
  
  /* Show mobile button row and hide individual containers on mobile */
  .mobile-button-row {
    display: flex;
  }
  
  .bomb-conversion-container,
  .trash-button-container {
    display: none;
  }
  
  /* Consistent button sizing for mobile */
  .bomb-conversion-btn, .trash-btn {
    width: 55px;
    height: 55px;
  }
  
  .bomb-conversion-btn .emoji, .trash-btn .emoji {
    font-size: 28px;
  }
  
  /* Adjust game grid for mobile */
  .game {
    gap: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  /* Make poles smaller for mobile */
  .pole {
    width: 100px;
    /* Height will be set by JavaScript via --stack-height variable */
    padding: 12px;
  }
  
  /* Adjust discs for smaller poles */
  .disc {
    width: 76px;
    height: 30px;
    font-size: 18px;
    margin-top: 6px;
  }
  
  /* Adjust bomb blocks for mobile to match disc sizing */
  .disc .bomb-emoji {
    font-size: 30px;
    top: -2px;
    left: -15px;
  }
  
  .disc .bomb-text {
    font-size: 18px;
  }
  
  /* Adjust bomb conversion button for mobile */
  .bomb-conversion-btn {
    width: 50px;
    height: 50px;
  }
  
  .bomb-conversion-btn .emoji {
    font-size: 24px;
  }
  
  .bomb-cost-text .emoji {
    font-size: 20px;
  }
  
  .bomb-cost-text .cost {
    font-size: 16px;
  }
  
  .trash-cost-text .emoji {
    font-size: 20px;
  }
  
  .trash-cost-text .cost {
    font-size: 16px;
  }
  
  /* Mobile button row styling */
  .mobile-button-row .mobile-bomb-container,
  .mobile-button-row .mobile-trash-container {
    display: flex;
    position: static;
    margin: 0;
    flex: 1;
    justify-content: center;
    align-items: center;
    gap: 12px;
  }
  
  .mobile-button-row .bomb-conversion-btn,
  .mobile-button-row .trash-btn {
    width: 55px;
    height: 55px;
    flex-shrink: 0;
  }
  
  .mobile-button-row .bomb-conversion-btn .emoji,
  .mobile-button-row .trash-btn .emoji {
    font-size: 28px;
  }
  
  .mobile-button-row .bomb-cost-text .emoji,
  .mobile-button-row .trash-cost-text .emoji {
    font-size: 20px;
  }
  
  .mobile-button-row .bomb-cost-text .cost,
  .mobile-button-row .trash-cost-text .cost {
    font-size: 16px;
  }
  
  /* Ensure mobile containers don't shrink */
  .mobile-button-row .mobile-bomb-container,
  .mobile-button-row .mobile-trash-container {
    flex-shrink: 0;
    min-width: 0;
  }
  
  /* Mobile button hover and active states - disabled on mobile */
  .mobile-button-row .bomb-conversion-btn:hover,
  .mobile-button-row .trash-btn:hover {
    /* Disable hover effects on mobile - no transform, border, background, or shadow changes */
    transform: none;
    border: 2px solid #DC2626; /* Keep original border */
    background: var(--panel); /* Keep original background */
    box-shadow: 0 3px 0 rgba(220, 38, 38, 0.25); /* Keep original shadow */
  }
  
  .mobile-button-row .bomb-conversion-btn.affordable:hover {
    /* Disable hover effects for affordable state on mobile */
    transform: none;
    border: 2px solid rgba(255, 255, 255, 0.3); /* Keep affordable border */
    background: var(--panel); /* Keep original background */
    box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1); /* Keep affordable shadow */
  }
  
  /* Mobile undo mode styling - when a bomb is selected and can be undone */
  .mobile-button-row .bomb-conversion-btn.undo-mode {
    border: 2px solid #10B981;
    background: #065F46;
    box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25);
    animation: undoModePulse 2s ease-in-out infinite;
  }
  
  .mobile-button-row .bomb-conversion-btn.undo-mode:hover {
    /* Disable hover effects for undo mode on mobile */
    transform: none;
    border: 2px solid #10B981; /* Keep undo border */
    background: #065F46; /* Keep undo background */
    box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25); /* Keep undo shadow */
  }
  
  .mobile-button-row .trash-btn.affordable:hover {
    /* Disable hover effects for affordable state on mobile */
    transform: none;
    border: 2px solid rgba(255, 255, 255, 0.3); /* Keep affordable border */
    background: var(--panel); /* Keep original background */
    box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1); /* Keep affordable shadow */
  }
  
  .mobile-button-row .bomb-conversion-btn:active,
  .mobile-button-row .trash-btn:active {
    transform: translateY(0);
  }
  
  /* Disable hover effects on mobile devices for bomb and trash buttons */
  @media (max-width: 768px) {
    /* Disable hover effects for all bomb and trash buttons on mobile */
    .bomb-conversion-btn:hover,
    .trash-btn:hover {
      /* Disable hover effects on mobile - no transform, border, background, or shadow changes */
      transform: none !important;
      border: 2px solid #DC2626 !important; /* Keep original border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(220, 38, 38, 0.25) !important; /* Keep original shadow */
    }
    
    .bomb-conversion-btn.affordable:hover {
      /* Disable hover effects for affordable state on mobile */
      transform: none !important;
      border: 2px solid rgba(255, 255, 255, 0.3) !important; /* Keep affordable border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1) !important; /* Keep affordable shadow */
    }
    
    .bomb-conversion-btn.undo-mode:hover {
      /* Disable hover effects for undo mode on mobile */
      transform: none !important;
      border: 2px solid #10B981 !important; /* Keep undo border */
      background: #065F46 !important; /* Keep undo background */
      box-shadow: 0 3px 0 rgba(16, 185, 129, 0.25) !important; /* Keep undo shadow */
    }
    
    .trash-btn.affordable:hover {
      /* Disable hover effects for affordable state on mobile */
      transform: none !important;
      border: 2px solid rgba(255, 255, 255, 0.3) !important; /* Keep affordable border */
      background: var(--panel) !important; /* Keep original background */
      box-shadow: 0 3px 0 rgba(255, 255, 255, 0.1) !important; /* Keep affordable shadow */
    }
  }
  
  /* Responsive adjustments for very small mobile screens */
  @media (max-width: 480px) {
    .mobile-button-row {
      gap: 16px;
      padding: 0 16px;
    }
    
    .mobile-button-row .bomb-conversion-btn,
    .mobile-button-row .trash-btn {
      width: 50px;
      height: 50px;
    }
    
    .mobile-button-row .bomb-conversion-btn .emoji,
    .mobile-button-row .trash-btn .emoji {
      font-size: 24px;
    }
    
    /* Further adjust bomb blocks for very small mobile */
    .disc .bomb-emoji {
      font-size: 26px;
      top: -1px;
      left: -13px;
    }
    
    .disc .bomb-text {
      font-size: 16px;
    }
  }
  
  /* Pulse animation for mobile buttons */
  .mobile-button-row .bomb-conversion-btn.pulse,
  .mobile-button-row .trash-btn.pulse {
    animation: buttonPulse 0.3s ease;
  }
  
  /* Desktop overrides - hide mobile buttons and show desktop buttons */
  @media (min-width: 769px) {
    .game-container .mobile-button-row {
      display: none !important;
    }
    
    .game-container .bomb-conversion-container,
    .game-container .trash-button-container {
      display: flex !important;
      position: absolute !important;
      left: calc(100% + 20px) !important;
      align-items: center !important;
      gap: 12px !important;
    }
    
    .game-container .bomb-conversion-container {
      top: 0 !important;
    }
    
    .game-container .trash-button-container {
      top: 80px !important;
    }
    
    /* Ensure desktop buttons have proper sizing */
    .game-container .bomb-conversion-btn,
    .game-container .trash-btn {
      width: 60px !important;
      height: 60px !important;
    }
    
    .game-container .bomb-conversion-btn .emoji,
    .game-container .trash-btn .emoji {
      font-size: 32px !important;
    }
    
    .game-container .bomb-cost-text .emoji,
    .game-container .trash-cost-text .emoji {
      font-size: 24px !important;
    }
    
    .game-container .bomb-cost-text .cost,
    .game-container .trash-cost-text .cost {
      font-size: 20px !important;
    }
  }
  
  /* Adjust bottom actions for mobile */
  .bottom-actions {
    margin-top: 16px;
    gap: 12px;
    order: 5;
  }
  
  .ai-btn {
    padding: 10px 20px;
    font-size: 14px;
  }
  
  /* Adjust help modal for mobile */
  .help-modal {
    width: 95vw;
    padding: 20px;
    /* Hide scrollbar while maintaining scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
  }
  
  /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) on mobile */
  .help-modal::-webkit-scrollbar {
    display: none;
  }
  
  .help-grid {
    gap: 16px;
  }
  
  /* Adjust debug pane for mobile */
  .debug-pane {
    width: 95vw;
    right: 0;
  }
}

/* Extra small mobile devices */
@media (max-width: 480px) {
  .topbar {
    padding: 12px 8px 6px;
  }
  
  h1 {
    font-size: 24px;
  }
  
  .game-info {
    gap: 16px;
    margin-top: 16px;
    flex-direction: row;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  .next {
    order: 2;
    width: 100%;
    margin-top: 12px;
  }
  
  .pole {
    width: 80px;
    /* Height will be set by JavaScript via --stack-height variable */
    padding: 8px;
  }
  
  .disc {
    width: 64px;
    height: 26px;
    font-size: 16px;
    margin-top: 4px;
  }
  
  /* Adjust bomb blocks for extra small mobile */
  .disc .bomb-emoji {
    font-size: 22px;
    top: -1px;
    left: -11px;
  }
  
  .disc .bomb-text {
    font-size: 16px;
  }
  
  .next-disc {
    width: 70px;
    height: 30px;
    font-size: 16px;
  }
  
  /* Adjust bomb blocks in next queue for extra small mobile */
  .next-disc .bomb-emoji {
    font-size: 26px;
    top: -1px;
    left: -13px;
  }
  
  .next-disc .bomb-text {
    font-size: 16px;
  }
  
  /* Fix next blocks animation for extra small mobile */
  .next-disc.shift-left {
    transform: translateX(-84px); /* Adjusted for extra small mobile next-disc width + gap */
  }
  
  .next-disc.consume-out {
    animation-duration: calc(0.15s * var(--animation-speed, 1)); /* Slightly faster on mobile */
  }
  
  /* Extra small mobile uses same drop animation approach */
  
  /* Fix drop animation for extra small mobile - override default with higher specificity */
  .game .pole .disc.animate {
    animation: dropMobileSmall calc(0.15s * var(--animation-speed, 1)) ease-out !important;
  }
  
  @keyframes dropMobileSmall {
    from { transform: translateY(-40px); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
  
  .game {
    gap: 12px;
  }
  
  .bomb-conversion-btn {
    width: 45px;
    height: 45px;
  }
  
  .bomb-conversion-btn .emoji {
    font-size: 20px;
  }
  
  /* Adjust stage multiplier badge for extra small mobile */
  .stage-multiplier-badge {
    font-size: 9px;
    padding: 2px 4px;
    min-width: 16px;
    bottom: -12px;
    left: 50%;
    transform: translateX(-50%);
  }
  
  .trash-btn {
    width: 45px;
    height: 45px;
  }
  
  .trash-btn .emoji {
    font-size: 20px;
  }
  
  /* Consistent cost text sizing for extra small mobile */
  .bomb-cost-text .emoji, .trash-cost-text .emoji {
    font-size: 18px;
  }
  
  .bomb-cost-text .cost, .trash-cost-text .cost {
    font-size: 14px;
  }
  
  /* Hide next stage display on extra small mobile too */
  .next-stage-container {
    display: none;
  }
}

/* Landscape mobile orientation */
@media (max-width: 768px) and (orientation: landscape) {
  .game-container {
    flex-direction: row;
    align-items: flex-start;
    gap: 12px;
  }
  
  .next-stage-container {
    position: absolute;
    left: calc(100% + 10px);
    top: 0;
    order: unset;
    margin: 0;
  }
  
  /* Position trash button for landscape mobile */
  .trash-button-container {
    position: absolute;
    left: calc(100% + 10px);
    top: 60px;
    order: unset;
    margin: 0;
  }
  
  .bomb-conversion-container {
    position: absolute;
    right: calc(100% + 10px);
    top: 0;
    order: unset;
    margin: 0;
  }
  
  .pole {
    height: 250px;
  }
  
  /* Adjust bomb blocks for landscape mobile */
  .disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .disc .bomb-text {
    font-size: 20px;
  }
  
  /* Adjust bomb blocks in next queue for landscape mobile */
  .next-disc .bomb-emoji {
    font-size: 32px;
    top: -2px;
    left: -18px;
  }
  
  .next-disc .bomb-text {
    font-size: 20px;
  }
}

/* Final desktop override to ensure mobile buttons are hidden */
@media (min-width: 769px) {
  .mobile-button-row {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    position: absolute !important;
    left: -9999px !important;
  }
  
  /* Additional specificity to override any mobile styles */
  body .game-container .mobile-button-row,
  html body .game-container .mobile-button-row {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    position: absolute !important;
    left: -9999px !important;
    width: 0 !important;
    height: 0 !important;
    overflow: hidden !important;
  }
}

/* Probability test results modal */
.prob-test-modal { 
  position: fixed; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%); 
  background: var(--panel); 
  color: var(--text); 
  width: min(600px, 90vw); 
  border-radius: 16px; 
  padding: 24px; 
  box-shadow: 0 15px 45px rgba(0,0,0,0.4); 
  font-family: var(--font-family);
  z-index: 1001;
  max-height: 80vh;
  overflow-y: auto;
}

.prob-test-modal h3 { 
  margin: 0 0 20px; 
  font-size: 20px; 
  text-align: center; 
  color: #0ea5e9;
  font-family: var(--font-family);
}

.prob-test-results {
  background: var(--bg);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
  border: 1px solid #475569;
}

.prob-test-table {
  width: 100%;
  border-collapse: collapse;
  margin: 12px 0;
  font-size: 14px;
}

.prob-test-table th,
.prob-test-table td {
  padding: 8px 12px;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.prob-test-table th {
  background: #334155;
  font-weight: 600;
  color: #f8fafc;
}

.prob-test-table td {
  font-family: 'Courier New', monospace;
  font-size: 13px;
}

.prob-test-table .block-value {
  font-weight: 600;
  color: #0ea5e9;
}

.prob-test-table .expected {
  color: #10B981;
}

.prob-test-table .actual {
  color: #F59E0B;
}

.prob-test-table .difference {
  color: #EF4444;
}

.prob-test-summary {
  text-align: center;
  margin-top: 16px;
  padding: 12px;
  background: #334155;
  border-radius: 6px;
  border: 1px solid #475569;
}

.prob-test-summary .total {
  font-size: 16px;
  font-weight: 600;
  color: #10B981;
}

.prob-test-close {
  background: #334155;
  color: var(--text);
  border: 1px solid #475569;
  padding: 10px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: background 0.2s;
  font-family: var(--font-family);
  width: 100%;
  margin-top: 16px;
}

.prob-test-close:hover {
  background: #475569;
}

.prob-test-close:active {
  background: #334155;
}



/* Hide next blocks section when game is over */
.next.game-over-hidden {
  opacity: 0.3;
  pointer-events: none;
}

/* Show new game button in place of next blocks */
.new-game-container {
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  margin-top: 16px;
}

.new-game-container.show {
  display: flex;
}

.new-game-container .label {
  font-size: 18px;
  opacity: 0.9;
  font-family: var(--font-family);
}

.new-game-container .new-game-btn {
  padding: 12px 24px;
  font-size: 16px;
}
</style>
</head>
<body>
  <!-- Probability test results modal (hidden by default) -->
  <div id="probTestModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="probTestTitle">
    <div class="modal prob-test-modal">
      <h3 id="probTestTitle">Probability Distribution Test Results</h3>
      
      <div class="prob-test-results">
        <div id="probTestContent">
          <!-- Test results will be populated here -->
        </div>
      </div>
      
      <button id="probTestClose" class="prob-test-close">Close</button>
    </div>
  </div>

  <div class="topbar">
    <div class="title-section">
      <button id="addBtn" class="title-btn" title="New Game">+</button>
      <h1>Stack Merge</h1>
      <button id="helpBtn" class="title-btn" title="How to play">?</button>
    </div>
  </div>

  <div class="game-info">
    <div class="score-display">
      <div class="score-label">Score</div>
      <div class="score-value" id="scoreDisplay">0</div>
    </div>
    
    <div class="next">
      <div class="label">Next Blocks</div>
      <div class="next-row" id="nextContainer" aria-live="polite"></div>
    </div>
    

    
    <div class="gold-display">
      <div class="gold-label">Gold</div>
      <div class="gold-value" id="goldDisplay">0</div>
    </div>
  </div>
  


  <!-- Game Over Button Overlay -->
  <div id="gameOverButton" class="game-over-button-overlay">
    <div class="game-over-text">Game Over</div>
  </div>

  <!-- New Game Confirmation Modal -->
  <div id="newGameModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="newGameTitle">
    <div class="modal new-game-modal">
      <h2 id="newGameTitle">New Game?</h2>
      <div class="new-game-buttons">
        <button id="confirmNewGameBtn" class="confirm-new-game-btn">Yes</button>
        <button id="cancelNewGameBtn" class="cancel-new-game-btn">No</button>
      </div>
    </div>
  </div>

  <div class="game-container">
    <!-- Next stage display positioned to the left of stacks -->
    <div class="next-stage-container">
      <div class="next-stage-display">
        <div class="next-stage-label">Next Stage</div>
        <div class="next-stage-indicator">
          <div class="next-stage-block" id="targetBlock" data-value="1024">1024</div>
        </div>
      </div>
    </div>
    
    <div class="game" id="game" role="application" aria-label="Stacks"></div>
    
    <!-- Bomb conversion button positioned to the right of stacks -->
    <div class="bomb-conversion-container">
      <button id="bombConversionBtn" class="bomb-conversion-btn" title="Convert next block to bomb (press again to undo)">
        <span class="emoji">💣</span>
      </button>
      <div class="bomb-cost-text">
        <span class="emoji">💰</span>
        <span class="cost" id="bombCost">25</span>
      </div>
    </div>
    
    <!-- Trash button positioned below bomb button -->
    <div class="trash-button-container">
      <button id="trashButton" class="trash-btn" title="Remove next block from queue">
        <span class="emoji">🗑️</span>
      </button>
      <div class="trash-cost-text">
        <span class="emoji">💰</span>
        <span class="cost" id="trashCost">25</span>
      </div>
    </div>
    
    <!-- Mobile button row for bomb and trash buttons -->
    <div class="mobile-button-row">
      <div class="mobile-bomb-container">
        <button id="bombConversionBtnMobile" class="bomb-conversion-btn" title="Convert next block to bomb (press again to undo)">
          <span class="emoji">💣</span>
        </button>
        <div class="bomb-cost-text">
          <span class="emoji">💰</span>
          <span class="cost" id="bombCostMobile">25</span>
        </div>
      </div>
      
      <div class="mobile-trash-container">
        <button id="trashButtonMobile" class="trash-btn" title="Remove next block from queue">
          <span class="emoji">🗑️</span>
        </button>
        <div class="trash-cost-text">
          <span class="emoji">💰</span>
          <span class="cost" id="trashCostMobile">25</span>
        </div>
      </div>
    </div>
  </div>
  
  <div class="bottom-actions">
    <button id="debugBtn" class="ai-btn" title="Debug controls">⚙️</button>
  </div>


  <!-- Help modal (hidden by default) -->
  <div id="helpModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modal help-modal">
      <h2 id="helpTitle">How to Play</h2>
      
      <div class="help-grid">
        <!-- Basic Controls Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🎮</span>
            <h3>Basic Controls</h3>
          </div>
          <div class="help-content">
            <p>Click one of the four stacks to drop the next block from the queue.</p>
          </div>
        </div>

        <!-- Merging Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🔗</span>
            <h3>Merging Blocks</h3>
          </div>
          <div class="help-content">
            <p>When two blocks with the same number touch, they merge into one bigger block.</p>
            <div class="merge-example" style="display: flex; gap: 80px; justify-content: center;">
              <div style="display: flex; align-items: center; gap: 12px;">
                <div class="merge-before">
                  <div class="merge-blocks">
                    <div class="merge-block block-1">1</div>
                    <div class="merge-block block-1">1</div>
                  </div>
                </div>
                <div class="merge-arrow">→</div>
                <div class="merge-after">
                  <div class="merge-blocks">
                    <div class="merge-block block-2">2</div>
                  </div>
                </div>
              </div>
              
              <div style="display: flex; align-items: center; gap: 12px;">
                <div class="merge-before">
                  <div class="merge-blocks">
                    <div class="merge-block block-2">2</div>
                    <div class="merge-block block-2">2</div>
                  </div>
                </div>
                <div class="merge-arrow">→</div>
                <div class="merge-after">
                  <div class="merge-blocks">
                    <div class="merge-block block-4">4</div>
                  </div>
                </div>
              </div>
            </div>
            
            <p><strong>Bombs:</strong> When a bomb block merges with a block of the same value, it explodes and destroys the entire stack!</p>
            <div class="merge-example">
              <div class="merge-before">
                <div class="merge-blocks">
                  <div class="merge-block block-2">2</div>
                  <div class="merge-block bomb-block">
                    <div class="bomb-content">
                      <div class="bomb-emoji">💣</div>
                      <div class="bomb-text">2</div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="merge-arrow">→</div>
              <div class="merge-after">
                <div class="merge-blocks">
                  <div class="merge-block bomb-block">
                    <div class="bomb-content">
                      <div class="bomb-emoji">💣</div>
                      <div class="bomb-text">4</div>
                    </div>
                  </div>
                </div>
              </div>
              <div style="display: flex; align-items: center; margin-left: 20px;">
                <span style="font-size: 24px; font-weight: bold; color: #f8fafc;">=</span>
                <span style="font-size: 18px; font-weight: bold; color: #ef4444; margin-left: 24px;">Stack Destroyed</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Gold & Power-ups Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">💰</span>
            <h3>Gold & Power-Ups</h3>
          </div>
                      <div class="help-content">
              <p><strong>Earn gold by merging blocks</strong></p>
              <p>• Each additional block in a cascade of merges earns more gold.</p>
              <p>• Use gold to buy power-ups.</p>
              <p>• <strong>Warning! </strong>Power-ups double in cost each time they are used, so try to increase your gold multiplier as soon as possible.</p>
              
              <p style="text-align: center;"><strong>Power-ups:</strong></p>
                            <div style="display: flex; gap: 80px; margin: 16px 0; justify-content: center;">
                <div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                  <button class="bomb-conversion-btn" style="width: 60px; height: 60px; pointer-events: none;">
                    <span class="emoji">💣</span>
                  </button>
                  <span style="color: #f8fafc; font-size: 14px; text-align: center;">Converts next block to bomb</span>
                </div>
                
                <div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                  <button class="trash-btn" style="width: 60px; height: 60px; pointer-events: none;">
                    <span class="emoji">🗑️</span>
                  </button>
                  <span style="color: #f8fafc; font-size: 14px; text-align: center;">Removes next block</span>
                </div>
              </div>
            </div>
        </div>

        <!-- Stage System Section -->
        <div class="help-section">
          <div class="help-section-header">
            <span class="help-icon">🚀</span>
            <h3>Stage Progression</h3>
          </div>
          <div class="help-content">
            <p><strong>Advance through stages to unlock new block sizes and increase gold earnings!</strong></p>
            
            <div class="merge-example" style="justify-content: center; gap: 40px; padding: 20px;">
              <div style="display: flex; flex-direction: column; gap: 20px; align-items: center; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div class="next-stage-display" style="margin: 0; justify-self: end;">
                    <div class="next-stage-indicator">
                      <div class="next-stage-block" data-value="1024" style="width: 120px; height: 50px; font-size: 24px;">1024</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div class="gold-display" style="margin: 0; justify-self: start;">
                    <div class="gold-value" style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 10px 20px; border-radius: 9px; font-weight: 600; font-size: 20px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div class="gold-emoji" style="position: absolute; top: -12px; left: -12px; font-size: 28px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div class="gold-text" style="position: relative; z-index: 2; font-size: 20px; font-weight: 600; line-height: 1; color: #000;">1.5k</div>
                      <div class="stage-multiplier-badge" style="position: absolute; bottom: -16px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 12px; font-weight: 700; padding: 4px 6px; border-radius: 8px; border: 2px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 20px; text-align: center;">10x</div>
                    </div>
                  </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div class="next-stage-display" style="margin: 0; justify-self: end;">
                    <div class="next-stage-indicator">
                      <div class="next-stage-block" data-value="2048" style="width: 120px; height: 50px; font-size: 24px;">2048</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div class="gold-display" style="margin: 0; justify-self: start;">
                    <div class="gold-value" style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 10px 20px; border-radius: 9px; font-weight: 600; font-size: 20px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div class="gold-emoji" style="position: absolute; top: -12px; left: -12px; font-size: 28px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div class="gold-text" style="position: relative; z-index: 2; font-size: 20px; font-weight: 600; line-height: 1; color: #000;">15.5k</div>
                      <div class="stage-multiplier-badge" style="position: absolute; bottom: -16px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 12px; font-weight: 700; padding: 4px 6px; border-radius: 8px; border: 2px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 20px; text-align: center;">100x</div>
                    </div>
                  </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 40px; width: 100%; max-width: 600px;">
                  <div class="next-stage-display" style="margin: 0; justify-self: end;">
                    <div class="next-stage-indicator">
                      <div class="next-stage-block" data-value="4096" style="width: 120px; height: 50px; font-size: 24px;">4096</div>
                    </div>
                  </div>
                  
                  <div style="display: flex; align-items: center; font-size: 24px; color: #94a3b8; justify-self: center;">→</div>
                  
                  <div class="gold-display" style="margin: 0; justify-self: start;">
                    <div class="gold-value" style="position: relative; display: inline-block; background: #FCD34D; color: #000; padding: 10px 20px; border-radius: 9px; font-weight: 600; font-size: 20px; min-width: 70px; text-align: center; box-shadow: 0 3px 0 rgba(0,0,0,0.25);">
                      <div class="gold-emoji" style="position: absolute; top: -12px; left: -12px; font-size: 28px; opacity: 1; z-index: 1; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">💰</div>
                      <div class="gold-text" style="position: relative; z-index: 2; font-size: 20px; font-weight: 600; line-height: 1; color: #000;">555.5k</div>
                      <div class="stage-multiplier-badge" style="position: absolute; bottom: -16px; left: 50%; transform: translateX(-50%); background: #dc2626; color: white; font-size: 12px; font-weight: 700; padding: 4px 6px; border-radius: 8px; border: 2px solid #0f172a; box-shadow: 0 2px 4px rgba(0,0,0,0.3); min-width: 20px; text-align: center;">1000x</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>


      </div>



      <div class="actions">
        <button id="helpClose" class="ai-btn">Close</button>
      </div>
    </div>
  </div>

  <!-- Debug pane (hidden by default) -->
  <div id="debugPane" class="debug-pane">
    <button class="close-btn" id="debugClose" title="Close debug pane">×</button>
    <h3>Debug Controls</h3>
    
    <div class="section">
      <div class="section-title">Game Speed</div>
      <div class="controls">
        <div class="control-row">
          <label for="debugSpeedSlider">Speed:</label>
          <input type="range" id="debugSpeedSlider" min="0" max="4" value="2" step="1">
          <div class="value-display" id="debugSpeedLabel">Medium</div>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Custom Block Dropper</div>
      <div class="controls">
        <div class="control-row">
          <label for="bombToggle">Bomb:</label>
          <input type="checkbox" id="bombToggle">
          <div class="value-display" id="bombStatus">No</div>
        </div>
        <div class="block-grid">
          <div class="block-item no-block" data-value="none">No Block</div>
          <div class="block-item" data-value="1">1</div>
          <div class="block-item" data-value="2">2</div>
          <div class="block-item" data-value="4">4</div>
          <div class="block-item" data-value="8">8</div>
          <div class="block-item" data-value="16">16</div>
          <div class="block-item" data-value="32">32</div>
          <div class="block-item" data-value="64">64</div>
          <div class="block-item" data-value="128">128</div>
          <div class="block-item" data-value="256">256</div>
          <div class="block-item" data-value="512">512</div>
          <div class="block-item" data-value="1024">1024</div>
          <div class="block-item" data-value="2048">2048</div>
          <div class="block-item" data-value="4096">4096</div>
          <div class="block-item" data-value="8192">8192</div>
          <div class="block-item" data-value="16384">16.4k</div>
        </div>
        <div class="selected-block-info">
          Next block: <span id="nextBlockValue" class="next-block-display">Queue</span>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Game State</div>
      <div class="controls">
        <table class="debug-stats-table">
          <tr><td>Score:</td><td id="debugScore">0</td></tr>
          <tr><td>Gold:</td><td id="debugGold">0</td></tr>
          <tr><td>Stacks:</td><td id="debugStacks">4</td></tr>
          <tr><td>Capacity:</td><td id="debugCapacity">10</td></tr>
          <tr><td>Target:</td><td id="debugTarget">1024</td></tr>
          <tr><td>Max Block:</td><td id="debugMaxBlock">512</td></tr>
          <tr><td>Blocks Dropped:</td><td id="debugBlocksDropped">0</td></tr>
          <tr><td>Bomb Status:</td><td id="debugBombStatus">Disabled</td></tr>
          <tr><td>Stage:</td><td id="debugStage">1</td></tr>
        </table>
      </div>
    </div>
    
    <div class="section bottom-buttons">
      <div class="controls">
        <div class="button-row">
          <button id="debugAiToggle" class="button primary">Auto Play: Off</button>
          <button id="grantScoreBtn" class="button primary">Grant 1000 Score</button>
          <button id="grantGoldBtn" class="button primary">Grant 1000 Gold</button>
        </div>
        <div class="button-row" style="margin-top: 8px;">
          <button id="testProbBtn" class="button">Test Probabilities</button>
        </div>
      </div>
    </div>
  </div>

<script>
// weights and probabilities - will be dynamically updated based on stage
let weights = [1, 2]; // Start with 1 and 2, unlock others as player progresses
let probabilities = [0.5, 0.5]; // Equal chance for 1 and 2 initially

// Cookie-based save system
const SAVE_COOKIE_NAME = 'stackMerge_save';
const SAVE_COOKIE_EXPIRY_DAYS = 30;
const MAX_COOKIE_SIZE = 3500; // Conservative limit to avoid issues

// Fallback to localStorage if cookies fail
let useLocalStorage = false;

// Save game state to cookies or localStorage
function saveGameState() {
  try {
    console.log('=== SAVING GAME STATE ===');
    console.log('Current game state:', {
      poles: poles,
      score: score,
      gold: gold,
      blocksDropped: blocksDropped,
      currentTargetBlockSize: currentTargetBlockSize,
      currentStage: currentStage,
      weights: weights,
      probabilities: probabilities,
      nextQueue: nextQueue,
      bombConversionCost: bombConversionCost,
      trashButtonCost: trashButtonCost,
      bombConversionPresses: bombConversionPresses,
      trashButtonPresses: trashButtonPresses,
      bombSelected: bombSelected,
      previousBombCost: previousBombCost
    });
    console.log('💾 Saving button costs - Bomb:', bombConversionCost, 'Trash:', trashButtonCost);
    console.log('💾 Saving bomb state - Selected:', bombSelected, 'Previous Cost:', previousBombCost);
    
    const gameState = {
      poles: poles,
      score: score,
      gold: gold,
      blocksDropped: blocksDropped,
      currentTargetBlockSize: currentTargetBlockSize,
      currentStage: currentStage,
      weights: weights,
      probabilities: probabilities,
      nextQueue: nextQueue,
      bombConversionCost: bombConversionCost,
      trashButtonCost: trashButtonCost,
      bombConversionPresses: bombConversionPresses,
      trashButtonPresses: trashButtonPresses,
      bombSelected: bombSelected,
      previousBombCost: previousBombCost,
      timestamp: Date.now()
    };
    
    const saveData = JSON.stringify(gameState);
    console.log('Save data size:', saveData.length, 'characters');
    console.log('Save data preview:', saveData.substring(0, 200) + '...');
    
    if (useLocalStorage) {
      // Use localStorage fallback
      console.log('📱 Using localStorage fallback...');
      try {
        localStorage.setItem(SAVE_COOKIE_NAME, saveData);
        console.log('✅ Game state saved to localStorage');
      } catch (localStorageError) {
        console.error('❌ localStorage also failed:', localStorageError);
      }
      return;
    }
    
    const expiryDate = new Date();
    expiryDate.setDate(expiryDate.getDate() + SAVE_COOKIE_EXPIRY_DAYS);
    
    // Check if we need to split into multiple cookies
    if (saveData.length > MAX_COOKIE_SIZE) {
      console.log('📦 Save data is large, splitting into multiple cookies...');
      
      // Split the save data into chunks
      const chunks = [];
      for (let i = 0; i < saveData.length; i += MAX_COOKIE_SIZE) {
        chunks.push(saveData.substring(i, i + MAX_COOKIE_SIZE));
      }
      
      console.log(`Split into ${chunks.length} chunks of max ${MAX_COOKIE_SIZE} characters`);
      
      // Save chunk info in first cookie
      const chunkInfo = {
        totalChunks: chunks.length,
        timestamp: Date.now(),
        dataSize: saveData.length
      };
      
      const infoCookie = `${SAVE_COOKIE_NAME}_info=${encodeURIComponent(JSON.stringify(chunkInfo))}; expires=${expiryDate.toUTCString()}; path=/; SameSite=Lax`;
      document.cookie = infoCookie;
      console.log('Set chunk info cookie');
      
      // Save each chunk in separate cookies
      chunks.forEach((chunk, index) => {
        const chunkCookie = `${SAVE_COOKIE_NAME}_chunk_${index}=${encodeURIComponent(chunk)}; expires=${expiryDate.toUTCString()}; path=/; SameSite=Lax`;
        document.cookie = chunkCookie;
        console.log(`Set chunk ${index + 1}/${chunks.length}`);
      });
      
      console.log('✅ Large save data split into multiple cookies');
    } else {
      // Single cookie approach - try multiple cookie formats
      console.log('Setting single cookie:', SAVE_COOKIE_NAME);
      console.log('Cookie expiry:', expiryDate.toUTCString());
      
      // Try different cookie formats to see which one works
      const cookieFormats = [
        // Format 1: Basic cookie
        `${SAVE_COOKIE_NAME}=${encodeURIComponent(saveData)}; expires=${expiryDate.toUTCString()}; path=/`,
        // Format 2: With SameSite
        `${SAVE_COOKIE_NAME}=${encodeURIComponent(saveData)}; expires=${expiryDate.toUTCString()}; path=/; SameSite=Lax`,
        // Format 3: Without expires (session cookie)
        `${SAVE_COOKIE_NAME}=${encodeURIComponent(saveData)}; path=/`,
        // Format 4: Minimal format
        `${SAVE_COOKIE_NAME}=${encodeURIComponent(saveData)}`
      ];
      
      cookieFormats.forEach((format, index) => {
        console.log(`Trying cookie format ${index + 1}:`, format.substring(0, 100) + '...');
        document.cookie = format;
        
        // Check if this format worked
        setTimeout(() => {
          const testCookies = document.cookie.split(';');
          const testCookie = testCookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '='));
          if (testCookie) {
            console.log(`✅ Cookie format ${index + 1} worked!`);
          } else {
            console.log(`❌ Cookie format ${index + 1} failed`);
          }
        }, 50 * (index + 1));
      });
    }
    
    // Wait a moment for cookie to be set, then verify
    setTimeout(() => {
      const cookies = document.cookie.split(';');
      console.log('All cookies after setting:', cookies);
      
      // Check for both single cookie and chunked cookies
      const savedCookie = cookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '='));
      const infoCookie = cookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '_info='));
      
      if (savedCookie) {
        console.log('✅ Single cookie verified successfully');
        console.log('Cookie length:', savedCookie.length);
      } else if (infoCookie) {
        console.log('✅ Chunked cookies verified successfully');
        console.log('Info cookie found:', infoCookie);
        
        // Count chunk cookies
        const chunkCookies = cookies.filter(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '_chunk_'));
        console.log(`Found ${chunkCookies.length} chunk cookies`);
      } else {
        console.error('❌ Cookie verification failed - no save cookies found');
        console.log('Available cookies:', cookies.map(c => c.trim().split('=')[0]));
        
        // Try to read the cookie directly
        try {
          const testCookie = document.cookie;
          console.log('Raw document.cookie:', testCookie);
        } catch (e) {
          console.error('Error reading document.cookie:', e);
        }
        
        // If cookies failed, try localStorage
        console.log('🔄 Attempting localStorage fallback...');
        try {
          localStorage.setItem(SAVE_COOKIE_NAME, saveData);
          console.log('✅ Fallback to localStorage successful');
          useLocalStorage = true;
        } catch (localStorageError) {
          console.error('❌ localStorage also failed:', localStorageError);
        }
      }
    }, 100);
    
    console.log('=== SAVE COMPLETE ===');
  } catch (error) {
    console.error('❌ Failed to save game state:', error);
  }
}

// Restore game state from loaded data
function restoreGameState(gameState) {
  try {
    console.log('Validating loaded game state...');
    
    // Validate the loaded data
    if (!gameState.poles || !Array.isArray(gameState.poles) || gameState.poles.length !== 4) {
      console.error('❌ Invalid save data: poles structure corrupted');
      console.log('Poles:', gameState.poles);
      console.log('Poles type:', typeof gameState.poles);
      console.log('Poles is array:', Array.isArray(gameState.poles));
      console.log('Poles length:', gameState.poles ? gameState.poles.length : 'undefined');
      return false;
    }
    
    // Check if save is too old (more than 30 days)
    const saveAge = Date.now() - gameState.timestamp;
    const maxAge = SAVE_COOKIE_EXPIRY_DAYS * 24 * 60 * 60 * 1000;
    console.log('Save age:', saveAge, 'ms');
    console.log('Max age:', maxAge, 'ms');
    console.log('Save timestamp:', new Date(gameState.timestamp).toISOString());
    
    if (saveAge > maxAge) {
      console.log('❌ Save data is too old, starting fresh game');
      clearGameSave();
      return false;
    }
    
    console.log('✅ Save data validation passed, restoring game state...');
    
    // Restore game state
    const oldPoles = [...poles];
    const oldScore = score;
    const oldGold = gold;
    
    poles = gameState.poles;
    score = gameState.score || 0;
    gold = gameState.gold || 0;
    blocksDropped = gameState.blocksDropped || 0;
    currentTargetBlockSize = gameState.currentTargetBlockSize || STARTING_BLOCK_SIZE;
    currentStage = gameState.currentStage || 1;
    weights = gameState.weights || [1, 2];
    probabilities = gameState.probabilities || [0.5, 0.5];
    nextQueue = gameState.nextQueue || [getRandomPiece(), getRandomPiece(), getRandomPiece()];
    
    // Restore button costs from saved state
    const oldBombCost = bombConversionCost;
    const oldTrashCost = trashButtonCost;
    bombConversionCost = gameState.bombConversionCost || 25;
    trashButtonCost = gameState.trashButtonCost || 25;
    bombConversionPresses = gameState.bombConversionPresses || 0;
    trashButtonPresses = gameState.trashButtonPresses || 0;
    
    // Restore bomb selection state from saved state
    bombSelected = gameState.bombSelected || false;
    previousBombCost = gameState.previousBombCost || bombConversionCost;
    
    console.log('🔄 Restored button costs - Bomb:', oldBombCost, '→', bombConversionCost, 'Trash:', oldTrashCost, '→', trashButtonCost);
    
    console.log('Game state restored:');
    console.log('- Poles changed from', oldPoles.length, 'to', poles.length);
    console.log('- Score changed from', oldScore, 'to', score);
    console.log('- Gold changed from', oldGold, 'to', gold);
    console.log('- Current stage:', currentStage);
    console.log('- Weights:', weights);
    console.log('- Next queue length:', nextQueue.length);
    console.log('- Bomb conversion cost:', bombConversionCost);
    console.log('- Trash button cost:', trashButtonCost);
    console.log('- Bomb selected:', bombSelected);
    console.log('- Previous bomb cost:', previousBombCost);
    
    // Update cost displays after restoring game state
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostEl) {
      trashCostEl.textContent = formatNumber(trashButtonCost);
    }
    if (bombCostElMobile) {
      bombCostElMobile.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostElMobile) {
      trashCostElMobile.textContent = formatNumber(trashButtonCost);
    }
    
    // Update button states to reflect restored bomb selection state
    updateBombConversionButtonState();
    
    console.log('=== LOAD COMPLETE ===');
    return true;
  } catch (error) {
    console.error('❌ Failed to restore game state:', error);
    return false;
  }
}



// Load game state from cookies or localStorage
function loadGameState() {
  try {
    console.log('=== LOADING GAME STATE ===');
    
    // Check localStorage first if we're using it
    if (useLocalStorage) {
      console.log('📱 Loading from localStorage...');
      try {
        const saveData = localStorage.getItem(SAVE_COOKIE_NAME);
        if (saveData) {
          console.log('✅ Found save data in localStorage');
          const gameState = JSON.parse(saveData);
          return restoreGameState(gameState);
        } else {
          console.log('❌ No save data found in localStorage');
          return false;
        }
      } catch (localStorageError) {
        console.error('❌ localStorage load failed:', localStorageError);
        return false;
      }
    }
    
    console.log('All cookies:', document.cookie);
    
    const cookies = document.cookie.split(';');
    console.log('Parsed cookies:', cookies);
    
    // Check for both single cookie and chunked cookies
    const saveCookie = cookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '='));
    const infoCookie = cookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '_info='));
    
    console.log('Looking for cookie starting with:', SAVE_COOKIE_NAME + '=');
    console.log('Found single save cookie:', saveCookie ? 'YES' : 'NO');
    console.log('Found chunked save cookies:', infoCookie ? 'YES' : 'NO');
    
    let saveData;
    
    if (saveCookie) {
      // Single cookie approach
      console.log('📦 Loading from single cookie...');
      console.log('Raw save cookie:', saveCookie);
      const cookieValue = saveCookie.split('=')[1];
      console.log('Cookie value (first 100 chars):', cookieValue ? cookieValue.substring(0, 100) + '...' : 'undefined');
      
      saveData = decodeURIComponent(cookieValue);
      console.log('Decoded save data (first 200 chars):', saveData.substring(0, 200) + '...');
      console.log('Save data length:', saveData.length);
    } else if (infoCookie) {
      // Chunked cookies approach
      console.log('📦 Loading from chunked cookies...');
      
      // Parse chunk info
      const infoValue = infoCookie.split('=')[1];
      const chunkInfo = JSON.parse(decodeURIComponent(infoValue));
      console.log('Chunk info:', chunkInfo);
      
      // Collect all chunks
      const chunks = [];
      for (let i = 0; i < chunkInfo.totalChunks; i++) {
        const chunkCookie = cookies.find(cookie => cookie.trim().startsWith(SAVE_COOKIE_NAME + '_chunk_' + i + '='));
        if (chunkCookie) {
          const chunkValue = chunkCookie.split('=')[1];
          chunks.push(decodeURIComponent(chunkValue));
          console.log(`Loaded chunk ${i + 1}/${chunkInfo.totalChunks}`);
        } else {
          console.error(`❌ Missing chunk ${i + 1}/${chunkInfo.totalChunks}`);
          return false;
        }
      }
      
      // Reconstruct save data
      saveData = chunks.join('');
      console.log('Reconstructed save data length:', saveData.length);
      console.log('Save data preview:', saveData.substring(0, 200) + '...');
    } else {
      console.log('❌ No saved game found in cookies - starting fresh');
      return false;
    }
    
    const gameState = JSON.parse(saveData);
    console.log('Parsed game state:', gameState);
    
    return restoreGameState(gameState);
  } catch (error) {
    console.error('❌ Failed to load game state:', error);
    console.error('Error details:', error.message);
    console.error('Error stack:', error.stack);
    clearGameSave();
    return false;
  }
}

// Clear saved game data
function clearGameSave() {
  try {
    console.log('=== CLEARING GAME SAVE ===');
    
    // Clear all possible save cookies
    const cookiesToClear = [
      SAVE_COOKIE_NAME,
      SAVE_COOKIE_NAME + '_info'
    ];
    
    // Clear chunk cookies (up to 10 chunks)
    for (let i = 0; i < 10; i++) {
      cookiesToClear.push(SAVE_COOKIE_NAME + '_chunk_' + i);
    }
    
    console.log('Clearing cookies:', cookiesToClear);
    
    cookiesToClear.forEach(cookieName => {
      document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
    });
    
    // Verify cookies were removed
    const remainingCookies = document.cookie.split(';');
    const remainingSaveCookies = remainingCookies.filter(cookie => 
      cookie.trim().startsWith(SAVE_COOKIE_NAME + '=')
    );
    
    if (remainingSaveCookies.length === 0) {
      console.log('✅ All save cookies successfully removed');
    } else {
      console.error('❌ Some save cookies still exist:', remainingSaveCookies);
    }
    
    // Also clear localStorage if we're using it
    if (useLocalStorage) {
      try {
        localStorage.removeItem(SAVE_COOKIE_NAME);
        console.log('✅ localStorage save data cleared');
      } catch (e) {
        console.error('❌ Failed to clear localStorage:', e);
      }
    }
    
    console.log('=== CLEAR COMPLETE ===');
  } catch (error) {
    console.error('❌ Failed to clear game save:', error);
  }
}

// Auto-save game state periodically and on important events
function setupAutoSave() {
  // Test cookie functionality first
  console.log('=== TESTING COOKIE FUNCTIONALITY ===');
  console.log('Current URL protocol:', window.location.protocol);
  console.log('Current URL:', window.location.href);
  console.log('Document cookie before test:', document.cookie);
  
  // Try to set a simple test cookie
  document.cookie = 'test_cookie=hello';
  console.log('Document cookie after setting test:', document.cookie);
  
  // Check if test cookie was set
  const testCookie = document.cookie.includes('test_cookie');
  console.log('Test cookie set successfully:', testCookie ? 'YES' : 'NO');
  
  if (!testCookie) {
    console.error('❌ COOKIES ARE NOT WORKING - browser may be blocking them');
    console.log('This could be due to:');
    console.log('- Browser privacy settings');
    console.log('- Incognito/private browsing mode');
    console.log('- Browser extensions blocking cookies');
    console.log('- HTTPS/HTTP mismatch');
    console.log('- SameSite policy restrictions');
    
    // Check if it's a local file issue
    if (window.location.protocol === 'file:') {
      console.log('🚨 DETECTED LOCAL FILE PROTOCOL - Cookies are blocked by browser security');
      console.log('This is expected behavior for file:// URLs');
      console.log('Solutions:');
      console.log('1. Use a local web server (http://localhost)');
      console.log('2. Use localStorage fallback (automatic)');
      console.log('3. Deploy to a web server');
      console.log('');
      console.log('💡 QUICK LOCAL SERVER SETUP:');
      console.log('If you have Python installed:');
      console.log('  python -m http.server 8000');
      console.log('Then visit: http://localhost:8000');
      console.log('');
      console.log('If you have Node.js installed:');
      console.log('  npx http-server');
      console.log('Then visit: http://localhost:8080');
    }
    
    // Automatically switch to localStorage
    console.log('🔄 Automatically switching to localStorage fallback...');
    useLocalStorage = true;
    
    // Test localStorage functionality
    try {
      localStorage.setItem('test_storage', 'hello');
      const testValue = localStorage.getItem('test_storage');
      if (testValue === 'hello') {
        console.log('✅ localStorage working correctly');
        localStorage.removeItem('test_storage');
      } else {
        console.error('❌ localStorage test failed');
      }
    } catch (e) {
      console.error('❌ localStorage not available:', e);
    }
  } else {
    console.log('✅ Basic cookie functionality working');
    
    // Clean up test cookie
    document.cookie = 'test_cookie=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
    console.log('Test cookie cleaned up');
  }
  
  // Auto-save every 30 seconds during gameplay
  setInterval(() => {
    if (score > 0 || gold > 0) { // Only save if there's actual progress
      console.log(`🔄 Auto-save interval triggered (using ${useLocalStorage ? 'localStorage' : 'cookies'})...`);
      saveGameState();
    }
  }, 30000);
  
  // Save on page unload/visibility change
  window.addEventListener('beforeunload', () => {
    console.log('🔄 Page unloading - saving game state...');
    saveGameState();
  });
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      console.log('🔄 Page hidden - saving game state...');
      saveGameState();
    }
  });
}

// Number formatting utility function
function formatNumber(num) {
  if (num < 1000) {
    return num.toString();
  } else if (num < 1000000) {
    return (num / 1000).toFixed(1) + 'k';
  } else if (num < 1000000000) {
    return (num / 1000000).toFixed(1) + 'm';
  } else if (num < 1000000000000) {
    return (num / 1000000000).toFixed(1) + 'b';
  } else if (num < 1000000000000000) {
    return (num / 1000000000000).toFixed(1) + 't';
  } else if (num < 1000000000000000000) {
    return (num / 1000000000000000).toFixed(1) + 'q';
  } else {
    return (num / 1000000000000000000).toFixed(1) + 'Q';
  }
}

// Multiplier formatting utility function
function formatMultiplier(num) {
  if (num < 100000) {
    return num.toString() + ' x';
  } else {
    // Use scientific notation for 100,000 and above without + sign
    const exp = Math.floor(Math.log10(num));
    const mantissa = (num / Math.pow(10, exp)).toFixed(1);
    return mantissa + 'e' + exp + ' x';
  }
}

// Centralized display update functions
function updateScoreDisplay() {
  const scoreDisplay = document.querySelector('.score-value');
  if (scoreDisplay) {
    scoreDisplay.innerHTML = `<div class="score-star">⭐</div><div class="score-text">${score}</div>`;
  }
  // Update debug score display with exact value
  if (debugScore) {
    debugScore.textContent = score;
  }
  
  // Auto-save when score changes
  if (score > 0) {
    saveGameState();
  }
}

function updateGoldDisplay() {
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
    const oldMultiplier = goldDisplay.querySelector('.stage-multiplier-badge')?.textContent;
    const newMultiplier = formatMultiplier(stageMultiplier);
    
    // Only show badge for stage 2 and higher
    const badgeHTML = currentStage >= 2 ? `<div class="stage-multiplier-badge" id="stageMultiplierBadge">${newMultiplier}</div>` : '';
    
    goldDisplay.innerHTML = `
      <div class="gold-emoji">💰</div>
      <div class="gold-text">${formatNumber(gold)}</div>
      ${badgeHTML}
    `;
    
    // Add pulse animation for stage progression if multiplier changed and badge exists
    if (oldMultiplier && oldMultiplier !== newMultiplier && currentStage >= 2) {
      const badge = goldDisplay.querySelector('.stage-multiplier-badge');
      if (badge) {
        badge.classList.add('pulse');
        setTimeout(() => {
          badge.classList.remove('pulse');
        }, 600);
      }
    }
  }
  
  // Update debug gold display with exact value
  if (debugGold) {
    debugGold.textContent = gold;
  }
  
  // Auto-save when gold changes
  if (gold > 0) {
    saveGameState();
  }
}
const MAX_HEIGHT = 10;
const BOMB_CHANCE = 0.01; // 1% chance for bombs
const BOMB_DELAY_BLOCKS = 50; // No bombs for first 50 blocks
const STARTING_BLOCK_SIZE = 512; // Starting block size to merge for new stacks

function getRandomWeight(){
  // Validate probabilities before selecting
  if (!validateProbabilityDistribution()) {
    console.error('Probability validation failed, using uniform distribution');
    const randomIndex = Math.floor(Math.random() * weights.length);
    return weights[randomIndex];
  }
  
  let r = Math.random();
  let cum = 0;
  
  for(let i=0;i<probabilities.length;i++){
    cum += probabilities[i];
    if (r < cum) {
      console.log(`Random weight selected: ${weights[i]} (probability: ${probabilities[i].toFixed(4)}, cumulative: ${cum.toFixed(4)})`);
      return weights[i];
    }
  }
  
  // Fallback - this should rarely happen if probabilities are correct
  console.warn(`Random weight fallback: ${weights[probabilities.length-1]} (cumulative sum: ${cum.toFixed(6)})`);
  return weights[probabilities.length-1];
}

function getRandomPiece(){
  // Prevent bombs from spawning for the first 50 blocks
  const canSpawnBomb = blocksDropped >= BOMB_DELAY_BLOCKS;
  const bombChance = canSpawnBomb ? BOMB_CHANCE : 0;
  
  return { w: getRandomWeight(), bomb: Math.random() < bombChance };
}

let poles = [[],[],[],[]];
let score = 0;
let gold = 0; // Track accumulated gold
let blocksDropped = 0; // Track total blocks dropped for bomb delay
let placing = false; // block multiple rapid placements while animating
let lastPlacementTime = 0; // track when placement started for timeout safety
let currentTargetBlockSize = STARTING_BLOCK_SIZE; // Current block size needed to unlock new stack
let currentStackCapacity = MAX_HEIGHT; // Current maximum height for each stack (no longer reduced per stage)
let currentStage = 1; // Current stage (1 = starting, 2 = after first stack unlock, etc.)

// Bomb conversion button state
let bombConversionCost = 25;
let bombConversionPresses = 0; // Number of times button has been pressed
let lastGoldAmount = 0; // Track last gold amount to prevent unnecessary updates
let bombSelected = false; // Track if a bomb is currently selected but not yet placed
let previousBombCost = 25; // Store the previous bomb cost before conversion

// Trash button state
let trashButtonCost = 25;
let trashButtonPresses = 0; // Number of times button has been pressed

// Set up initial probability distribution for the starting block sizes (1 and 2)
updateProbabilityDistribution();

// Initialize next queue after probability distribution is set up
let nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];

// Emergency reset keyboard shortcut (Ctrl+R)
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 'r') {
    e.preventDefault();
    console.log('Emergency reset triggered via Ctrl+R');
    placing = false; // Force reset placing state
    
    // Re-enable hover effects and pointer events on all poles
    const allPoles = Array.from(gameDiv.children);
    allPoles.forEach(poleDiv => {
      poleDiv.style.pointerEvents = '';
      poleDiv.classList.remove('no-hover');
    });
    
    resetGame(true);
  }
});



function checkForNewStack() {
  // Stage progression without adding new stacks
  // IMPORTANT: This function should NEVER modify the poles array
  // Poles should remain at exactly 4 permanently
  
  // Safety check: ensure we still have exactly 4 poles
  if (poles.length !== 4) {
    console.error(`CRITICAL ERROR: checkForNewStack found ${poles.length} poles instead of 4! Resetting to 4 poles.`);
    poles = [[],[],[],[]];
  }
  
  // Increment stage counter for gold multiplier
  currentStage++;
  // Double the target block size for the next unlock
  currentTargetBlockSize *= 2;
  // Don't call updateBlockRange() here - let the merge system handle block unlocking
  const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
  console.log(`Advanced to Stage ${currentStage}! Gold earnings now multiplied by ${stageMultiplier}x`);
  console.log(`Poles count remains at ${poles.length} (should always be 4)`);
  console.log(`New target block size: ${currentTargetBlockSize} (need to merge to ${currentTargetBlockSize * 2} for next stage)`);
  
  // Save game state after stage progression
  console.log('🔄 Triggering save after stage progression...');
  saveGameState();
}

function checkForNewBlockSize(mergedSize) {
  // Check if this merge unlocks a new block size for future drops
  // The merged size should be available as a droppable piece
  if (!weights.includes(mergedSize)) {
    weights.push(mergedSize);
    
    // Check if this was a stage-triggering block
    if (mergedSize === currentTargetBlockSize * 2) {
      // This was a stage progression block
      console.log(`Stage progression block ${mergedSize} added to droppable pieces`);
    } else {
      // This was a regular merge unlock
      console.log(`Regular block size ${mergedSize} unlocked`);
    }
    
    // Implement a better probability distribution system
    // Lower tier blocks should remain more common, higher tiers progressively rarer
    updateProbabilityDistribution();
    
    console.log(`New block size unlocked: ${mergedSize}`);
    
    // Save game state after unlocking new block size
    console.log('🔄 Triggering save after unlocking new block size...');
    saveGameState();
  }
}

function updateProbabilityDistribution() {
  // Create a balanced probability distribution that scales properly with new blocks
  // Lower tier blocks should be more common, higher tiers progressively rarer
  
  const numBlocks = weights.length;
  
  if (numBlocks === 0) {
    console.warn('No blocks available for probability distribution');
    return;
  }
  
  // Base probabilities with proper scaling
  const baseProbabilities = [];
  
  for (let i = 0; i < numBlocks; i++) {
    const blockSize = weights[i];
    
    if (i < 3) {
      // First three block sizes (1, 2, 4) get equal, higher probabilities
      baseProbabilities.push(0.25);
    } else if (i < 6) {
      // Next three block sizes (8, 16, 32) get medium probabilities
      baseProbabilities.push(0.15);
    } else if (i < 9) {
      // Next three block sizes (64, 128, 256) get lower probabilities
      baseProbabilities.push(0.08);
    } else {
      // Highest tier blocks get very low probabilities
      baseProbabilities.push(0.04);
    }
  }
  
  // Normalize probabilities to sum to 1.0
  const totalProbability = baseProbabilities.reduce((sum, p) => sum + p, 0);
  
  if (totalProbability === 0) {
    console.error('Total probability is 0, using uniform distribution');
    probabilities = new Array(numBlocks).fill(1.0 / numBlocks);
  } else {
    probabilities = baseProbabilities.map(p => p / totalProbability);
  }
  
  // Verify probabilities sum to 1.0 (with small floating point tolerance)
  const actualSum = probabilities.reduce((sum, p) => sum + p, 0);
  if (Math.abs(actualSum - 1.0) > 0.0001) {
    console.warn(`Probability sum is ${actualSum.toFixed(6)}, expected 1.0. Normalizing...`);
    // Force normalization
    const correctedSum = probabilities.reduce((sum, p) => sum + p, 0);
    probabilities = probabilities.map(p => p / correctedSum);
  }
  
  // Final validation
  validateProbabilityDistribution();
  
  // Log the current state for debugging
  logProbabilityState();
  
  console.log('Updated probability distribution:', weights.map((w, i) => `${w}: ${probabilities[i].toFixed(4)}`).join(', '));
  console.log('Probability sum:', probabilities.reduce((sum, p) => sum + p, 0).toFixed(6));
  console.log('Current weights array:', weights);
}

function validateProbabilityDistribution() {
  // Validate that probabilities are mathematically correct
  if (!probabilities || probabilities.length === 0) {
    console.error('Probabilities array is empty or undefined');
    return false;
  }
  
  if (probabilities.length !== weights.length) {
    console.error(`Mismatch: ${probabilities.length} probabilities vs ${weights.length} weights`);
    return false;
  }
  
  // Check for negative probabilities
  const negativeProbs = probabilities.filter(p => p < 0);
  if (negativeProbs.length > 0) {
    console.error('Found negative probabilities:', negativeProbs);
    return false;
  }
  
  // Check that probabilities sum to 1.0 (with tolerance for floating point errors)
  const sum = probabilities.reduce((s, p) => s + p, 0);
  if (Math.abs(sum - 1.0) > 0.0001) {
    console.error(`Probabilities sum to ${sum.toFixed(6)}, expected 1.0`);
    return false;
  }
  
  // Check that all probabilities are finite numbers
  const invalidProbs = probabilities.filter(p => !isFinite(p));
  if (invalidProbs.length > 0) {
    console.error('Found invalid probabilities:', invalidProbs);
    return false;
  }
  
  console.log('Probability distribution validation passed ✓');
  return true;
}

// updateBlockRange function removed - block unlocking now handled entirely by checkForNewBlockSize





function showGoldEarned(amount) {
  // Create the gold earned display element
  const goldEl = document.createElement('div');
  goldEl.className = 'gold-earned';
  goldEl.textContent = `+${amount}`;
  
  // Position it closer to the top right corner of the gold display
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    const rect = goldDisplay.getBoundingClientRect();
    goldEl.style.left = (rect.right + 2) + 'px';
    goldEl.style.top = (rect.top + 5) + 'px';
  } else {
    // Fallback positioning if gold display not found
    goldEl.style.left = '50%';
    goldEl.style.top = '50%';
    goldEl.style.transform = 'translate(-50%, -50%)';
  }
  
  document.body.appendChild(goldEl);
  
  // Add pulse animation to the gold count
  if (goldDisplay) {
    goldDisplay.classList.add('pulse');
    setTimeout(() => {
      goldDisplay.classList.remove('pulse');
    }, 300);
  }
  
  // Remove after animation completes
  setTimeout(() => {
    if (goldEl.parentNode) {
      goldEl.parentNode.removeChild(goldEl);
    }
  }, 1200);
}

function handleBombConversion() {
  // Check if there's a next block to work with
  if (nextQueue.length === 0) {
    return;
  }
  
  const currentBlock = nextQueue[0];
  
  // If a bomb is already selected, allow undoing the selection
  if (bombSelected && currentBlock.bomb) {
    // Undo bomb selection
    currentBlock.bomb = false;
    gold += previousBombCost; // Refund the gold that was actually spent
    bombConversionCost = previousBombCost; // Restore previous cost
    bombSelected = false;
    
    console.log(`Undid bomb selection, refunded ${previousBombCost} gold, restored cost to ${previousBombCost}`);
    
    // Update gold display
    updateGoldDisplay();
    const goldDisplay = document.querySelector('.gold-value');
    if (goldDisplay) {
      goldDisplay.classList.add('pulse');
      setTimeout(() => {
        goldDisplay.classList.remove('pulse');
      }, 300);
    }
    
    // Re-render to show the regular block
    renderNext();
    
    // Update button cost display
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (bombCostElMobile) {
      bombCostElMobile.textContent = formatNumber(bombConversionCost);
    }
    
    // Update button state and appearance
    updateBombConversionButtonState();
    
    // Save game state after undoing bomb selection
    console.log('🔄 Triggering save after undoing bomb selection...');
    saveGameState();
    return;
  }
  
  // Check if the next block is already a bomb (either natural or from previous conversion)
  if (currentBlock.bomb) {
    // Show feedback that the block is already a bomb
    bombConversionBtn.classList.add('pulse');
    setTimeout(() => bombConversionBtn.classList.remove('pulse'), 300);
    if (bombConversionBtnMobile) {
      bombConversionBtnMobile.classList.add('pulse');
      setTimeout(() => bombConversionBtnMobile.classList.remove('pulse'), 300);
    }
    return;
  }
  
  // Check if player has enough gold for new bomb conversion
  if (gold < bombConversionCost) {
    // Show feedback that they don't have enough gold
    bombConversionBtn.classList.add('pulse');
    setTimeout(() => bombConversionBtn.classList.remove('pulse'), 300);
    if (bombConversionBtnMobile) {
      bombConversionBtnMobile.classList.add('pulse');
      setTimeout(() => bombConversionBtnMobile.classList.remove('pulse'), 300);
    }
    return;
  }
  
  // Store the current cost before converting
  previousBombCost = bombConversionCost;
  
  // Deduct gold
  gold -= bombConversionCost;
  
  // Convert the current next block to a bomb
  if (currentBlock) {
    currentBlock.bomb = true;
    bombSelected = true; // Mark that a bomb is selected
    console.log(`Converted block ${currentBlock.w} to bomb for ${bombConversionCost} gold`);
    
    // Update gold display
    updateGoldDisplay();
    const goldDisplay = document.querySelector('.gold-value');
    if (goldDisplay) {
      goldDisplay.classList.add('pulse');
      setTimeout(() => {
        goldDisplay.classList.remove('pulse');
      }, 300);
    }
    
    // Re-render to show the bomb
    renderNext();
    
    // Also re-render the main game to ensure pole placement logic is updated
    // This ensures that if bomb status affects any placement decisions, they're properly reflected
    render();
    
    // Increment press count and double the cost
    bombConversionCost *= 2;
    
    // Update button cost display
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (bombCostElMobile) {
      bombCostElMobile.textContent = formatNumber(bombConversionCost);
    }
    
    // Update button state (cost changed, so force update)
    updateBombConversionButtonState();
    
    // Save game state after bomb conversion and cost increase
    console.log('🔄 Triggering save after bomb conversion and cost increase...');
    saveGameState();
  }
}

function handleTrashButton() {
  // Check if player has enough gold
  if (gold < trashButtonCost) {
    // Show feedback that they don't have enough gold
    trashButton.classList.add('pulse');
    setTimeout(() => trashButton.classList.remove('pulse'), 300);
    if (trashButtonMobile) {
      trashButtonMobile.classList.add('pulse');
      setTimeout(() => trashButtonMobile.classList.remove('pulse'), 300);
    }
    return;
  }
  
  // Check if there's a next block to remove
  if (nextQueue.length === 0) {
    return;
  }
  
  // Deduct gold
  gold -= trashButtonCost;
  
  // Remove the current next block from the queue
  const removedBlock = nextQueue.shift();
  console.log(`Removed block ${removedBlock.w} from queue for ${trashButtonCost} gold`);
  
  // Add a new random block to the end of the queue to maintain 3 blocks
  nextQueue.push(getRandomPiece());
  
  // Update gold display
  updateGoldDisplay();
  const goldDisplay = document.querySelector('.gold-value');
  if (goldDisplay) {
    goldDisplay.classList.add('pulse');
    setTimeout(() => {
      goldDisplay.classList.remove('pulse');
    }, 300);
  }
  
  // Play the same animation as placing a block, but don't place it
  animateNextQueueAdvance(true).then(() => {
    // After the queue animation completes, re-render to update pole placement logic
    // This ensures that the new next block can be properly evaluated for placement
    render();
  }); // true = queue already modified
  
  // Increment press count and double the cost
  trashButtonCost *= 2;
  
  // Update button cost display
  const trashCostEl = document.getElementById('trashCost');
  if (trashCostEl) {
    trashCostEl.textContent = formatNumber(trashButtonCost);
  }
  if (trashCostElMobile) {
    trashCostElMobile.textContent = formatNumber(trashButtonCost);
  }
  
  // Update button state (cost changed, so force update)
  updateTrashButtonState();
  
  // Save game state after using trash button and cost increase
  console.log('🔄 Triggering save after using trash button and cost increase...');
  saveGameState();
}

function updateBombConversionButtonState() {
  // Always update when called since we call this strategically
  if (bombConversionBtn) {
    // If a bomb is selected, the button should always be enabled for undo
    if (bombSelected) {
      bombConversionBtn.disabled = false;
      bombConversionBtn.classList.remove('affordable');
      bombConversionBtn.classList.add('undo-mode');
      bombConversionBtn.title = "Press again to undo bomb selection";
      bombConversionBtn.querySelector('.emoji').textContent = "↩️";
    } else {
      // Check if the next block is already a bomb (either natural or from previous conversion)
      const nextBlockIsBomb = nextQueue.length > 0 && nextQueue[0].bomb;
      
      if (nextBlockIsBomb) {
        // Next block is already a bomb, disable the button
        bombConversionBtn.disabled = true;
        bombConversionBtn.classList.remove('affordable');
        bombConversionBtn.classList.remove('undo-mode');
        bombConversionBtn.title = "Next block is already a bomb";
        bombConversionBtn.querySelector('.emoji').textContent = "💣";
      } else {
        // Next block is not a bomb, check if player has enough gold
        const hasEnoughGold = gold >= bombConversionCost;
        bombConversionBtn.disabled = !hasEnoughGold;
        
        // Update visual styling based on affordability
        // Red border (default): when gold < cost (disabled)
        // White border (affordable): when gold >= cost (enabled)
        if (hasEnoughGold) {
          bombConversionBtn.classList.add('affordable');
        } else {
          bombConversionBtn.classList.remove('affordable');
        }
        bombConversionBtn.classList.remove('undo-mode');
        bombConversionBtn.title = "Convert next block to bomb (press again to undo)";
        bombConversionBtn.querySelector('.emoji').textContent = "💣";
      }
    }
    
    // Update the tracked gold amount
    lastGoldAmount = gold;
  }
  
  // Also update mobile button if it exists
  if (bombConversionBtnMobile) {
    // If a bomb is selected, the button should always be enabled for undo
    if (bombSelected) {
      bombConversionBtnMobile.disabled = false;
      bombConversionBtnMobile.classList.remove('affordable');
      bombConversionBtnMobile.classList.add('undo-mode');
      bombConversionBtnMobile.title = "Press again to undo bomb selection";
      bombConversionBtnMobile.querySelector('.emoji').textContent = "↩️";
    } else {
      // Check if the next block is already a bomb (either natural or from previous conversion)
      const nextBlockIsBomb = nextQueue.length > 0 && nextQueue[0].bomb;
      
      if (nextBlockIsBomb) {
        // Next block is already a bomb, disable the button
        bombConversionBtnMobile.disabled = true;
        bombConversionBtnMobile.classList.remove('affordable');
        bombConversionBtnMobile.classList.remove('undo-mode');
        bombConversionBtnMobile.title = "Next block is already a bomb";
        bombConversionBtnMobile.querySelector('.emoji').textContent = "💣";
      } else {
        // Next block is not a bomb, check if player has enough gold
        const hasEnoughGold = gold >= bombConversionCost;
        bombConversionBtnMobile.disabled = !hasEnoughGold;
        
        if (hasEnoughGold) {
          bombConversionBtnMobile.classList.add('affordable');
        } else {
          bombConversionBtnMobile.classList.remove('affordable');
        }
        bombConversionBtnMobile.classList.remove('undo-mode');
        bombConversionBtnMobile.title = "Convert next block to bomb (press again to undo)";
        bombConversionBtnMobile.querySelector('.emoji').textContent = "💣";
      }
    }
  }
}

function updateTrashButtonState() {
  // Always update when called since we call this strategically
  console.log(`updateTrashButtonState called - gold: ${gold}, trashButtonCost: ${trashButtonCost}, lastGoldAmount: ${lastGoldAmount}`);
  console.log(`trashButton element:`, trashButton);
  if (trashButton) {
    const hasEnoughGold = gold >= trashButtonCost;
    console.log(`Trash button - hasEnoughGold: ${hasEnoughGold}, will disable: ${!hasEnoughGold}`);
    trashButton.disabled = !hasEnoughGold;
    
    // Update visual styling based on affordability
    // Red border (default): when gold < cost (disabled)
    // White border (affordable): when gold >= cost (enabled)
    if (hasEnoughGold) {
      trashButton.classList.add('affordable');
      console.log('Trash button: Added affordable class');
    } else {
      trashButton.classList.remove('affordable');
      console.log('Trash button: Removed affordable class');
    }
    
    // Update the tracked gold amount
    lastGoldAmount = gold;
    console.log(`Updated lastGoldAmount to: ${lastGoldAmount}`);
  } else {
    console.log('Trash button element not found');
  }
  
  // Also update mobile button if it exists
  if (trashButtonMobile) {
    const hasEnoughGold = gold >= trashButtonCost;
    trashButtonMobile.disabled = !hasEnoughGold;
    
    if (hasEnoughGold) {
      trashButtonMobile.classList.add('affordable');
    } else {
      trashButtonMobile.classList.remove('affordable');
    }
  }
}

// More targeted update function for when we know gold has changed
// Use this instead of updateBombConversionButtonState() when gold changes during gameplay
function updateBombButtonIfGoldChanged() {
  updateBombConversionButtonState();
}

// More targeted update function for trash button when we know gold has changed
function updateTrashButtonIfGoldChanged() {
  console.log(`updateTrashButtonIfGoldChanged called - gold: ${gold}, lastGoldAmount: ${lastGoldAmount}`);
  updateTrashButtonState();
}

// AI state
let aiEnabled = false;
let aiInterval = null;
const AI_DELAY_MS = 500;

// Speed control state
let currentSpeed = 2; // 0-4, default 2 (Medium): 0=Very Slow, 1=Slow, 2=Medium, 3=Fast, 4=Blazing

// Debug pane state
let debugPane = null;
let debugClose = null;
let bombToggle = null;
let bombStatus = null;
let debugScore = null;
let debugGold = null;
let debugStacks = null;
let debugCapacity = null;
let debugTarget = null;
let debugMaxBlock = null;
let debugBlocksDropped = null;
let debugBombStatus = null;
let debugStage = null;
let debugAiToggle = null;
let debugSpeedSlider = null;
let debugSpeedLabel = null;
let customBlockMode = false;
let customBlockSize = null;
let customBlockBomb = false;

// DOM refs
const gameDiv = document.getElementById('game');
const nextContainer = document.getElementById('nextContainer');
const scoreEl = document.getElementById('scoreDisplay');
const goldEl = document.getElementById('goldDisplay');

const helpBtn = document.getElementById('helpBtn');
const helpModal = document.getElementById('helpModal');
const helpClose = document.getElementById('helpClose');

// Bomb conversion button DOM refs
const bombConversionBtn = document.getElementById('bombConversionBtn');
const bombCostEl = document.getElementById('bombCost');

// Trash button DOM refs
const trashButton = document.getElementById('trashButton');
const trashCostEl = document.getElementById('trashCost');

// Mobile button DOM refs
const bombConversionBtnMobile = document.getElementById('bombConversionBtnMobile');
const bombCostElMobile = document.getElementById('bombCostMobile');
const trashButtonMobile = document.getElementById('trashButtonMobile');
const trashCostElMobile = document.getElementById('trashCostMobile');

// Debug pane DOM refs
debugPane = document.getElementById('debugPane');
debugClose = document.getElementById('debugClose');
bombToggle = document.getElementById('bombToggle');
bombStatus = document.getElementById('bombStatus');
debugScore = document.getElementById('debugScore');
debugGold = document.getElementById('debugGold');
debugStacks = document.getElementById('debugStacks');
debugCapacity = document.getElementById('debugCapacity');
debugTarget = document.getElementById('debugTarget');
debugMaxBlock = document.getElementById('debugMaxBlock');
debugBlocksDropped = document.getElementById('debugBlocksDropped');
debugBombStatus = document.getElementById('debugBombStatus');
debugStage = document.getElementById('debugStage');
const grantGoldBtn = document.getElementById('grantGoldBtn');
const grantScoreBtn = document.getElementById('grantScoreBtn');

// Debug auto-play DOM refs
debugAiToggle = document.getElementById('debugAiToggle');
debugSpeedSlider = document.getElementById('debugSpeedSlider');
debugSpeedLabel = document.getElementById('debugSpeedLabel');



// Help modal wiring
function openHelp(){ helpModal.classList.remove('hidden'); }
function closeHelp(){ helpModal.classList.add('hidden'); }
helpBtn.addEventListener('click', openHelp);
helpClose.addEventListener('click', closeHelp);
helpModal.addEventListener('click', (e) => { if (e.target === helpModal) closeHelp(); });
window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !helpModal.classList.contains('hidden')) closeHelp(); });

// Bomb conversion button event listener
bombConversionBtn.addEventListener('click', handleBombConversion);

// Trash button event listener
trashButton.addEventListener('click', handleTrashButton);

// Mobile button event listeners
bombConversionBtnMobile.addEventListener('click', handleBombConversion);
trashButtonMobile.addEventListener('click', handleTrashButton);

// Game over popup - any click anywhere closes it
const gameOverButton = document.getElementById('gameOverButton');
if (gameOverButton) {
  // Add click listener to the document to close game over popup on any click
  document.addEventListener('click', () => {
    if (gameOverButton.classList.contains('show')) {
      gameOverButton.classList.remove('show');
    }
  });
}

// Add button event listener for new game
const addBtn = document.getElementById('addBtn');
if (addBtn) {
  addBtn.addEventListener('click', openNewGameModal);
}

// New game modal button event listeners
const confirmNewGameBtn = document.getElementById('confirmNewGameBtn');
if (confirmNewGameBtn) {
  confirmNewGameBtn.addEventListener('click', handleNewGameConfirmation);
}

const cancelNewGameBtn = document.getElementById('cancelNewGameBtn');
if (cancelNewGameBtn) {
  cancelNewGameBtn.addEventListener('click', handleNewGameCancel);
}

// Close new game modal when clicking outside
const newGameModal = document.getElementById('newGameModal');
if (newGameModal) {
  newGameModal.addEventListener('click', (e) => {
    if (e.target === newGameModal) {
      closeNewGameModal();
    }
  });
}

// Close new game modal with Escape key
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && newGameModal && !newGameModal.classList.contains('hidden')) {
    closeNewGameModal();
  }
});

// Initialize button states
updateBombConversionButtonState();
updateTrashButtonState();

// Initialize cost displays
if (bombCostEl) {
  bombCostEl.textContent = formatNumber(bombConversionCost);
}
if (trashCostEl) {
  trashCostEl.textContent = formatNumber(trashButtonCost);
}
if (bombCostElMobile) {
  bombCostElMobile.textContent = formatNumber(bombConversionCost);
}
if (trashCostElMobile) {
  trashCostElMobile.textContent = formatNumber(trashButtonCost);
}

// Debug button wiring
debugBtn.addEventListener('click', openDebugPane);

// Simple title selection detection to reveal debug button
document.addEventListener('DOMContentLoaded', () => {
  const titleElement = document.querySelector('h1');
  const debugBtn = document.getElementById('debugBtn');
  
  titleElement.addEventListener('mouseup', () => {
    const selection = window.getSelection();
    if (selection.toString().toLowerCase().includes('merge')) {
      debugBtn.style.display = 'block';
      console.log('Debug button revealed!');
    }
  });
});

function toggleAI(enable){
  if(enable === aiEnabled) return;
  aiEnabled = enable;
  
  console.log('AI toggled:', aiEnabled ? 'ON' : 'OFF');
  
  // Update debug pane display if it exists
  if (debugAiToggle) {
    updateDebugAutoPlayDisplay();
  }
  

  
  if(aiEnabled){
    // start AI interval
    if(aiInterval) clearInterval(aiInterval);
    // make an immediate move then interval
    console.log('AI: Starting immediate move');
    aiStep();
    // Set up the initial interval based on current speed
    const delays = [2000, 1500, 1000, 500, 50];
    const initialDelay = delays[currentSpeed];
    console.log('AI: Setting up interval with delay:', initialDelay, 'ms');
    aiInterval = setInterval(aiStep, initialDelay);
  } else {
    if(aiInterval) clearInterval(aiInterval);
    aiInterval = null;
    console.log('AI: Stopped and cleared interval');
    
    // Reset animation speed to default when auto-play is turned off
    currentSpeed = 2; // Medium
    if (debugSpeedSlider) {
      debugSpeedSlider.value = currentSpeed;
    }
    updateSpeedLabel();
    updateDebugSpeedLabel();
    updateAnimationSpeed();
  }
}

function updateSpeedLabel() {
  if (debugSpeedLabel) {
    const speedLabels = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Blazing'];
    debugSpeedLabel.textContent = speedLabels[currentSpeed];
  }
}

function updateAISpeed() {
  if (!aiEnabled) return;
  
  // Clear existing interval if it exists
  if (aiInterval) {
    clearInterval(aiInterval);
  }
  
  // Calculate new delay based on speed (0-4)
  // Speed 0 = Very Slow (2000ms), Speed 4 = Blazing (50ms)
  const delays = [2000, 1500, 1000, 500, 50];
  const newDelay = delays[currentSpeed];
  
  // Restart interval with new speed
  aiInterval = setInterval(aiStep, newDelay);
}

function updateAnimationSpeed() {
  // Calculate animation multiplier based on speed (0-4)
  // Speed 0 = Very Slow (3x slower), Speed 4 = Blazing (0x - instant, no animations)
  const multipliers = [3, 2, 1, 0.5, 0];
  
  // When speed is 4 (Blazing), set multiplier to 0 to disable animations
  const multiplier = multipliers[currentSpeed];
  
  // Update CSS custom properties for animation durations
  document.documentElement.style.setProperty('--animation-speed', multiplier);
  
  // Apply animation speed to all animated elements for instant animation support
  const animatedElements = document.querySelectorAll('.disc, .next-disc, .pole');
  animatedElements.forEach(el => {
    el.style.setProperty('--animation-speed', multiplier);
  });
  
  console.log(`Animation speed updated: ${multiplier} (speed level: ${currentSpeed})`);
}

function updateStackHeight() {
  // Stack height is now fixed at MAX_HEIGHT (10) - no more dynamic reduction
  // Base height varies by screen size for mobile responsiveness
  // Each slot needs: disc height + margin-top
  // 10 slots need: (disc height + margin) × 10 + pole padding
  let baseHeight = 542; // Desktop: 42px disc + 9px margin = 51px per slot, 10 slots = 510px + 32px padding = 542px
  
  // Check if we're on mobile and adjust height accordingly
  if (window.innerWidth <= 480) {
    // Extra small mobile: 26px disc + 4px margin = 30px per slot
    // 10 slots: 30px × 10 = 300px + 16px padding (8px top + 8px bottom) = 316px
    baseHeight = 316;
    console.log('Mobile (≤480px): Setting stack height to', baseHeight, 'px for 10 slots');
  } else if (window.innerWidth <= 768) {
    // Regular mobile: 30px disc + 6px margin = 36px per slot  
    // 10 slots: 36px × 10 = 360px + 24px padding (12px top + 12px bottom) = 384px
    baseHeight = 384;
    console.log('Mobile (≤768px): Setting stack height to', baseHeight, 'px for 10 slots');
  } else {
    console.log('Desktop: Setting stack height to', baseHeight, 'px for 10 slots');
  }
  
  // Update CSS custom property for stack height
  document.documentElement.style.setProperty('--stack-height', baseHeight + 'px');
  console.log('Updated --stack-height to', baseHeight, 'px');
}

function updateDebugPane() {
  if (debugScore) debugScore.textContent = score;
  if (debugGold) debugGold.textContent = gold;
  if (debugStacks) debugStacks.textContent = poles.length;
  if (debugCapacity) debugCapacity.textContent = currentStackCapacity;
  if (debugTarget) debugTarget.textContent = currentTargetBlockSize * 2;
  if (debugMaxBlock) debugMaxBlock.textContent = Math.max(...weights);
  if (debugBlocksDropped) debugBlocksDropped.textContent = blocksDropped;
  if (debugBombStatus) debugBombStatus.textContent = blocksDropped >= BOMB_DELAY_BLOCKS ? 'Enabled' : 'Disabled';
  if (debugStage) debugStage.textContent = currentStage;
}



// Debug pane wiring
function openDebugPane(){ 
  debugPane.classList.add('show'); 
  syncDebugControls();
}
function closeDebugPane(){ 
  debugPane.classList.remove('show'); 
  // Reset custom block mode when debug pane is closed
  customBlockMode = false;
  
  // Reset next block display to show "Queue" when debug pane is closed
  const nextBlockElement = document.getElementById('nextBlockValue');
  if (nextBlockElement) {
    nextBlockElement.textContent = 'Queue';
    nextBlockElement.removeAttribute('data-value');
  }
  
  console.log('Debug pane closed, custom block mode disabled');
}
debugClose.addEventListener('click', closeDebugPane);
debugPane.addEventListener('click', (e) => { if (e.target === debugPane) closeDebugPane(); });
window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && debugPane.classList.contains('show')) closeDebugPane(); });

// New Game Modal Functions
function openNewGameModal() {
  const newGameModal = document.getElementById('newGameModal');
  if (newGameModal) {
    newGameModal.classList.remove('hidden');
  }
}

function closeNewGameModal() {
  const newGameModal = document.getElementById('newGameModal');
  if (newGameModal) {
    newGameModal.classList.add('hidden');
  }
}

function handleNewGameConfirmation() {
  closeNewGameModal();
  resetGame(true);
}

function handleNewGameCancel() {
  closeNewGameModal();
}

function syncDebugControls() {
  // Sync auto-play state
  updateDebugAutoPlayDisplay();
  
  // Sync speed control
  if (debugSpeedSlider) {
    debugSpeedSlider.value = currentSpeed;
  }
  updateDebugSpeedLabel();
}

// Debug pane controls - Block grid interface
document.querySelectorAll('.block-item').forEach(blockItem => {
  blockItem.addEventListener('click', () => {
    // Remove previous selection
    document.querySelectorAll('.block-item').forEach(item => item.classList.remove('selected'));
    
    // Select this block
    blockItem.classList.add('selected');
    
    // Check if "No Block" is selected
    if (blockItem.dataset.value === 'none') {
      customBlockSize = null;
      customBlockMode = false;
      const nextBlockElement = document.getElementById('nextBlockValue');
      nextBlockElement.textContent = 'Queue';
      nextBlockElement.removeAttribute('data-value');
      console.log('No block selected - using queue');
    } else {
      // Update the custom block size
      const value = parseInt(blockItem.dataset.value);
      customBlockSize = value;
      
      // Update the display with number formatting for large values
      const displayValue = value >= 100000 ? formatNumber(value) : value;
      const nextBlockElement = document.getElementById('nextBlockValue');
      nextBlockElement.textContent = displayValue;
      nextBlockElement.setAttribute('data-value', value);
      
      // Enable custom block mode
      customBlockMode = true;
      
      console.log(`Selected block: ${value}`);
    }
  });
});

bombToggle.addEventListener('change', (e) => {
  customBlockBomb = e.target.checked;
  bombStatus.textContent = customBlockBomb ? 'Yes' : 'No';
});

// Gold grant button
grantGoldBtn.addEventListener('click', () => {
  gold += 1000;
  // Update gold display
  updateGoldDisplay();
  // Update bomb conversion button state
  updateBombButtonIfGoldChanged();
  // Update trash button state
  updateTrashButtonIfGoldChanged();
  
  // Save game state after granting gold
  console.log('🔄 Triggering save after granting gold...');
  saveGameState();
  
  console.log(`Granted 1000 gold. New balance: ${gold}`);
});

// Score grant button
grantScoreBtn.addEventListener('click', () => {
  score += 1000;
  // Update score display
  updateScoreDisplay();
  
  // Save game state after granting score
  console.log('🔄 Triggering save after granting score...');
  saveGameState();
  
  console.log(`Granted 1000 score. New score: ${score}`);
});

// Debug auto-play controls
debugAiToggle.addEventListener('click', () => {
  toggleAI(!aiEnabled);
  updateDebugAutoPlayDisplay();
});

debugSpeedSlider.addEventListener('input', (e) => {
  currentSpeed = parseInt(e.target.value);
  updateSpeedLabel();
  updateDebugSpeedLabel();
  updateAISpeed();
  updateAnimationSpeed();
});

function updateDebugAutoPlayDisplay() {
  debugAiToggle.textContent = aiEnabled ? 'Auto Play: On' : 'Auto Play: Off';
  debugAiToggle.classList.toggle('active', aiEnabled);
}

function updateDebugSpeedLabel() {
  const speedLabels = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Blazing'];
  debugSpeedLabel.textContent = speedLabels[currentSpeed];
}

function colorFor(w){
  const colors = [
    '#cfef08', // lime green - value 1 (subtle)
    '#10B981', // emerald-500 - value 2 (soft green)
    '#2563EB', // blue-600 - value 4 (medium blue)
    '#7C3AED', // violet-600 - value 8 (violet - midpoint between blue and dark purple)
    '#581C87', // violet-800 - value 16 (dark purple)
    '#D946EF', // fuchsia-500 - value 32 (bright fuchsia - clearly different from 16)
    '#EC4899', // pink-500 - value 64 (hot pink)
    '#e86758', // red-500 - value 128 (intense red)
    '#F59E0B', // amber-500 - value 256 (bright amber)
    '#ea580c', // orange-600 - value 512 (vibrant orange)
    '#dc2626', // red-600 - value 1024 (bright red)
    '#9d174d', // rose-700 - value 2048 (darker magenta)
    '#000',    // black - value 4096
    '#64748b', // gray - value 8192
    '#fff'     // white - value 16384
  ];
  
  const log2w = Math.log2(w);
  const colorIndex = Math.min(Math.floor(log2w), colors.length - 1);
  return colors[colorIndex];
}

function labelForPiece(piece){
  if (piece && piece.bomb) {
    // Format bomb text for large numbers (6+ digits)
    const displayValue = piece.w >= 100000 ? formatNumber(piece.w) : piece.w;
    return `<div class="bomb-content"><div class="bomb-emoji">💣</div><div class="bomb-text">${displayValue}</div></div>`;
  }
  // Format regular block text for large numbers (6+ digits)
  return piece.w >= 100000 ? formatNumber(piece.w) : String(piece.w);
}

function getTextColorFor(w){
  // Return black text for lime green block (value 1) and blocks >= 16384, white for others
  return (w === 1 || w >= 16384) ? '#000000' : '#ffffff';
}

function render(){
  // build poles
  gameDiv.innerHTML = '';
  
  // Safety check: ensure we only have exactly 4 poles
  if (poles.length !== 4) {
    console.warn(`Warning: Expected 4 poles but found ${poles.length}. Resetting to 4 poles.`);
    poles = [[],[],[],[]];
  }
  
  console.log(`Rendering ${poles.length} poles:`, poles.map(p => p.length));
  
  poles.forEach((pole, idx) => {
    const poleDiv = document.createElement('div');
    const isAtCapacity = pole.length >= currentStackCapacity;
    const playable = canPlaceOnPole(nextQueue[0], pole);
    const isDisabled = isAtCapacity && !playable;
    
    poleDiv.className = 'pole' + (isDisabled ? ' full' : '');
    
    // Preserve the no-hover state if we're currently placing
    if (placing) {
      poleDiv.classList.add('no-hover');
      poleDiv.style.pointerEvents = 'none';
    }
    
    // If stack is disabled (full and can't merge), disable interactions
    if (isDisabled) {
      poleDiv.classList.add('no-hover');
      poleDiv.style.pointerEvents = 'none';
      poleDiv.style.cursor = 'not-allowed';
    }
    
    poleDiv.setAttribute('role', 'button');
    poleDiv.tabIndex = isDisabled ? -1 : 0;
    poleDiv.setAttribute('aria-label', `Stack ${idx + 1}, contains ${pole.length} blocks${isAtCapacity ? (playable ? ', merge available' : ', blocked') : ''}`);
    poleDiv.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (!isDisabled) {
          placeOnPole(idx);
        }
      }
    });
    // existing discs (no animation class)
    pole.forEach(p => {
      const d = document.createElement('div');
      d.className = 'disc';
      if (p.bomb) {
        d.innerHTML = labelForPiece(p);
      } else {
        d.textContent = labelForPiece(p);
      }
      d.style.background = p.bomb ? '#000' : colorFor(p.w);
      d.style.color = p.bomb ? '#fff' : getTextColorFor(p.w);
      
      // Add dynamic gold glow effect for white blocks (16384+)
      if (!p.bomb && p.w >= 16384) {
        d.classList.add('white-block-glow');
        
        // Calculate glow intensity based on block value
        const log2Value = Math.log2(p.w);
        const baseLog2 = Math.log2(16384); // 14
        const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
        
        // Set CSS custom properties for dynamic glow
        d.style.setProperty('--glow-intensity', intensityMultiplier.toString());
        d.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
        d.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
        d.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
        d.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
        d.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
      }
      
      poleDiv.appendChild(d);
    });
    
    // Only add click handler if stack is not disabled
    if (!isDisabled) {
      poleDiv.addEventListener('click', () => placeOnPole(idx));
      
      // Add touch event handling for better mobile experience
      let touchStartTime = 0;
      let touchStartY = 0;
      
      poleDiv.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        touchStartY = e.touches[0].clientY;
        // Prevent default to avoid double-tap zoom on mobile
        e.preventDefault();
      }, { passive: false });
      
      poleDiv.addEventListener('touchend', (e) => {
        const touchEndTime = Date.now();
        const touchEndY = e.changedTouches[0].clientY;
        const touchDuration = touchEndTime - touchStartTime;
        const touchDistance = Math.abs(touchEndY - touchStartY);
        
        // Only trigger placement if it's a quick tap (not a swipe) and close to start position
        if (touchDuration < 300 && touchDistance < 20) {
          placeOnPole(idx);
        }
      });
      
      // Clear hover state when touch moves (prevents stuck highlights)
      poleDiv.addEventListener('touchmove', (e) => {
        // If touch moves significantly, don't trigger placement
        const currentY = e.touches[0].clientY;
        if (Math.abs(currentY - touchStartY) > 20) {
          // Touch moved too much, this won't be a valid tap
        }
      });
      
      // Handle touch cancellation
      poleDiv.addEventListener('touchcancel', () => {
        // Touch was cancelled, do nothing
      });
    }
    
    gameDiv.appendChild(poleDiv);
    
    // Apply current animation speed to the new pole
    poleDiv.style.setProperty('--animation-speed', document.documentElement.style.getPropertyValue('--animation-speed'));
  });
  
  // Final safety check: verify we only have 4 pole elements
  const renderedPoles = gameDiv.querySelectorAll('.pole');
  if (renderedPoles.length !== 4) {
    console.error(`Error: Rendered ${renderedPoles.length} pole elements instead of 4! Clearing and re-rendering...`);
    gameDiv.innerHTML = '';
    // Force a single re-render
    setTimeout(() => render(), 0);
    return;
  }
  
  console.log(`Successfully rendered ${renderedPoles.length} poles`);
  
  // update score display in game info
  updateScoreDisplay();
  
  // update gold display in game info
  updateGoldDisplay();
  
  // Update bomb conversion button state
  updateBombButtonIfGoldChanged();
  // Update trash button state
  updateTrashButtonIfGoldChanged();
  
  // update next stage display in bottom actions
  const targetBlockEl = document.getElementById('targetBlock');
  if (targetBlockEl) {
    // Show the target block size (what you get after merging)
    const targetValue = currentTargetBlockSize * 2;
    targetBlockEl.textContent = targetValue;
    targetBlockEl.setAttribute('data-value', targetValue);
  }
  
  updateDebugPane();
  
  renderNext();
}

function renderNext(){
  nextContainer.innerHTML = '';
  nextQueue.forEach((p, idx) => {
    const d = document.createElement('div');
    d.className = 'next-disc' + (idx === 0 ? ' current' : '');
    if (p.bomb) {
      d.innerHTML = labelForPiece(p);
    } else {
      d.textContent = labelForPiece(p);
    }
    d.style.background = p.bomb ? '#000' : colorFor(p.w);
    d.style.color = p.bomb ? '#fff' : getTextColorFor(p.w);
    
    // Add dynamic gold glow effect for white blocks (16384+)
    if (!p.bomb && p.w >= 16384) {
      d.classList.add('white-block-glow');
      
      // Calculate glow intensity based on block value
      const log2Value = Math.log2(p.w);
      const baseLog2 = Math.log2(16384); // 14
      const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
      
      // Set CSS custom properties for dynamic glow
      d.style.setProperty('--glow-intensity', intensityMultiplier.toString());
      d.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
      d.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
      d.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
      d.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
      d.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
    }
    
    nextContainer.appendChild(d);
    
    // Apply current animation speed to the new next disc
    d.style.setProperty('--animation-speed', document.documentElement.style.getPropertyValue('--animation-speed'));
  });
}

function placeOnPole(idx){
  console.log('placeOnPole called with idx:', idx, 'placing:', placing);
  if (placing) { 
    console.log('Placement in progress, ignoring click for pole:', idx);
    return; // Simply ignore clicks during placement instead of queueing
  }
  const pole = poles[idx];
  
  // Additional safety check: ensure this stack can actually accept the next piece
  const isAtCapacity = pole.length >= currentStackCapacity;
  const playable = canPlaceOnPole(nextQueue[0], pole);
  if (isAtCapacity && !playable) {
    console.log('Stack is full and cannot merge, ignoring click');
    return;
  }
  
  // Check if custom block mode is active AND debug pane is open
  let nextPiece;
  let wasCustomBlock = false;
  if (customBlockMode && customBlockSize && debugPane && debugPane.classList.contains('show')) {
    nextPiece = { w: customBlockSize, bomb: customBlockBomb };
    wasCustomBlock = true;
    // Custom block mode only works when debug pane is visible and a block is selected
  } else {
    nextPiece = nextQueue[0];
  }
  
  if (pole.length >= currentStackCapacity && (!topOf(pole) || topOf(pole).w !== nextPiece.w)) return;
  placing = true;
  lastPlacementTime = Date.now();

  // Disable hover effects on all poles during placement
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = 'none';
    poleDiv.classList.add('no-hover');
    console.log('Added no-hover class to pole:', poleDiv);
    console.log('Pole classes after adding no-hover:', poleDiv.className);
    console.log('Pole computed pointer-events:', window.getComputedStyle(poleDiv).pointerEvents);
  });

  // append an animated disc to the pole DOM, without modifying the data model yet
  const poleDiv = gameDiv.children[idx];
  const animDisc = document.createElement('div');
  animDisc.className = 'disc animate';
  if (nextPiece.bomb) {
    animDisc.innerHTML = labelForPiece(nextPiece);
  } else {
    animDisc.textContent = labelForPiece(nextPiece);
  }
  animDisc.style.background = nextPiece.bomb ? '#000' : colorFor(nextPiece.w);
  animDisc.style.color = nextPiece.bomb ? '#fff' : getTextColorFor(nextPiece.w);
  
  // Add dynamic gold glow effect for white blocks (16384+)
  if (!nextPiece.bomb && nextPiece.w >= 16384) {
    animDisc.classList.add('white-block-glow');
    
    // Calculate glow intensity based on block value
    const log2Value = Math.log2(nextPiece.w);
    const baseLog2 = Math.log2(16384); // 14
    const intensityMultiplier = Math.max(1, (log2Value - baseLog2 + 1) * 0.5);
    
    // Set CSS custom properties for dynamic glow
    animDisc.style.setProperty('--glow-intensity', intensityMultiplier.toString());
    animDisc.style.setProperty('--glow-spread', Math.max(8, 8 * intensityMultiplier) + 'px');
    animDisc.style.setProperty('--glow-opacity', Math.min(1, 0.6 * intensityMultiplier).toString());
    animDisc.style.setProperty('--border-width', Math.max(2, 2 * intensityMultiplier) + 'px');
    animDisc.style.setProperty('--border-opacity', Math.min(1, 0.8 * intensityMultiplier).toString());
    animDisc.style.setProperty('--inset-opacity', Math.min(1, 0.1 * intensityMultiplier).toString());
  }
  
  // Apply current animation speed to the animated disc
  animDisc.style.setProperty('--animation-speed', document.documentElement.style.getPropertyValue('--animation-speed'));
  
  // Apply current stack height to the animated disc
  animDisc.style.setProperty('--stack-height', document.documentElement.style.getPropertyValue('--stack-height'));
  
  // Let CSS handle the mobile-specific drop animations
  // The CSS media queries will automatically apply the correct animation
  
  poleDiv.appendChild(animDisc);

  // Check if animations are disabled (speed = 0)
  const animationSpeed = parseFloat(document.documentElement.style.getPropertyValue('--animation-speed') || '1');
  const isInstantAnimation = animationSpeed === 0;

  // after drop animation, commit, then animate merge cascade step-by-step
  const handlePlacement = async () => {
    // Add safety timeout to prevent hanging
    const safetyTimeout = setTimeout(() => {
      if (placing) {
        console.error('Placement safety timeout - forcing completion');
        placing = false;
        
        render();
        checkGameOver();
      }
    }, 10000); // 10 second safety timeout
    
    try {
      poles[idx].push(nextPiece);
      // scoring: add only the dropped piece's weight
      score += nextPiece.w;
      updateScoreDisplay();
      
      // Save game state after placing a block
      console.log('🔄 Triggering save after block placement...');
      saveGameState();
      
      // Add pulse animation to the score display
      const scoreDisplay = document.querySelector('.score-value');
      if (scoreDisplay) {
        scoreDisplay.classList.add('pulse');
        setTimeout(() => {
          scoreDisplay.classList.remove('pulse');
        }, 300);
      }
      
      // Increment blocks dropped counter (only for regular pieces, not custom debug pieces)
      if (!wasCustomBlock) {
        blocksDropped++;
      }
      
      // Only advance the queue if we used a regular piece, not a custom one
      if (!wasCustomBlock) {
        // animate next queue: consume current, shift others, append new
        await animateNextQueueAdvance(); // false = queue not yet modified
      }
      
      render();
      try {
        await animateMergeCascade(idx);
        
        // Only set placing to false after merge cascade completes
        placing = false;
        console.log('Placement completed, placing set to false');
      } catch (error) {
        console.error('Merge cascade error:', error);
        // Force reset placing flag on error to prevent game freeze
        placing = false;
        console.log('Placement error - forcing placing to false');
        
        // Re-enable hover effects and pointer events after placing is false
        const allPoles = Array.from(gameDiv.children);
        allPoles.forEach(poleDiv => {
          poleDiv.style.pointerEvents = '';
          poleDiv.classList.remove('no-hover');
          console.log('Removed no-hover class from pole (error):', poleDiv);
        });
      }
      render();
      checkGameOver();
      

      
    } finally {
      clearTimeout(safetyTimeout);
    }
  };

  // If animations are disabled or very fast, execute placement immediately
  if (isInstantAnimation || animationSpeed <= 0.5) {
    console.log(`Fast/instant animation detected (${animationSpeed}), executing placement immediately`);
    // Remove the animated disc since we don't need it
    animDisc.remove();
    // Execute placement logic immediately
    handlePlacement();
  } else {
    // Wait for animation to complete
    console.log(`Normal animation speed (${animationSpeed}), waiting for animationend event`);
    animDisc.addEventListener('animationend', handlePlacement, { once: true });
  }
}

function waitForAnimation(element){
  return new Promise(resolve => {
    // Check if animations are disabled (speed = 0)
    const animationSpeed = element.style.getPropertyValue('--animation-speed') || 
                          document.documentElement.style.getPropertyValue('--animation-speed') || '1';
    const speedValue = parseFloat(animationSpeed);
    
    if (speedValue === 0) {
      console.log('Animations disabled, resolving immediately');
      // Add a small delay to ensure DOM updates are processed
      setTimeout(resolve, 10);
      return;
    }
    
    // For very fast animations (speed <= 0.5), add a small delay to ensure proper timing
    if (speedValue <= 0.5) {
      console.log(`Very fast animation detected (${speedValue}), adding delay`);
      setTimeout(resolve, Math.max(50, speedValue * 100)); // At least 50ms delay
      return;
    }
    
    // Add multiple event listeners to catch different animation end events
    const handleAnimationEnd = () => {
      console.log('Animation ended for element:', element);
      resolve();
    };
    
    element.addEventListener('animationend', handleAnimationEnd, { once: true });
    element.addEventListener('webkitAnimationEnd', handleAnimationEnd, { once: true });
    
    // Also check if animation is actually running
    const computedStyle = window.getComputedStyle(element);
    const animationName = computedStyle.animationName;
    
    if (animationName === 'none') {
      console.log('No animation detected, resolving immediately');
      resolve();
      return;
    }
    
    // Fallback timeout to prevent hanging
    setTimeout(() => {
      console.log('Animation timeout fallback triggered for:', animationName);
      resolve();
    }, 1500); // 1.5 second timeout
  });
}

// Function to check if any animations are currently running
function areAnyAnimationsRunning() {
  // Check all poles for running animations
  const allPoles = Array.from(gameDiv.children);
  for (const pole of allPoles) {
    const discs = pole.querySelectorAll('.disc');
    for (const disc of discs) {
      const computedStyle = window.getComputedStyle(disc);
      const animationName = computedStyle.animationName;
      if (animationName !== 'none') {
        console.log('Found running animation on disc:', animationName, disc);
        return true;
      }
    }
  }
  
  // Check next queue for running animations
  const nextItems = nextContainer.querySelectorAll('.next-disc');
  for (const item of nextItems) {
    const computedStyle = window.getComputedStyle(item);
    const animationName = computedStyle.animationName;
    if (animationName !== 'none') {
      console.log('Found running animation on next item:', animationName, item);
      return true;
    }
  }
  
  return false;
}

async function animateMergeCascade(index){
  console.log('Starting merge cascade for pole:', index);
  
  // Global timeout to prevent infinite hanging
  const globalTimeout = setTimeout(() => {
    console.error('Merge cascade global timeout - forcing completion');
    throw new Error('Merge cascade timeout');
  }, 5000); // 5 second global timeout
  
  try {
    let iterationCount = 0;
    const maxIterations = 20; // Prevent infinite loops
    let mergeCount = 0; // Track number of merges in this cascade for gold calculation
    
    while (true){
      iterationCount++;
      if (iterationCount > maxIterations) {
        console.error('Merge cascade exceeded max iterations, forcing completion');
        break;
      }
      
      const poleArr = poles[index];
      // find top-first adjacent equal pair
      let pairIndex = -1;
      for (let i = poleArr.length - 1; i > 0; i--) {
        if (poleArr[i] && poleArr[i - 1] && poleArr[i].w === poleArr[i - 1].w) { pairIndex = i; break; }
      }
      if (pairIndex === -1) {
        console.log('No more merges found, breaking');
        break;
      }
    
    console.log('Found merge pair at index:', pairIndex, 'weights:', poleArr[pairIndex].w, poleArr[pairIndex-1].w);

    // animate both discs merging out with enhanced visual effects
    const poleDiv = gameDiv.children[index];
    const discs = poleDiv.querySelectorAll('.disc');
    const topEl = discs[pairIndex];
    const belowEl = discs[pairIndex - 1];
    if (!topEl || !belowEl) break;
    
    try {
      // Add glow effect to both discs before merging
      topEl.classList.add('merging');
      belowEl.classList.add('merging');
      
      // Stagger the merge-out animations slightly for better visual flow
      topEl.classList.add('merge-out');
      await new Promise(resolve => setTimeout(resolve, 25)); // Reduced delay for snappier effect
      belowEl.classList.add('merge-out');
      
      // Wait for both animations to complete with error handling
      await Promise.all([
        waitForAnimation(topEl).catch(err => console.log('Top animation error:', err)),
        waitForAnimation(belowEl).catch(err => console.log('Bottom animation error:', err))
      ]);
      
      // Remove glow effects
      topEl.classList.remove('merging');
      belowEl.classList.remove('merging');
    } catch (error) {
      console.log('Merge animation error:', error);
      // Clean up classes in case of error
      topEl.classList.remove('merging', 'merge-out');
      belowEl.classList.remove('merging', 'merge-out');
    }

    // commit merge to data model
    const a = poleArr[pairIndex];
    const b = poleArr[pairIndex - 1];
    const newW = a.w * 2; // weights are equal here
    const isBombMerge = a.bomb || b.bomb;
    poleArr.splice(pairIndex - 1, 2, { w: newW, bomb: isBombMerge });
    
    // Earn gold for this merge (increases by 1 for each merge in the cascade, multiplied by current stage)
    mergeCount++;
    const baseGoldEarned = mergeCount;
    // Stage 1: 1x multiplier, Stage 2+: 10x multiplier
    const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
    const goldEarned = baseGoldEarned * stageMultiplier;
    gold += goldEarned;
    updateGoldDisplay();
    console.log(`Merge ${mergeCount}: Earned ${goldEarned} gold (${baseGoldEarned} × ${stageMultiplier}x multiplier) (Total: ${gold})`);
    
    // Show gold earned animation
    showGoldEarned(goldEarned);
    
    // Update bomb conversion button state
    updateBombButtonIfGoldChanged();
    // Update trash button state
    updateTrashButtonIfGoldChanged();
    
    // Save game state after merge and gold earning
    console.log('🔄 Triggering save after merge...');
    saveGameState();

    if (isBombMerge){
      // Bomb merge - clear the entire stack
      await animateClearPoleWithFallingBlock(index, pairIndex - 1, newW);
      // after animation, pole is cleared; continue which will break
      continue;
    }
    
      // Check if this merge unlocks a new stack (stage progression)
  if (newW === currentTargetBlockSize * 2){
    console.log(`Stage progression triggered! Merged to ${newW}, target was ${currentTargetBlockSize}`);
    // Stage progression: keep the merged block, clear the rest of the stack
    await animateStageProgression(index, pairIndex - 1, newW);
    // Check if we should add a new stack
    checkForNewStack();
    // after animation, pole has only the merged block; continue which will break
    continue;
  }

    // Check if this merge unlocks a new block size for future drops
    checkForNewBlockSize(newW);
    
    // re-render and pop-in the new merged disc with enhanced effects
    render();
    const poleDivAfter = gameDiv.children[index];
    const discsAfter = poleDivAfter.querySelectorAll('.disc');
    const mergedEl = discsAfter[pairIndex - 1];
    if (mergedEl){
      try {
        // Add glow effect for the new merged block
        mergedEl.classList.add('merging');
        mergedEl.classList.add('merge-in');
        await waitForAnimation(mergedEl);
        mergedEl.classList.remove('merge-in');
        mergedEl.classList.remove('merging');
      } catch (error) {
        console.log('Merge-in animation error:', error);
        // Clean up classes in case of error
        mergedEl.classList.remove('merging', 'merge-in');
      }
    }
    
    console.log('Merge iteration completed, checking for more merges...');
    
    // Re-render to ensure DOM is up to date before next iteration
    // Note: This render call is now conditional to prevent excessive rendering
    if (gameDiv.children.length !== 4) {
      console.warn('Pole count mismatch detected, re-rendering...');
      render();
    }
  }
  
  console.log('Merge cascade completed for pole:', index);
  
  // Re-enable hover effects and pointer events after the cascade is complete
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = '';
    poleDiv.classList.remove('no-hover');
    console.log('Re-enabled hover effects for pole:', poleDiv);
  });
  
  } finally {
    clearTimeout(globalTimeout);
  }
}

function checkGameOver(){
  if (!hasAnyMove(nextQueue[0])){
    if (aiEnabled) toggleAI(false);
    showGameOver();
  }
}

function showGameOver(){
  // Show game over button overlay centered on screen with fade-in effect
  const gameOverButton = document.getElementById('gameOverButton');
  if (gameOverButton) {
    // Small delay to make the fade-in more noticeable
    setTimeout(() => {
      gameOverButton.classList.add('show');
    }, 200);
  }
  
  // Add glowing effect to the + button to guide user to start new game
  const addBtn = document.getElementById('addBtn');
  if (addBtn) {
    addBtn.classList.add('game-over-glow');
  }
  
  // Reset bomb selection state when game over is reached
  bombSelected = false;
  
  // Note: Pole interactions are no longer disabled to allow players to examine the final state
  
  // Save final game state when game over is reached
  console.log('🔄 Triggering final save at game over...');
  saveGameState();
}



function resetGame(isFreshGame = true){
  // Hide game over button overlay
  const gameOverButton = document.getElementById('gameOverButton');
  if (gameOverButton) {
    gameOverButton.classList.remove('show');
  }
  
  // Remove glowing effect from the + button
  const addBtn = document.getElementById('addBtn');
  if (addBtn) {
    addBtn.classList.remove('game-over-glow');
  }
  
  poles = [[],[],[],[]];
  score = 0;
  gold = 0; // Reset gold counter
  blocksDropped = 0; // Reset blocks dropped counter
  currentTargetBlockSize = STARTING_BLOCK_SIZE; // Reset target block size
  currentStackCapacity = MAX_HEIGHT; // Reset stack capacity
  currentStage = 1; // Reset stage counter
  
  // Only reset button costs if this is a fresh game (not a UI reset)
  if (isFreshGame) {
    // Reset bomb conversion button state
    bombConversionCost = 25;
    bombConversionPresses = 0;
    lastGoldAmount = 0; // Reset tracked gold amount to force button state update
    bombSelected = false; // Reset bomb selection state
    previousBombCost = 25; // Reset previous bomb cost
    
    // Reset trash button state
    trashButtonCost = 25;
    trashButtonPresses = 0;
  }
  
  // Update cost displays after reset (only if costs were actually reset)
  if (isFreshGame) {
    if (bombCostEl) {
      bombCostEl.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostEl) {
      trashCostEl.textContent = formatNumber(trashButtonCost);
    }
    if (bombCostElMobile) {
      bombCostElMobile.textContent = formatNumber(bombConversionCost);
    }
    if (trashCostElMobile) {
      trashCostElMobile.textContent = formatNumber(trashButtonCost);
    }
  }
  
  // Reset weights and probabilities to initial state
  weights = [1, 2];
  // Let updateProbabilityDistribution calculate the correct initial probabilities
  updateProbabilityDistribution();
  
  nextQueue = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
  placing = false;
  
  // Re-enable hover effects and pointer events on all poles
  const allPoles = Array.from(gameDiv.children);
  allPoles.forEach(poleDiv => {
    poleDiv.style.pointerEvents = '';
    poleDiv.classList.remove('no-hover');
  });
  
  // Reset custom block mode
  customBlockMode = false;
  
  // Reset next block display to show "Queue"
  const nextBlockElement = document.getElementById('nextBlockValue');
  if (nextBlockElement) {
    nextBlockElement.textContent = 'Queue';
    nextBlockElement.removeAttribute('data-value');
  }
  
  // Reset speed to default (Medium)
  currentSpeed = 2;
  updateAnimationSpeed();
  
  updateStackHeight();
  updateScoreDisplay();
  updateGoldDisplay();
  render();
  
  // Clear saved game after reset
  clearGameSave();
}

// ------------------
// AI logic: simplified to focus on core priorities:
// 1. MERGING - If a merge can be made, do it immediately
// 2. CLEAN STACKS - Place blocks on next size up (16 on 32, 8 on 16, etc.)
// 3. NEXT CLOSEST - Place on closest larger size when optimal isn't available
// 4. BOMB STRATEGY - Clean up messy stacks, avoid disrupting valuable ones
// 5. MINIMAL DISRUPTION - Only disrupt when necessary, prefer empty poles
// ------------------
function topOf(pole){
  return pole.length === 0 ? null : pole[pole.length - 1];
}

function canPlaceOnPole(pieceOrWeight, pole){
  const weight = typeof pieceOrWeight === 'number' ? pieceOrWeight : pieceOrWeight.w;
  const top = topOf(pole);
  return pole.length < currentStackCapacity || (top && top.w === weight);
}

function hasAnyMove(pieceOrWeight){
  return poles.some(p => canPlaceOnPole(pieceOrWeight, p));
}

async function animateNextQueueAdvance(queueAlreadyModified = false){
  // add consume animation to current
  const items = nextContainer.querySelectorAll('.next-disc');
  const current = items[0];
  const second = items[1];
  const third = items[2];
  if (current) current.classList.add('consume-out');
  if (second) second.classList.add('shift-left');
  if (third) third.classList.add('shift-left');

  // wait for ALL animations to complete before proceeding
  const animations = [];
  if (current) animations.push(waitForAnimation(current));
  if (second) animations.push(waitForAnimation(second));
  if (third) animations.push(waitForAnimation(third));
  
  // Wait for all animations to complete
  await Promise.all(animations);

  // Only update queue data if it hasn't already been modified
  if (!queueAlreadyModified) {
    // Reset bomb selection state when the queue advances (bomb was placed)
    bombSelected = false;
    
    nextQueue.shift();
    nextQueue.push(getRandomPiece());
  }
  
  renderNext();
  
  // Update button states since queue changed
  updateBombButtonIfGoldChanged();
  updateTrashButtonIfGoldChanged();
}

function getElementPageRect(el){
  const r = el.getBoundingClientRect();
  return { left: r.left + window.scrollX, top: r.top + window.scrollY, width: r.width, height: r.height };
}



async function animateStageProgression(index, mergedIndex, weight){
  // Render so the merged block exists in the DOM
  render();
  const poleDiv = gameDiv.children[index];
  const discs = poleDiv.querySelectorAll('.disc');
  const mergedEl = discs[mergedIndex];
  if(!mergedEl){
    poles[index] = [];
    render();
    return;
  }

  // Let the new block behave like a normal merge result first
  mergedEl.classList.add('merge-in');
  await waitForAnimation(mergedEl);
  mergedEl.classList.remove('merge-in');

  // Keep only the merged block, clear everything else
  const mergedBlock = poles[index][mergedIndex];
  poles[index] = [mergedBlock]; // Keep only the merged block
  
  // Animate clearing of other blocks (but not the merged one)
  const blocksToClear = Array.from(poleDiv.querySelectorAll('.disc')).filter((_, i) => i !== mergedIndex);
  blocksToClear.forEach(d => d.classList.add('clear-out'));
  await Promise.all(blocksToClear.map(d => waitForAnimation(d)));

  // Re-render to show the cleared stack with only the merged block
  // Only render if we still have exactly 4 poles
  if (gameDiv.children.length === 4) {
    render();
  } else {
    console.warn('Pole count mismatch in stage progression, skipping render');
  }
}

async function animateClearPoleWithFallingBlock(index, mergedIndex, weight){
  // Render so the merged block exists in the DOM
  render();
  const poleDiv = gameDiv.children[index];
  const discs = poleDiv.querySelectorAll('.disc');
  const mergedEl = discs[mergedIndex];
  if(!mergedEl){
    poles[index] = [];
    render();
    return;
  }

  // Calculate gold reward for bomb clear based on number of blocks cleared and current stage
  const blocksCleared = discs.length;
  // Gold increases by 1 for each block cleared (like cascade merges), multiplied by current stage
  // Stage 1: 1x multiplier, Stage 2+: 10x multiplier
  const stageMultiplier = currentStage === 1 ? 1 : Math.pow(10, currentStage - 1);
  const totalGoldEarned = (blocksCleared * (blocksCleared + 1) / 2) * stageMultiplier;
  
  // Add total gold to player's balance
  gold += totalGoldEarned;
  console.log(`Bomb clear: Cleared ${blocksCleared} blocks, earned ${totalGoldEarned} gold (sum of 1 to ${blocksCleared} × ${stageMultiplier}x multiplier) (Total: ${gold})`);
  
  // Show individual gold animations for each block cleared (like cascade merges)
  for (let i = 0; i < blocksCleared; i++) {
    const blockGoldEarned = (i + 1) * stageMultiplier; // Gold increases by 1 for each block, multiplied by current stage
    setTimeout(() => {
      showGoldEarned(blockGoldEarned);
    }, i * 100); // Stagger each animation by 100ms for visual effect
  }
  
  // Update gold display
  updateGoldDisplay();
  
  // Update bomb conversion button state
  updateBombButtonIfGoldChanged();
  // Update trash button state
  updateTrashButtonIfGoldChanged();



  // Let the new block behave like a normal merge result first
  mergedEl.classList.add('merge-in');
  await waitForAnimation(mergedEl);
  mergedEl.classList.remove('merge-in');

  // Create a shockwave ripple effect that propagates through the stack
  const allDiscs = Array.from(poleDiv.querySelectorAll('.disc'));
  
  // Check if animations are disabled (speed = 0)
  const animationSpeed = parseFloat(document.documentElement.style.getPropertyValue('--animation-speed') || '1');
  const isInstantAnimation = animationSpeed === 0;
  
  if (isInstantAnimation) {
    // Instant animation - immediately hide all blocks
    allDiscs.forEach(d => {
      d.style.transform = 'scale(0.8) translateY(0)';
      d.style.opacity = '0';
      d.style.filter = 'brightness(0.8) saturate(0.9)';
    });
  } else {
    // Start the ripple from the merged block (bomb location) and propagate outward in both directions
    const bombIndex = mergedIndex; // The bomb merge location
    
    for (let i = 0; i < allDiscs.length; i++) {
      const disc = allDiscs[i];
      // Calculate distance from bomb location for wave propagation
      const distanceFromBomb = Math.abs(i - bombIndex);
      // Add a small delay to create the wave effect, starting from bomb location
      const delay = distanceFromBomb * 60; // 60ms delay per block distance for the ripple effect
      
      setTimeout(() => {
        disc.classList.add('bomb-ripple');
      }, delay);
    }
    
    // Wait for the entire ripple animation to complete
    const totalAnimationTime = Math.max(...Array.from({length: allDiscs.length}, (_, i) => 
      Math.abs(i - bombIndex) * 60 + 500
    )); // Max delay + 500ms animation duration
    await new Promise(resolve => setTimeout(resolve, totalAnimationTime));
    
    // Clean up the ripple classes
    allDiscs.forEach(d => d.classList.remove('bomb-ripple'));
  }

  // Clear pole and re-render
  poles[index] = [];
  render();
}

function choosePoleFor(pieceOrWeight){
  console.log('choosePoleFor called with:', pieceOrWeight);
  let avail = poles.map((p,i)=> ({p,i})).filter(x=> canPlaceOnPole(pieceOrWeight, x.p));
  console.log('Available poles:', avail);
  if(avail.length === 0) {
    console.log('No available poles found');
    return null;
  }
  
  const piece = typeof pieceOrWeight === 'number' ? { w: pieceOrWeight, bomb: false } : pieceOrWeight;
  const isBomb = piece.bomb;
  
  // Helper function to check if a stack is "messy" (order disrupted)
  function isStackMessy(pole) {
    if (pole.length < 2) return false;
    for (let i = pole.length - 1; i > 0; i--) {
      if (pole[i].w >= pole[i-1].w) return true; // Order is disrupted
    }
    return false;
  }
  
  // Helper function to get stack height
  function getStackHeight(pole) {
    return pole.length;
  }
  
  // Helper function to get total point value of a stack
  function getStackValue(pole) {
    return pole.reduce((sum, disc) => sum + disc.w, 0);
  }
  
  // Helper function to check if placing this piece would create a merge
  function wouldCreateMerge(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w === piece.w;
  }
  
  // Helper function to check if placing this piece would be on a block exactly 1 size above
  function wouldBeOnExactSize(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w === piece.w * 2;
  }
  
  // Helper function to check if placing this piece would be on a larger block (but not exact size)
  function wouldBeOnLargerBlock(pole, piece) {
    if (pole.length === 0) return false;
    const top = pole[pole.length - 1];
    return top.w > piece.w;
  }
  
  // Check for bomb in queue (special case 1.5)
  const hasBombInQueue = nextQueue.some(p => p.bomb);
  const isBombMatch = hasBombInQueue && nextQueue.some(p => p.bomb && p.w === piece.w);
  
  if (!isBomb) {
    // NORMAL BLOCKS LOGIC
    
    // Priority 1: Merges (100% override)
    const mergeOptions = avail.filter(x => wouldCreateMerge(x.p, piece));
    if (mergeOptions.length > 0) {
      return mergeOptions[0].i;
    }
    
    // Priority 1.5: Avoid placing normal blocks on stacks with bombs anywhere in them
    // This prevents cutting off bombs from being able to merge and clear the stack
    const bombAvoidanceOptions = avail.filter(x => {
      if (x.p.length === 0) return true; // Empty stack is fine
      
      // Check if there's a bomb anywhere in the stack
      const hasBombInStack = x.p.some(disc => disc.bomb);
      
      if (hasBombInStack) {
        // If there's a bomb in the stack, only allow placement if:
        // 1. The block is smaller than the bomb it would be placed on, OR
        // 2. We're placing on an empty stack (which shouldn't happen here, but safety check)
        const top = x.p[x.p.length - 1];
        if (top.bomb) {
          // Placing on a bomb - only allow if block is smaller
          return piece.w < top.w;
        } else {
          // Placing above a bomb - this would cut off the bomb, so never allow larger blocks
          return piece.w < top.w;
        }
      }
      
      return true; // No bomb in stack, so placement is fine
    });
    
    // If we have no valid options after bomb avoidance, fall back to all available
    if (bombAvoidanceOptions.length === 0) {
      // This should rarely happen, but if it does, we'll use the original avail list
      console.warn('AI: No bomb-avoidance options available, using fallback');
    } else {
      // Use the filtered options for the rest of the logic
      avail = bombAvoidanceOptions;
    }
    
    // Priority 2: Special case - bomb match in queue
    if (isBombMatch) {
      const messyStacks = avail.filter(x => isStackMessy(x.p));
      if (messyStacks.length > 0) {
        return messyStacks[0].i;
      }
    }
    
    // Priority 3: Place on block exactly 1 size above
    const exactSizeOptions = avail.filter(x => wouldBeOnExactSize(x.p, piece));
    if (exactSizeOptions.length > 0) {
      // Prefer stacks with less height if multiple options
      exactSizeOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
      return exactSizeOptions[0].i;
    }
    
    // Priority 4: Place on larger block (but not exact size)
    const largerBlockOptions = avail.filter(x => wouldBeOnLargerBlock(x.p, piece));
    if (largerBlockOptions.length > 0) {
      // Prefer messy stacks, then by height
      const messyOptions = largerBlockOptions.filter(x => isStackMessy(x.p));
      const cleanOptions = largerBlockOptions.filter(x => !isStackMessy(x.p));
      
      if (messyOptions.length > 0) {
        // Choose messiest stack among messy options
        messyOptions.sort((a, b) => {
          // Count how many order violations each stack has
          const getViolations = (pole) => {
            let violations = 0;
            for (let i = pole.length - 1; i > 0; i--) {
              if (pole[i].w >= pole[i-1].w) violations++;
            }
            return violations;
          };
          return getViolations(b.p) - getViolations(a.p); // More violations = messier
        });
        return messyOptions[0].i;
      } else {
        // All stacks are clean, choose by height
        cleanOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
        return cleanOptions[0].i;
      }
    }
    
    // Priority 5: Place on smaller block or empty stack
    const remainingOptions = avail.filter(x => !wouldBeOnLargerBlock(x.p, piece));
    if (remainingOptions.length > 0) {
      // Prefer messy stacks, then by height
      const messyOptions = remainingOptions.filter(x => isStackMessy(x.p));
      const cleanOptions = remainingOptions.filter(x => !isStackMessy(x.p));
      
      if (messyOptions.length > 0) {
        // Choose messiest stack among messy options
        messyOptions.sort((a, b) => {
          const getViolations = (pole) => {
            let violations = 0;
            for (let i = pole.length - 1; i > 0; i--) {
              if (pole[i].w >= pole[i-1].w) violations++;
            }
            return violations;
          };
          return getViolations(b.p) - getViolations(a.p);
        });
        return messyOptions[0].i;
      } else {
        // All stacks are clean, choose by height
        cleanOptions.sort((a, b) => getStackHeight(a.p) - getStackHeight(b.p));
        return cleanOptions[0].i;
      }
    }
    
  } else {
    // BOMB LOGIC
    
    // Priority 1: Tallest, messiest stack
    const messyStacks = avail.filter(x => isStackMessy(x.p));
    if (messyStacks.length > 0) {
      // Sort by height first, then by messiness
      messyStacks.sort((a, b) => {
        const heightDiff = getStackHeight(b.p) - getStackHeight(a.p);
        if (Math.abs(heightDiff) > 0) return heightDiff;
        
        // If heights are equal, sort by messiness
        const getViolations = (pole) => {
          let violations = 0;
          for (let i = pole.length - 1; i > 0; i--) {
            if (pole[i].w >= pole[i-1].w) violations++;
          }
          return violations;
        };
        return getViolations(b.p) - getViolations(a.p);
      });
      return messyStacks[0].i;
    }
    
    // Priority 2: Must place on clean stack - choose lowest total value
    const cleanStacks = avail.filter(x => !isStackMessy(x.p));
    if (cleanStacks.length > 0) {
      cleanStacks.sort((a, b) => getStackValue(a.p) - getStackValue(b.p));
      return cleanStacks[0].i;
    }
  }
  
  // Fallback: return first available pole
  return avail[0].i;
}

function aiStep(){
  console.log('AI: aiStep called, placing:', placing, 'aiEnabled:', aiEnabled);
  
  if(placing) {
    console.log('AI: Waiting for placement to complete...');
    return;
  }
  
  // Safety check: if placing has been true for too long, reset it
  if (placing && Date.now() - lastPlacementTime > 10000) { // 10 second timeout
    console.warn('AI: Placement timeout detected, resetting placing flag');
    placing = false;
    
    // Re-enable hover effects and pointer events on all poles
    const allPoles = Array.from(gameDiv.children);
    allPoles.forEach(poleDiv => {
      poleDiv.style.pointerEvents = '';
      poleDiv.classList.remove('no-hover');
    });
  }
  
  // if game over, nothing to do
  const pick = choosePoleFor(nextQueue[0]);
  if(pick === null) { 
    console.log('AI: No valid move available, checking game over');
    checkGameOver(); 
    return; 
  }
  
  console.log('AI: Making move on pole', pick, 'with piece', nextQueue[0]);
  placeOnPole(pick);
}

// Try to load saved game state
console.log('=== GAME INITIALIZATION ===');
console.log('Attempting to load saved game state...');
const gameLoaded = loadGameState();
console.log('Load result:', gameLoaded ? 'SUCCESS' : 'FAILED - starting fresh game');



// initial render
render();

// Initialize animation speed and stack height
updateAnimationSpeed();
updateStackHeight();

// Initialize displays with proper formatting
updateScoreDisplay();
updateGoldDisplay();

// Set up auto-save system
console.log('Setting up auto-save system...');
setupAutoSave();
console.log('Auto-save system initialized');

// Safety check: ensure we start with exactly 4 poles
ensureCorrectPoleCount();

// Initialize debug pane - Block grid interface
document.addEventListener('DOMContentLoaded', () => {
  // Set initial selection to "No Block" option
  const noBlockOption = document.querySelector('.block-item[data-value="none"]');
  if (noBlockOption) {
    noBlockOption.classList.add('selected');
    customBlockSize = null;
    customBlockMode = false;
    const nextBlockElement = document.getElementById('nextBlockValue');
    nextBlockElement.textContent = 'Queue';
    nextBlockElement.removeAttribute('data-value');
  }
  
  // Initialize the target block display with proper styling
  const targetBlockEl = document.getElementById('targetBlock');
  if (targetBlockEl) {
    const targetValue = currentTargetBlockSize * 2;
    targetBlockEl.textContent = targetValue;
    targetBlockEl.setAttribute('data-value', targetValue);
  }
  
  // Initial render to set up the game display
  if (typeof render === 'function') {
    render();
  }
  if (typeof renderNext === 'function') {
    renderNext();
  }
});

if (bombToggle && bombStatus) {
  bombToggle.checked = false;
  bombStatus.textContent = 'No';
  customBlockBomb = false;
}

// Initialize debug auto-play controls
if (debugSpeedSlider) {
  debugSpeedSlider.value = currentSpeed;
}
updateDebugSpeedLabel();
updateAnimationSpeed();

// Initialize bomb conversion button state
updateBombConversionButtonState();

// Handle window resize for mobile responsiveness
window.addEventListener('resize', () => {
  console.log('Window resized to', window.innerWidth, 'x', window.innerHeight, '- updating stack heights');
  updateStackHeight();
});

// GitHub Pages redirect fix - if we're on the wrong page, redirect to the game
(function() {
  // Check if we're on the right page by looking for game elements
  if (!document.getElementById('game')) {
    // We're probably on the README page, redirect to the game
    window.location.href = window.location.href;
  }
})();

// Global safety check to ensure we always have exactly 4 poles
function ensureCorrectPoleCount() {
  if (poles.length !== 4) {
    console.error(`CRITICAL ERROR: Global pole count check found ${poles.length} poles instead of 4! Resetting to 4 poles.`);
    poles = [[],[],[],[]];
    // Force a re-render to fix the display
    render();
  }
  
  // Also check the DOM to ensure we have exactly 4 pole elements
  if (gameDiv && gameDiv.children.length !== 4) {
    console.error(`CRITICAL ERROR: DOM contains ${gameDiv.children.length} pole elements instead of 4! Re-rendering...`);
    render();
  }
}

// Run safety check every 5 seconds
setInterval(ensureCorrectPoleCount, 5000);

function testProbabilityDistribution() {
  console.log('=== Testing Probability Distribution ===');
  console.log('Current weights:', weights);
  console.log('Current probabilities:', probabilities);
  
  // Simulate 1000 random selections to test distribution
  const results = {};
  const iterations = 1000;
  
  for (let i = 0; i < iterations; i++) {
    const weight = getRandomWeight();
    results[weight] = (results[weight] || 0) + 1;
  }
  
  // Create the results table HTML
  let tableHTML = `
    <table class="prob-test-table">
      <thead>
        <tr>
          <th>Block</th>
          <th>Expected</th>
          <th>Actual</th>
          <th>Difference</th>
        </tr>
      </thead>
      <tbody>
  `;
  
  let totalExpected = 0;
  let totalActual = 0;
  
  for (const weight of weights) {
    const count = results[weight] || 0;
    const actualProb = count / iterations;
    const expectedProb = probabilities[weights.indexOf(weight)];
    const difference = Math.abs(actualProb - expectedProb);
    
    totalExpected += expectedProb;
    totalActual += actualProb;
    
    tableHTML += `
      <tr>
        <td class="block-value">${weight}</td>
        <td class="expected">${(expectedProb * 100).toFixed(2)}%</td>
        <td class="actual">${(actualProb * 100).toFixed(2)}%</td>
        <td class="difference">${(difference * 100).toFixed(2)}%</td>
      </tr>
    `;
    
    // Also log to console for debugging
    console.log(`Block ${weight}: Expected ${(expectedProb * 100).toFixed(2)}%, Got ${(actualProb * 100).toFixed(2)}%, Diff: ${(difference * 100).toFixed(2)}%`);
  }
  
  tableHTML += `
      </tbody>
    </table>
    
    <div class="prob-test-summary">
      <div class="total">Total Probability: ${(totalExpected * 100).toFixed(2)}% (Expected) vs ${(totalActual * 100).toFixed(2)}% (Actual)</div>
    </div>
  `;
  
  // Populate the modal content
  const contentDiv = document.getElementById('probTestContent');
  if (contentDiv) {
    contentDiv.innerHTML = tableHTML;
  }
  
  // Show the modal
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.remove('hidden');
  }
  
  console.log('=== End Test ===');
}

// Modal functionality
function showProbabilityTestModal() {
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.remove('hidden');
  }
}

function hideProbabilityTestModal() {
  const modal = document.getElementById('probTestModal');
  if (modal) {
    modal.classList.add('hidden');
  }
}

function logProbabilityState() {
  console.log('=== Current Probability State ===');
  console.log(`Total blocks available: ${weights.length}`);
  console.log('Block | Weight | Probability | Cumulative');
  console.log('------|--------|-------------|------------');
  
  let cumulative = 0;
  for (let i = 0; i < weights.length; i++) {
    cumulative += probabilities[i];
    console.log(`${i.toString().padStart(5)} | ${weights[i].toString().padStart(6)} | ${(probabilities[i] * 100).toFixed(2).padStart(11)}% | ${(cumulative * 100).toFixed(2).padStart(10)}%`);
  }
  
  console.log(`Total probability: ${(cumulative * 100).toFixed(2)}%`);
  console.log('=====================================');
}

// Test probabilities button
const testProbBtn = document.getElementById('testProbBtn');
testProbBtn.addEventListener('click', testProbabilityDistribution);

// Probability test modal close button
const probTestClose = document.getElementById('probTestClose');
if (probTestClose) {
  probTestClose.addEventListener('click', hideProbabilityTestModal);
}

// Close probability test modal when clicking outside
const probTestModal = document.getElementById('probTestModal');
if (probTestModal) {
  probTestModal.addEventListener('click', (e) => {
    if (e.target === probTestModal) {
      hideProbabilityTestModal();
    }
  });
}



// Add keyboard support for probability test modal
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (probTestModal && !probTestModal.classList.contains('hidden')) {
      hideProbabilityTestModal();
    }
  }
});
</script>
</body>
</html>
